{"version":3,"file":"index-QSxojIDE.js","sources":["../../src/types/index.ts","../../src/renderer/Renderer.ts","../../src/utils/constants.ts","../../src/game/InputManager.ts","../../src/utils/math.ts","../../src/entities/Player.ts","../../src/game/ScoringSystem.ts","../../src/game/CollisionSystem.ts","../../src/game/DifficultyManager.ts","../../src/patterns/PatternRegistry.ts","../../src/game/ToastManager.ts","../../src/game/PatternManager.ts","../../src/entities/WeaponOrb.ts","../../src/game/WeaponOrbSpawner.ts","../../src/weapons/WeaponRegistry.ts","../../src/weapons/Weapon.ts","../../src/weapons/NuclearBomb.ts","../../src/utils/storage.ts","../../src/game/Game.ts","../../src/entities/Dot.ts","../../src/patterns/Pattern.ts","../../src/patterns/ZombieSnow.ts","../../src/patterns/SweeperLine.ts","../../src/patterns/SparseGrid.ts","../../src/patterns/BouncingBall.ts","../../src/patterns/GatlingPoint.ts","../../src/patterns/BulletHell.ts","../../src/patterns/ContainmentRing.ts","../../src/patterns/Cyclone.ts","../../src/patterns/ClockSweep.ts","../../src/weapons/Blaster.ts","../../src/weapons/Chainsaw.ts","../../src/weapons/DotRepellent.ts","../../src/weapons/ElectricBomb.ts","../../src/weapons/FlameBurst.ts","../../src/weapons/HomingMissile.ts","../../src/weapons/IceBomb.ts","../../src/weapons/KineticBomb.ts","../../src/main.ts"],"sourcesContent":["export interface Vector2 {\n  x: number;\n  y: number;\n}\n\nexport enum GameState {\n  MENU = 'MENU',\n  PLAYING = 'PLAYING',\n  GAME_OVER = 'GAME_OVER',\n  PAUSED = 'PAUSED'\n}\n\nexport enum DotState {\n  SPAWNING = 'SPAWNING',\n  ACTIVE = 'ACTIVE',\n  FROZEN = 'FROZEN',\n  DEAD = 'DEAD'\n}\n\nexport enum PatternType {\n  ZOMBIE_SNOW = 'ZOMBIE_SNOW',\n  SWEEPER_LINE = 'SWEEPER_LINE',\n  SPARSE_GRID = 'SPARSE_GRID',\n  BOUNCING_BALL = 'BOUNCING_BALL',\n  GATLING_POINT = 'GATLING_POINT',\n  BULLET_HELL = 'BULLET_HELL',\n  CONTAINMENT_RING = 'CONTAINMENT_RING',\n  CYCLONE = 'CYCLONE',\n  CLOCK_SWEEP = 'CLOCK_SWEEP'\n}\n\nexport enum WeaponType {\n  KINETIC_BOMB = 'KINETIC_BOMB',\n  BLASTER = 'BLASTER',\n  ICE_BOMB = 'ICE_BOMB',\n  HOMING_MISSILE = 'HOMING_MISSILE',\n  NUCLEAR_BOMB = 'NUCLEAR_BOMB',\n  ELECTRIC_BOMB = 'ELECTRIC_BOMB',\n  DOT_REPELLENT = 'DOT_REPELLENT',\n  CHAINSAW = 'CHAINSAW',\n  FLAME_BURST = 'FLAME_BURST'\n}\n\nexport enum Difficulty {\n  EASY = 'EASY',\n  MEDIUM = 'MEDIUM',\n  HARD = 'HARD'\n}\n\nexport interface Entity {\n  position: Vector2;\n  velocity: Vector2;\n  radius: number;\n}\n\nexport interface HighscoreEntry {\n  score: number;\n  timestamp: number;\n}\n\nexport interface PlayerConfig {\n  hitboxRadius: number;\n  maxSpeed: number;\n}\n\nexport interface DotConfig {\n  radius: number;\n  spawnAnimationDuration: number;\n}\n\nexport interface WeaponOrbConfig {\n  radius: number;\n  alwaysOnArena: number;\n}\n\nexport interface Bounds {\n  width: number;\n  height: number;\n}\n\nexport interface DeathEvent {\n  message: string;\n  type: 'dot' | 'nuclear_bomb' | 'electric_bomb';\n  timestamp: number;\n}\n","interface CircleBatch {\n  x: number;\n  y: number;\n  radius: number;\n}\n\ninterface CircleOutlineBatch {\n  x: number;\n  y: number;\n  radius: number;\n  lineWidth: number;\n}\n\nexport class Renderer {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private width: number = 0;\n  private height: number = 0;\n  private dpr: number = 1;\n\n  private circleBatches: Map<string, CircleBatch[]> = new Map();\n  private outlineBatches: Map<string, CircleOutlineBatch[]> = new Map();\n\n  private static readonly TWO_PI = Math.PI * 2;\n  private scale: number = 1.3;\n  private onScaleChange?: () => void;\n\n  constructor(canvasId: string = 'game') {\n    const canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    if (!canvas) {\n      throw new Error(`Canvas element with id \"${canvasId}\" not found`);\n    }\n    this.canvas = canvas;\n    \n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get 2D context');\n    }\n    this.ctx = ctx;\n    \n    this.resize();\n    window.addEventListener('resize', () => this.resize());\n  }\n\n  resize(): void {\n    this.dpr = window.devicePixelRatio || 1;\n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n    \n    // Set canvas backing store to physical pixel size for crisp rendering\n    this.canvas.width = Math.floor(this.width * this.dpr);\n    this.canvas.height = Math.floor(this.height * this.dpr);\n    \n    // Keep CSS size at logical pixels\n    this.canvas.style.width = `${this.width}px`;\n    this.canvas.style.height = `${this.height}px`;\n  }\n\n  getBounds(): { width: number; height: number } {\n    return { width: this.width / this.scale, height: this.height / this.scale };\n  }\n\n  setScale(scale: number): void {\n    this.scale = scale;\n    if (this.onScaleChange) {\n      this.onScaleChange();\n    }\n  }\n\n  getScale(): number {\n    return this.scale;\n  }\n\n  onScaleChangeCallback(callback: () => void): void {\n    this.onScaleChange = callback;\n  }\n\n  clear(color: string = '#000000'): void {\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.save();\n    this.ctx.scale(this.dpr * this.scale, this.dpr * this.scale);\n  }\n\n  endFrame(): void {\n    this.ctx.restore();\n  }\n\n  // Queue a circle - renders when flushBatches() is called\n  drawCircle(x: number, y: number, radius: number, color: string): void {\n    let batch = this.circleBatches.get(color);\n    if (!batch) {\n      batch = [];\n      this.circleBatches.set(color, batch);\n    }\n    batch.push({ x, y, radius });\n  }\n\n  drawCircleOutline(x: number, y: number, radius: number, color: string, lineWidth: number = 2): void {\n    let batch = this.outlineBatches.get(color);\n    if (!batch) {\n      batch = [];\n      this.outlineBatches.set(color, batch);\n    }\n    batch.push({ x, y, radius, lineWidth });\n  }\n\n  // Must be called once per frame after all entities rendered\n  flushBatches(): void {\n    const ctx = this.ctx;\n    \n    ctx.fillStyle = '';\n    this.circleBatches.forEach((batch, color) => {\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      for (let i = 0; i < batch.length; i++) {\n        const c = batch[i];\n        ctx.moveTo(c.x + c.radius, c.y);\n        ctx.arc(c.x, c.y, c.radius, 0, Renderer.TWO_PI);\n      }\n      ctx.fill();\n    });\n    this.circleBatches.clear();\n    \n    ctx.strokeStyle = '';\n    this.outlineBatches.forEach((batch, color) => {\n      const byWidth = new Map<number, CircleOutlineBatch[]>();\n      for (let i = 0; i < batch.length; i++) {\n        const o = batch[i];\n        let group = byWidth.get(o.lineWidth);\n        if (!group) {\n          group = [];\n          byWidth.set(o.lineWidth, group);\n        }\n        group.push(o);\n      }\n      \n      byWidth.forEach((group, lineWidth) => {\n        ctx.strokeStyle = color;\n        ctx.lineWidth = lineWidth;\n        ctx.beginPath();\n        for (let i = 0; i < group.length; i++) {\n          const o = group[i];\n          ctx.moveTo(o.x + o.radius, o.y);\n          ctx.arc(o.x, o.y, o.radius, 0, Renderer.TWO_PI);\n        }\n        ctx.stroke();\n      });\n    });\n    this.outlineBatches.clear();\n  }\n\n  drawCircleImmediate(x: number, y: number, radius: number, color: string): void {\n    this.ctx.fillStyle = color;\n    this.ctx.beginPath();\n    this.ctx.arc(x, y, radius, 0, Renderer.TWO_PI);\n    this.ctx.fill();\n  }\n\n  drawLine(x1: number, y1: number, x2: number, y2: number, color: string, width: number = 2): void {\n    this.ctx.beginPath();\n    this.ctx.moveTo(x1, y1);\n    this.ctx.lineTo(x2, y2);\n    this.ctx.strokeStyle = color;\n    this.ctx.lineWidth = width;\n    this.ctx.stroke();\n  }\n\n  drawArrow(x: number, y: number, angle: number, length: number, color: string = '#00CC00'): void {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const endX = x + cos * length;\n    const endY = y + sin * length;\n    \n    const ctx = this.ctx;\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 3;\n    \n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n    \n    const headLength = 8;\n    const headAngle = Math.PI / 6;\n    \n    ctx.beginPath();\n    ctx.moveTo(endX, endY);\n    ctx.lineTo(\n      endX - headLength * Math.cos(angle - headAngle),\n      endY - headLength * Math.sin(angle - headAngle)\n    );\n    ctx.moveTo(endX, endY);\n    ctx.lineTo(\n      endX - headLength * Math.cos(angle + headAngle),\n      endY - headLength * Math.sin(angle + headAngle)\n    );\n    ctx.stroke();\n  }\n\n  drawRect(x: number, y: number, width: number, height: number, color: string): void {\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(x, y, width, height);\n  }\n\n  drawText(text: string, x: number, y: number, color: string = '#FFFFFF', fontSize: number = 16): void {\n    this.ctx.font = `${fontSize}px Arial`;\n    this.ctx.fillStyle = color;\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(text, x, y);\n  }\n\n  drawTextLeft(text: string, x: number, y: number, color: string = '#FFFFFF', fontSize: number = 16): void {\n    this.ctx.font = `${fontSize}px Arial`;\n    this.ctx.fillStyle = color;\n    this.ctx.textAlign = 'left';\n    this.ctx.textBaseline = 'top';\n    this.ctx.fillText(text, x, y);\n  }\n\n  drawPolygon(points: { x: number; y: number }[], color: string): void {\n    if (points.length < 3) return;\n    \n    const ctx = this.ctx;\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      ctx.lineTo(points[i].x, points[i].y);\n    }\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  getContext(): CanvasRenderingContext2D {\n    return this.ctx;\n  }\n}\n","export const PLAYER_VISUAL_RADIUS = 10;\nexport const PLAYER_HITBOX_RADIUS = PLAYER_VISUAL_RADIUS * 0.5;\nexport const PLAYER_MAX_SPEED = 800;\nexport const PLAYER_ARROW_LENGTH = 15;\n\nexport const DOT_RADIUS = 8;\nexport const DOT_SPAWN_ANIMATION_DURATION = 1000;\nexport const DOT_SPAWN_SCALE_MAX = 1.5;\n\nexport const WEAPON_ORB_RADIUS = 20;\nexport const WEAPON_ORB_COUNT = 3;\nexport const WEAPON_ORB_MIN_SPACING = 100;\n\nexport const WRAP_ENABLED = true;\n\nexport const SCORE_KILL = 10;\nexport const SCORE_PATTERN_BONUS_MIN = 50;\nexport const SCORE_PATTERN_BONUS_MAX = 200;\nexport const SCORE_TIME_DIVISOR = 10;\n\nexport const DIFFICULTY_EASY_MAX_SCORE = 500;\nexport const DIFFICULTY_MEDIUM_MAX_SCORE = 1500;\n\nexport const PATTERN_SELECTION_INTERVAL = 8000;\n\nexport const COLOR_PLAYER = '#00FF00';\nexport const COLOR_PLAYER_ARROW = '#00CC00';\nexport const COLOR_DOT = '#FF0000';\nexport const COLOR_DOT_SPAWNING = '#FF6666';\nexport const COLOR_DOT_FROZEN = '#00FFFF';\nexport const COLOR_BACKGROUND = '#000000';\n\nexport const WEAPON_COLORS: Record<string, string> = {\n  KINETIC_BOMB: '#FF6600',\n  BLASTER: '#9900FF',\n  ICE_BOMB: '#00CCFF',\n  HOMING_MISSILE: '#FFFF00',\n  NUCLEAR_BOMB: '#FF0000',\n  ELECTRIC_BOMB: '#00FFFF',\n  DOT_REPELLENT: '#808080',\n  CHAINSAW: '#0066FF',\n  FLAME_BURST: '#FF9900'\n};\n\nexport const TARGET_FPS = 60;\nexport const FRAME_TIME = 1000 / TARGET_FPS;\n","import { Vector2 } from '../types';\nimport { PLAYER_MAX_SPEED } from '../utils/constants';\n\nexport type PermissionState = 'unknown' | 'pending' | 'granted' | 'denied';\n\ninterface TiltBasis {\n  gamma: number;\n  beta: number;\n}\n\nexport class InputManager {\n  private velocity: Vector2 = { x: 0, y: 0 };\n  private permissionState: PermissionState = 'unknown';\n  private tiltBasis: TiltBasis | null = null;\n\n  constructor() {\n    this.checkPermissionAvailability();\n    this.trackScreenOrientation();\n  }\n\n  private trackScreenOrientation(): void {\n    window.addEventListener('orientationchange', () => {});\n  }\n\n  setTiltBasis(basis: TiltBasis): void {\n    this.tiltBasis = basis;\n  }\n\n  getCurrentTiltBasis(): TiltBasis | null {\n    return this.tiltBasis;\n  }\n\n  private checkPermissionAvailability(): void {\n    if (typeof (DeviceOrientationEvent as any).requestPermission === 'function') {\n      this.permissionState = 'pending';\n    } else if (window.DeviceOrientationEvent) {\n      this.permissionState = 'granted';\n      this.enableDeviceOrientation();\n    } else {\n      this.permissionState = 'denied';\n    }\n  }\n\n  async requestPermission(): Promise<boolean> {\n    if (this.permissionState === 'granted') {\n      return true;\n    }\n\n    if (typeof (DeviceOrientationEvent as any).requestPermission === 'function') {\n      try {\n        const permissionPromise = (DeviceOrientationEvent as any).requestPermission() as Promise<'granted' | 'denied' | 'prompt'>;\n        const permission = await permissionPromise;\n\n        if (permission === 'granted') {\n          this.permissionState = 'granted';\n          this.enableDeviceOrientation();\n          return true;\n        } else {\n          this.permissionState = 'denied';\n          return false;\n        }\n      } catch (error) {\n        console.error('Device orientation permission error:', error);\n        this.permissionState = 'denied';\n        return false;\n      }\n    }\n\n    return (this.permissionState as PermissionState) === 'granted';\n  }\n\n  private enableDeviceOrientation(): void {\n    window.addEventListener('deviceorientation', this.handleOrientation.bind(this));\n  }\n\n  private lastTilt: TiltBasis = { gamma: 0, beta: 45 };\n\n  calibrateTiltBasis(): void {\n    this.tiltBasis = { ...this.lastTilt };\n  }\n\n  private getScreenOrientation(): number {\n    if (screen.orientation) {\n      return screen.orientation.angle;\n    }\n    return 0;\n  }\n\n  private transformTiltToGameCoords(gamma: number, beta: number, orientation: number): { x: number; y: number } {\n    const tiltX = gamma;\n    const tiltY = beta - 45;\n    \n    switch (orientation) {\n      case 0:\n        return { x: tiltX, y: tiltY };\n      case 90:\n      case -270:\n        return { x: -tiltY, y: tiltX };\n      case 180:\n      case -180:\n        return { x: -tiltX, y: -tiltY };\n      case -90:\n      case 270:\n        return { x: tiltY, y: -tiltX };\n      default:\n        return { x: tiltX, y: tiltY };\n    }\n  }\n\n  private handleOrientation(event: DeviceOrientationEvent): void {\n    if (event.gamma === null || event.beta === null) {\n      return;\n    }\n    \n    const gamma = event.gamma;\n    const beta = event.beta;\n    this.lastTilt = { gamma, beta };\n    \n    const orientation = this.getScreenOrientation();\n    const reference = this.tiltBasis;\n    \n    let gammaDelta = gamma;\n    let betaDelta = beta - 45;\n    \n    if (reference !== null) {\n      gammaDelta = gamma - reference.gamma;\n      betaDelta = (beta - 45) - (reference.beta - 45);\n    }\n    \n    const gameCoords = this.transformTiltToGameCoords(gammaDelta, betaDelta + 45, orientation);\n    \n    const normalizedX = this.clamp(gameCoords.x / 22.5, -1, 1);\n    const normalizedY = this.clamp(gameCoords.y / 22.5, -1, 1);\n    \n    this.velocity.x = normalizedX * PLAYER_MAX_SPEED;\n    this.velocity.y = normalizedY * PLAYER_MAX_SPEED;\n  }\n\n  private clamp(value: number, min: number, max: number): number {\n    return Math.max(min, Math.min(max, value));\n  }\n\n  getVelocity(): Vector2 {\n    return { x: this.velocity.x, y: this.velocity.y };\n  }\n\n  getPermissionState(): PermissionState {\n    return this.permissionState;\n  }\n\n  needsPermissionRequest(): boolean {\n    return this.permissionState === 'pending';\n  }\n\n  destroy(): void {\n    window.removeEventListener('deviceorientation', this.handleOrientation.bind(this));\n  }\n}\n","import { Vector2, Bounds } from '../types';\n\nexport class Vec2 implements Vector2 {\n  constructor(public x: number = 0, public y: number = 0) {}\n\n  static from(v: Vector2): Vec2 {\n    return new Vec2(v.x, v.y);\n  }\n\n  add(other: Vector2): Vec2 {\n    return new Vec2(this.x + other.x, this.y + other.y);\n  }\n\n  subtract(other: Vector2): Vec2 {\n    return new Vec2(this.x - other.x, this.y - other.y);\n  }\n\n  multiply(scalar: number): Vec2 {\n    return new Vec2(this.x * scalar, this.y * scalar);\n  }\n\n  divide(scalar: number): Vec2 {\n    if (scalar === 0) throw new Error('Division by zero');\n    return new Vec2(this.x / scalar, this.y / scalar);\n  }\n\n  magnitude(): number {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  normalize(): Vec2 {\n    const mag = this.magnitude();\n    if (mag === 0) return new Vec2(0, 0);\n    return this.divide(mag);\n  }\n\n  dot(other: Vector2): number {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  angleTo(other: Vector2): number {\n    return Math.atan2(other.y - this.y, other.x - this.x);\n  }\n\n  clone(): Vec2 {\n    return new Vec2(this.x, this.y);\n  }\n\n  set(x: number, y: number): void {\n    this.x = x;\n    this.y = y;\n  }\n\n  addInPlace(other: Vector2): void {\n    this.x += other.x;\n    this.y += other.y;\n  }\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value));\n}\n\nexport function distance(a: Vector2, b: Vector2): number {\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function wrap(position: Vector2, bounds: Bounds): Vector2 {\n  let x = position.x;\n  let y = position.y;\n  if (bounds.width > 0 && bounds.height > 0) {\n    while (x < 0) x += bounds.width;\n    while (y < 0) y += bounds.height;\n    x = x % bounds.width;\n    y = y % bounds.height;\n  }\n  return { x, y };\n}\n\nexport function wrapInPlace(position: Vector2, bounds: Bounds): void {\n  if (bounds.width > 0 && bounds.height > 0) {\n    while (position.x < 0) position.x += bounds.width;\n    while (position.y < 0) position.y += bounds.height;\n    position.x = position.x % bounds.width;\n    position.y = position.y % bounds.height;\n  }\n}\n\nexport function circleCollision(\n  a: Vector2,\n  radiusA: number,\n  b: Vector2,\n  radiusB: number\n): boolean {\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  const distanceSq = dx * dx + dy * dy;\n  const radiiSum = radiusA + radiusB;\n  return distanceSq < radiiSum * radiiSum;\n}\n\nexport function lerp(a: number, b: number, t: number): number {\n  return a + (b - a) * t;\n}\n\nexport function randomRange(min: number, max: number): number {\n  return min + Math.random() * (max - min);\n}\n\nexport function randomPosition(bounds: Bounds, margin: number = 0): Vector2 {\n  return {\n    x: margin + Math.random() * (bounds.width - margin * 2),\n    y: margin + Math.random() * (bounds.height - margin * 2)\n  };\n}\n","import { Vector2, Bounds } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { Vec2, wrapInPlace } from '../utils/math';\nimport { PLAYER_HITBOX_RADIUS, PLAYER_VISUAL_RADIUS, PLAYER_ARROW_LENGTH, COLOR_PLAYER, COLOR_PLAYER_ARROW } from '../utils/constants';\n\nexport class Player {\n  position: Vec2;\n  velocity: Vector2 = { x: 0, y: 0 };\n  directionAngle: number = 0;\n  readonly hitboxRadius: number = PLAYER_HITBOX_RADIUS;\n\n  constructor(x: number, y: number) {\n    this.position = new Vec2(x, y);\n  }\n\n  update(dt: number, inputVelocity: Vector2, bounds: Bounds, shouldWrap: boolean = true): void {\n    this.velocity.x = inputVelocity.x;\n    this.velocity.y = inputVelocity.y;\n    \n    if (this.velocity.x !== 0 || this.velocity.y !== 0) {\n      this.directionAngle = Math.atan2(this.velocity.y, this.velocity.x);\n    }\n    \n    this.position.x += this.velocity.x * dt;\n    this.position.y += this.velocity.y * dt;\n    \n    if (shouldWrap) {\n      wrapInPlace(this.position, bounds);\n    } else {\n      this.position.x = Math.max(0, Math.min(bounds.width, this.position.x));\n      this.position.y = Math.max(0, Math.min(bounds.height, this.position.y));\n    }\n  }\n\n  setPosition(x: number, y: number): void {\n    this.position.x = x;\n    this.position.y = y;\n  }\n\n  render(renderer: Renderer): void {\n    renderer.drawCircleImmediate(\n      this.position.x,\n      this.position.y,\n      PLAYER_VISUAL_RADIUS,\n      COLOR_PLAYER\n    );\n    \n    const arrowStartX = this.position.x + Math.cos(this.directionAngle) * (PLAYER_VISUAL_RADIUS + 2);\n    const arrowStartY = this.position.y + Math.sin(this.directionAngle) * (PLAYER_VISUAL_RADIUS + 2);\n    \n    renderer.drawArrow(\n      arrowStartX,\n      arrowStartY,\n      this.directionAngle,\n      PLAYER_ARROW_LENGTH,\n      COLOR_PLAYER_ARROW\n    );\n  }\n\n  getPosition(): Vector2 {\n    return this.position;\n  }\n}\n","export class ScoringSystem {\n  private score: number = 0;\n  private kills: number = 0;\n  private startTime: number = 0;\n\n  start(): void {\n    this.score = 0;\n    this.kills = 0;\n    this.startTime = Date.now();\n  }\n\n  addKill(): void {\n    this.kills++;\n  }\n\n  addKills(count: number): void {\n    this.kills += count;\n  }\n\n  addPatternBonus(difficulty: string): void {\n    const bonuses = { EASY: 50, MEDIUM: 100, HARD: 200 };\n    this.score += bonuses[difficulty as keyof typeof bonuses] || 50;\n  }\n\n  getScore(): number {\n    const timeBonus = Math.floor((Date.now() - this.startTime) / 10000);\n    return this.score + this.kills * 10 + timeBonus;\n  }\n\n  getKills(): number {\n    return this.kills;\n  }\n\n  getTimeAlive(): number {\n    return Date.now() - this.startTime;\n  }\n}\n","import { Bounds } from '../types';\nimport { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponOrb } from '../entities/WeaponOrb';\nimport { circleCollision } from '../utils/math';\n\nconst CELL_SIZE = 100;\n\n// Pre-allocated array for nearby cell offsets - avoids allocation during collision checks\nconst NEARBY_OFFSETS = [\n  [-1, -1], [0, -1], [1, -1],\n  [-1, 0], [0, 0], [1, 0],\n  [-1, 1], [0, 1], [1, 1]\n];\n\nexport class CollisionSystem {\n  // Use numeric key instead of string to avoid allocations\n  private grid: Map<number, Dot[]> = new Map();\n  \n  // Pre-allocated array for nearby keys - reused each frame\n  private nearbyKeys: number[] = new Array(9);\n\n  constructor(_bounds: Bounds) {\n  }\n  \n  // Use numeric key: cellX * 10000 + cellY (assumes grid < 10000 cells wide)\n  private getCellKey(x: number, y: number): number {\n    const cellX = Math.floor(x / CELL_SIZE);\n    const cellY = Math.floor(y / CELL_SIZE);\n    return cellX * 10000 + cellY;\n  }\n  \n  private getNearbyKeys(x: number, y: number): number[] {\n    const cellX = Math.floor(x / CELL_SIZE);\n    const cellY = Math.floor(y / CELL_SIZE);\n    \n    for (let i = 0; i < 9; i++) {\n      const [dx, dy] = NEARBY_OFFSETS[i];\n      this.nearbyKeys[i] = (cellX + dx) * 10000 + (cellY + dy);\n    }\n    return this.nearbyKeys;\n  }\n  \n  rebuildGrid(dots: Dot[]): void {\n    // Clear and reuse map instead of creating new one\n    this.grid.clear();\n\n    for (let i = 0; i < dots.length; i++) {\n      const dot = dots[i];\n      if (!dot.isLethal() && !dot.isFrozen()) continue;\n\n      const pos = dot.getPosition();\n      const key = this.getCellKey(pos.x, pos.y);\n\n      let cell = this.grid.get(key);\n      if (!cell) {\n        cell = [];\n        this.grid.set(key, cell);\n      }\n\n      cell.push(dot);\n    }\n  }\n  \n  checkPlayerDotCollision(player: Player): Dot | null {\n    const playerPos = player.getPosition();\n    const playerRadius = player.hitboxRadius;\n    \n    const nearbyKeys = this.getNearbyKeys(playerPos.x, playerPos.y);\n    \n    for (let i = 0; i < 9; i++) {\n      const cell = this.grid.get(nearbyKeys[i]);\n      if (!cell) continue;\n      \n      for (let j = 0; j < cell.length; j++) {\n        const dot = cell[j];\n        const dotPos = dot.getPosition();\n        const dotRadius = dot.getEffectiveRadius();\n\n        if (circleCollision(playerPos, playerRadius, dotPos, dotRadius)) {\n          return dot;\n        }\n      }\n    }\n    \n    return null;\n  }\n  \n  checkPlayerOrbCollision(player: Player, orbs: WeaponOrb[]): WeaponOrb | null {\n    const playerPos = player.getPosition();\n    const playerRadius = player.hitboxRadius;\n    \n    for (let i = 0; i < orbs.length; i++) {\n      const orb = orbs[i];\n      if (!orb.isActive()) continue;\n      \n      const orbPos = orb.getPosition();\n      const orbRadius = orb.radius;\n      \n      if (circleCollision(playerPos, playerRadius, orbPos, orbRadius)) {\n        return orb;\n      }\n    }\n    \n    return null;\n  }\n\n  updateBounds(_bounds: Bounds): void {\n  }\n}\n","import { Difficulty } from '../types';\n\nexport class DifficultyManager {\n  private currentDifficulty: Difficulty = Difficulty.EASY;\n  private readonly mediumThreshold: number = 500;\n  private readonly hardThreshold: number = 1500;\n\n  update(score: number): void {\n    if (score >= this.hardThreshold) {\n      this.currentDifficulty = Difficulty.HARD;\n    } else if (score >= this.mediumThreshold) {\n      this.currentDifficulty = Difficulty.MEDIUM;\n    } else {\n      this.currentDifficulty = Difficulty.EASY;\n    }\n  }\n\n  getDifficulty(): Difficulty {\n    return this.currentDifficulty;\n  }\n\n  getSpawnRateMultiplier(): number {\n    const multipliers = {\n      [Difficulty.EASY]: 1.0,\n      [Difficulty.MEDIUM]: 1.5,\n      [Difficulty.HARD]: 2.0\n    };\n    return multipliers[this.currentDifficulty];\n  }\n\n  getMaxDots(): number {\n    const maxDots = {\n      [Difficulty.EASY]: 150,\n      [Difficulty.MEDIUM]: 225,\n      [Difficulty.HARD]: 300\n    };\n    return maxDots[this.currentDifficulty];\n  }\n}\n","import { PatternType } from '../types';\nimport type { Pattern } from './Pattern';\n\ntype PatternConstructor = new () => Pattern;\n\nclass PatternRegistryImpl {\n  private patterns: Map<PatternType, PatternConstructor> = new Map();\n\n  register(type: PatternType, patternClass: PatternConstructor): void {\n    this.patterns.set(type, patternClass);\n  }\n\n  create(type: PatternType): Pattern | null {\n    const PatternClass = this.patterns.get(type);\n    if (!PatternClass) return null;\n    return new PatternClass();\n  }\n\n  getAvailableTypes(): PatternType[] {\n    return Array.from(this.patterns.keys());\n  }\n}\n\nexport const PatternRegistry = new PatternRegistryImpl();\n","export interface ToastMessage {\n  id: number;\n  text: string;\n  type: 'info' | 'success' | 'warning' | 'error';\n  createdAt: number;\n  duration: number;\n}\n\nexport class ToastManager {\n  private toasts: ToastMessage[] = [];\n  private allMessages: ToastMessage[] = [];\n  private container: HTMLElement;\n  private errorOverlay: HTMLElement | null = null;\n  private nextId: number = 0;\n  private readonly maxToasts: number = 5;\n  private readonly defaultDuration: number = 3000;\n\n  constructor() {\n    this.container = document.createElement('div');\n    this.container.id = 'toast-container';\n    this.container.style.cssText = `\n      position: fixed;\n      bottom: 20px;\n      right: 20px;\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n      z-index: 1000;\n      pointer-events: none;\n      font-family: Arial, sans-serif;\n    `;\n    document.body.appendChild(this.container);\n  }\n\n  show(text: string, type: ToastMessage['type'] = 'info', duration?: number): void {\n    const toast: ToastMessage = {\n      id: this.nextId++,\n      text,\n      type,\n      createdAt: Date.now(),\n      duration: duration ?? this.defaultDuration\n    };\n\n    this.toasts.push(toast);\n    this.allMessages.push(toast);\n\n    if (this.allMessages.length > 100) {\n      this.allMessages = this.allMessages.slice(-50);\n    }\n\n    if (this.toasts.length > this.maxToasts) {\n      const removed = this.toasts.shift();\n      if (removed) {\n        this.removeToastElement(removed.id);\n      }\n    }\n\n    this.renderToast(toast);\n    this.scheduleRemoval(toast);\n  }\n\n  private renderToast(toast: ToastMessage): void {\n    const element = document.createElement('div');\n    element.id = `toast-${toast.id}`;\n    \n    const colors = this.getColorsForType(toast.type);\n    \n    element.style.cssText = `\n      background: ${colors.background};\n      color: ${colors.text};\n      padding: 10px 16px;\n      border-radius: 4px;\n      font-size: 14px;\n      max-width: 280px;\n      word-wrap: break-word;\n      opacity: 0;\n      transform: translateX(20px);\n      transition: opacity 0.3s ease, transform 0.3s ease;\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n      border-left: 3px solid ${colors.border};\n    `;\n    element.textContent = toast.text;\n\n    this.container.appendChild(element);\n\n    requestAnimationFrame(() => {\n      element.style.opacity = '1';\n      element.style.transform = 'translateX(0)';\n    });\n  }\n\n  private getColorsForType(type: ToastMessage['type']): { background: string; text: string; border: string } {\n    switch (type) {\n      case 'success':\n        return {\n          background: 'rgba(0, 100, 0, 0.9)',\n          text: '#90EE90',\n          border: '#00FF00'\n        };\n      case 'warning':\n        return {\n          background: 'rgba(100, 80, 0, 0.9)',\n          text: '#FFE4B5',\n          border: '#FFD700'\n        };\n      case 'error':\n        return {\n          background: 'rgba(100, 0, 0, 0.9)',\n          text: '#FFB6C1',\n          border: '#FF4444'\n        };\n      case 'info':\n      default:\n        return {\n          background: 'rgba(30, 30, 30, 0.9)',\n          text: '#E0E0E0',\n          border: '#888888'\n        };\n    }\n  }\n\n  private scheduleRemoval(toast: ToastMessage): void {\n    setTimeout(() => {\n      this.removeToast(toast.id);\n    }, toast.duration);\n  }\n\n  private removeToast(id: number): void {\n    const index = this.toasts.findIndex(t => t.id === id);\n    if (index !== -1) {\n      this.toasts.splice(index, 1);\n      this.removeToastElement(id);\n    }\n  }\n\n  private removeToastElement(id: number): void {\n    const element = document.getElementById(`toast-${id}`);\n    if (element) {\n      element.style.opacity = '0';\n      element.style.transform = 'translateX(20px)';\n      setTimeout(() => {\n        element.remove();\n      }, 300);\n    }\n  }\n\n  clear(): void {\n    this.toasts.forEach(toast => {\n      this.removeToastElement(toast.id);\n    });\n    this.toasts = [];\n    this.allMessages = [];\n  }\n\n  getRecentMessages(count: number = 5): ToastMessage[] {\n    return this.toasts.slice(-count);\n  }\n\n  getAllMessages(): ToastMessage[] {\n    return this.allMessages;\n  }\n\n  setupGlobalErrorHandler(): void {\n    window.addEventListener('error', (event) => {\n      const stack = event.error?.stack ?? 'No stack trace available';\n      this.showFatalError('Runtime Error', event.message, stack, event.filename, event.lineno, event.colno);\n    });\n\n    window.addEventListener('unhandledrejection', (event) => {\n      const error = event.reason;\n      const message = error instanceof Error ? error.message : String(error);\n      const stack = error instanceof Error ? (error.stack ?? 'No stack trace available') : 'No stack trace available';\n      this.showFatalError('Unhandled Promise Rejection', message, stack);\n    });\n  }\n\n  private showFatalError(title: string, message: string, stack: string, filename?: string, lineno?: number, colno?: number): void {\n    if (this.errorOverlay) return;\n\n    this.errorOverlay = document.createElement('div');\n    this.errorOverlay.id = 'fatal-error-overlay';\n    this.errorOverlay.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100vw;\n      height: 100vh;\n      background: rgba(0, 0, 0, 0.95);\n      z-index: 9999;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      justify-content: flex-start;\n      padding: 40px;\n      box-sizing: border-box;\n      font-family: 'Courier New', monospace;\n      overflow-y: auto;\n    `;\n\n    const content = document.createElement('div');\n    content.style.cssText = `\n      max-width: 900px;\n      width: 100%;\n      background: #1a1a1a;\n      border: 2px solid #ff4444;\n      border-radius: 8px;\n      padding: 30px;\n      box-shadow: 0 0 30px rgba(255, 68, 68, 0.3);\n    `;\n\n    const header = document.createElement('h1');\n    header.textContent = 'âš ï¸ ' + title;\n    header.style.cssText = `\n      color: #ff4444;\n      margin: 0 0 20px 0;\n      font-size: 24px;\n      font-family: Arial, sans-serif;\n    `;\n\n    const messageDiv = document.createElement('div');\n    messageDiv.textContent = message;\n    messageDiv.style.cssText = `\n      color: #ffffff;\n      font-size: 16px;\n      margin-bottom: 10px;\n      padding: 10px;\n      background: rgba(255, 68, 68, 0.1);\n      border-radius: 4px;\n      font-family: Arial, sans-serif;\n    `;\n\n    content.appendChild(header);\n    content.appendChild(messageDiv);\n\n    if (filename) {\n      const locationDiv = document.createElement('div');\n      locationDiv.textContent = `Location: ${filename}:${lineno ?? '?'}:${colno ?? '?'}`;\n      locationDiv.style.cssText = `\n        color: #aaaaaa;\n        font-size: 12px;\n        margin-bottom: 20px;\n        font-family: Arial, sans-serif;\n      `;\n      content.appendChild(locationDiv);\n    }\n\n    const stackHeader = document.createElement('div');\n    stackHeader.textContent = 'Stack Trace:';\n    stackHeader.style.cssText = `\n      color: #ff8844;\n      font-size: 14px;\n      margin: 20px 0 10px 0;\n      font-weight: bold;\n      font-family: Arial, sans-serif;\n    `;\n    content.appendChild(stackHeader);\n\n    const stackTrace = document.createElement('pre');\n    stackTrace.textContent = stack;\n    stackTrace.style.cssText = `\n      color: #cccccc;\n      font-size: 12px;\n      line-height: 1.5;\n      background: #0a0a0a;\n      padding: 15px;\n      border-radius: 4px;\n      overflow-x: auto;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n      max-height: 400px;\n      overflow-y: auto;\n      border: 1px solid #333;\n      margin: 0;\n    `;\n    content.appendChild(stackTrace);\n\n    const buttonContainer = document.createElement('div');\n    buttonContainer.style.cssText = `\n      display: flex;\n      gap: 10px;\n      margin-top: 20px;\n    `;\n\n    const reloadButton = document.createElement('button');\n    reloadButton.textContent = 'ðŸ”„ Reload Game';\n    reloadButton.style.cssText = `\n      padding: 12px 24px;\n      font-size: 14px;\n      background: #ff4444;\n      color: white;\n      border: none;\n      border-radius: 4px;\n      cursor: pointer;\n      font-family: Arial, sans-serif;\n      font-weight: bold;\n    `;\n    reloadButton.onmouseover = () => reloadButton.style.background = '#ff6666';\n    reloadButton.onmouseout = () => reloadButton.style.background = '#ff4444';\n    reloadButton.onclick = () => window.location.reload();\n\n    const copyButton = document.createElement('button');\n    copyButton.textContent = 'ðŸ“‹ Copy Error';\n    copyButton.style.cssText = `\n      padding: 12px 24px;\n      font-size: 14px;\n      background: #444444;\n      color: white;\n      border: none;\n      border-radius: 4px;\n      cursor: pointer;\n      font-family: Arial, sans-serif;\n      font-weight: bold;\n    `;\n    copyButton.onmouseover = () => copyButton.style.background = '#555555';\n    copyButton.onmouseout = () => copyButton.style.background = '#444444';\n    copyButton.onclick = () => {\n      const fullError = `${title}\\n${message}\\n${filename ? `Location: ${filename}:${lineno}:${colno}\\n` : ''}\\nStack Trace:\\n${stack}`;\n      navigator.clipboard.writeText(fullError).then(() => {\n        copyButton.textContent = 'âœ… Copied!';\n        setTimeout(() => copyButton.textContent = 'ðŸ“‹ Copy Error', 2000);\n      });\n    };\n\n    buttonContainer.appendChild(reloadButton);\n    buttonContainer.appendChild(copyButton);\n    content.appendChild(buttonContainer);\n\n    this.errorOverlay.appendChild(content);\n    document.body.appendChild(this.errorOverlay);\n\n    console.error(`[FATAL ERROR] ${title}:`, message, '\\nStack:', stack);\n  }\n}\n\nexport const toastManager = new ToastManager();\n","import { Pattern } from '../patterns/Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { PatternRegistry } from '../patterns/PatternRegistry';\nimport { Dot } from '../entities/Dot';\nimport { toastManager } from './ToastManager';\n\nconst PATTERN_DIFFICULTY_MAP: Map<PatternType, Difficulty> = new Map([\n  [PatternType.ZOMBIE_SNOW, Difficulty.EASY],\n  [PatternType.SPARSE_GRID, Difficulty.EASY],\n  [PatternType.CONTAINMENT_RING, Difficulty.EASY],\n  [PatternType.SWEEPER_LINE, Difficulty.MEDIUM],\n  [PatternType.GATLING_POINT, Difficulty.MEDIUM],\n  [PatternType.BOUNCING_BALL, Difficulty.MEDIUM],\n  [PatternType.BULLET_HELL, Difficulty.HARD],\n  [PatternType.CYCLONE, Difficulty.HARD],\n]);\n\nconst SCORE_THRESHOLDS = {\n  EASY_MAX: 500,\n  MEDIUM_MAX: 1500,\n};\n\nexport class PatternManager {\n  private activePatterns: Pattern[] = [];\n  private patternTimer: number = 0;\n  private nextPatternInterval: number = 3000;\n  private currentScore: number = 0;\n  private allDotsCache: Dot[] = [];\n\n  private readonly minInterval: number = 2000;\n  private readonly maxInterval: number = 4000;\n\n  constructor() {\n    this.nextPatternInterval = this.getRandomInterval();\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    this.patternTimer += dt * 1000;\n    if (this.patternTimer >= this.nextPatternInterval) {\n      this.patternTimer = 0;\n      this.nextPatternInterval = this.getRandomInterval();\n      const nextType = this.selectNextPattern();\n      if (nextType) {\n        this.spawnPattern(nextType, playerPosition, bounds);\n      }\n    }\n\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      const pattern = this.activePatterns[i];\n      pattern.tick(dt);\n      pattern.update(dt, playerPosition, bounds);\n    }\n\n    this.removeCompletedPatterns();\n    this.rebuildDotsCache();\n  }\n\n  addPattern(pattern: Pattern): void {\n    if (this.isPatternTypeActive(pattern.type)) {\n      return;\n    }\n    this.activePatterns.push(pattern);\n  }\n\n  removePattern(pattern: Pattern): void {\n    const index = this.activePatterns.indexOf(pattern);\n    if (index !== -1) {\n      pattern.clear();\n      this.activePatterns.splice(index, 1);\n    }\n  }\n\n  getActivePatterns(): Pattern[] {\n    return this.activePatterns;\n  }\n\n  getAllDots(): Dot[] {\n    return this.allDotsCache;\n  }\n\n  isAnyPatternActivelySpawning(): boolean {\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      if (this.activePatterns[i].isActivelySpawning()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private rebuildDotsCache(): void {\n    this.allDotsCache.length = 0;\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      const dots = this.activePatterns[i].getDots();\n      for (let j = 0; j < dots.length; j++) {\n        this.allDotsCache.push(dots[j]);\n      }\n    }\n  }\n\n  setScore(score: number): void {\n    this.currentScore = score;\n  }\n\n  getAvailablePatternTypes(): PatternType[] {\n    const availableTypes: PatternType[] = [];\n    const allTypes = PatternRegistry.getAvailableTypes();\n\n    for (const type of allTypes) {\n      const difficulty = PATTERN_DIFFICULTY_MAP.get(type);\n      if (!difficulty) continue;\n\n      if (this.isDifficultyAvailable(difficulty)) {\n        availableTypes.push(type);\n      }\n    }\n\n    return availableTypes;\n  }\n\n  selectNextPattern(): PatternType | null {\n    const availableTypes = this.getAvailablePatternTypes();\n    \n    const candidateTypes = availableTypes.filter(\n      type => !this.isPatternTypeActive(type)\n    );\n\n    if (candidateTypes.length === 0) {\n      return null;\n    }\n\n    const randomIndex = Math.floor(Math.random() * candidateTypes.length);\n    return candidateTypes[randomIndex];\n  }\n\n  spawnPattern(type: PatternType, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.isPatternTypeActive(type)) {\n      return;\n    }\n\n    const pattern = PatternRegistry.create(type);\n    if (!pattern) {\n      console.warn(`Failed to create pattern of type: ${type}`);\n      return;\n    }\n\n    toastManager.show(`Pattern: ${this.formatPatternName(type)}`, 'info');\n    pattern.spawn(playerPosition, bounds);\n    pattern.start();\n    this.activePatterns.push(pattern);\n  }\n\n  private isPatternTypeActive(type: PatternType): boolean {\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      if (this.activePatterns[i].type === type) return true;\n    }\n    return false;\n  }\n\n  private isDifficultyAvailable(difficulty: Difficulty): boolean {\n    switch (difficulty) {\n      case Difficulty.EASY:\n        return this.currentScore < SCORE_THRESHOLDS.EASY_MAX;\n      case Difficulty.MEDIUM:\n        return this.currentScore >= SCORE_THRESHOLDS.EASY_MAX;\n      case Difficulty.HARD:\n        return this.currentScore >= SCORE_THRESHOLDS.MEDIUM_MAX;\n      default:\n        return false;\n    }\n  }\n\n  private removeCompletedPatterns(): void {\n    for (let i = this.activePatterns.length - 1; i >= 0; i--) {\n      if (this.activePatterns[i].isComplete()) {\n        const completedPattern = this.activePatterns[i];\n        completedPattern.clear();\n        this.activePatterns.splice(i, 1);\n        toastManager.show(`Pattern ended: ${this.formatPatternName(completedPattern.type)}`, 'info');\n      }\n    }\n  }\n\n  clear(): void {\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      this.activePatterns[i].clear();\n    }\n    this.activePatterns = [];\n    this.patternTimer = 0;\n    this.allDotsCache.length = 0;\n  }\n\n  getPatternTimer(): number {\n    return this.patternTimer;\n  }\n\n  getPatternInterval(): number {\n    return this.nextPatternInterval;\n  }\n\n  private getRandomInterval(): number {\n    return this.minInterval + Math.random() * (this.maxInterval - this.minInterval);\n  }\n\n  private formatPatternName(type: PatternType): string {\n    return type\n      .toLowerCase()\n      .split('_')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n}\n","import { Vector2 } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { WeaponType } from '../types';\nimport { WEAPON_ORB_RADIUS, WEAPON_COLORS } from '../utils/constants';\n\nexport class WeaponOrb {\n  position: Vector2;\n  weaponType: WeaponType;\n  pickedUp: boolean = false;\n  readonly radius: number = WEAPON_ORB_RADIUS;\n\n  // Weapons that bounce when collided with\n  private static readonly BOUNCED_WEAPONS: WeaponType[] = [\n    WeaponType.NUCLEAR_BOMB,\n    WeaponType.ELECTRIC_BOMB\n  ];\n\n  // Bounce physics state for bounced weapons\n  private velocity: Vector2 = { x: 0, y: 0 };\n  private lastBounceTime: number = 0;\n  private readonly bounceCooldown: number = 100;\n\n  constructor(x: number, y: number, weaponType: WeaponType) {\n    this.position = { x, y };\n    this.weaponType = weaponType;\n  }\n\n  render(renderer: Renderer): void {\n    if (this.pickedUp) return;\n\n    const color = WEAPON_COLORS[this.weaponType] || '#FFFFFF';\n\n    renderer.drawCircleImmediate(\n      this.position.x,\n      this.position.y,\n      this.radius,\n      color\n    );\n\n    const isBouncedWeapon = WeaponOrb.BOUNCED_WEAPONS.includes(this.weaponType);\n    const borderColor = isBouncedWeapon ? '#9B30FF' : '#FFFFFF';\n\n    const ctx = renderer.getContext();\n    ctx.strokeStyle = borderColor;\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.arc(this.position.x, this.position.y, this.radius + 2, 0, Math.PI * 2);\n    ctx.stroke();\n\n    this.drawIcon(ctx, this.position.x, this.position.y, this.radius);\n  }\n\n  private drawIcon(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number): void {\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n    ctx.fillStyle = '#FFFFFF';\n\n    const iconScale = radius * 0.5;\n\n    switch (this.weaponType) {\n      case WeaponType.KINETIC_BOMB:\n        this.drawKineticBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.BLASTER:\n        this.drawBlasterIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.ICE_BOMB:\n        this.drawIceBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.HOMING_MISSILE:\n        this.drawHomingMissileIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.NUCLEAR_BOMB:\n        this.drawNuclearBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.ELECTRIC_BOMB:\n        this.drawElectricBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.DOT_REPELLENT:\n        this.drawDotRepellentIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.CHAINSAW:\n        this.drawChainsawIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.FLAME_BURST:\n        this.drawFlameBurstIcon(ctx, x, y, iconScale);\n        break;\n    }\n  }\n\n  private drawKineticBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.3, 0, Math.PI * 2);\n    ctx.fill();\n\n    for (let i = 0; i < 8; i++) {\n      const angle = (i / 8) * Math.PI * 2;\n      ctx.beginPath();\n      ctx.moveTo(x + Math.cos(angle) * scale * 0.4, y + Math.sin(angle) * scale * 0.4);\n      ctx.lineTo(x + Math.cos(angle) * scale * 0.8, y + Math.sin(angle) * scale * 0.8);\n      ctx.stroke();\n    }\n  }\n\n  private drawBlasterIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.fillRect(x - scale * 0.8, y - scale * 0.15, scale * 1.6, scale * 0.3);\n    ctx.fillRect(x - scale * 0.9, y - scale * 0.4, scale * 0.3, scale * 0.8);\n    ctx.fillRect(x + scale * 0.6, y - scale * 0.4, scale * 0.3, scale * 0.8);\n  }\n\n  private drawIceBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    for (let i = 0; i < 6; i++) {\n      const angle = (i / 6) * Math.PI * 2;\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(angle) * scale * 0.8, y + Math.sin(angle) * scale * 0.8);\n      ctx.stroke();\n      const branchX = x + Math.cos(angle) * scale * 0.5;\n      const branchY = y + Math.sin(angle) * scale * 0.5;\n      ctx.beginPath();\n      ctx.moveTo(branchX, branchY);\n      ctx.lineTo(branchX + Math.cos(angle + Math.PI / 4) * scale * 0.3, branchY + Math.sin(angle + Math.PI / 4) * scale * 0.3);\n      ctx.moveTo(branchX, branchY);\n      ctx.lineTo(branchX + Math.cos(angle - Math.PI / 4) * scale * 0.3, branchY + Math.sin(angle - Math.PI / 4) * scale * 0.3);\n      ctx.stroke();\n    }\n  }\n\n  private drawHomingMissileIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    const arrowSize = scale * 0.25;\n    const spacing = scale * 0.35;\n\n    for (let i = -1; i <= 1; i++) {\n      const arrowX = x + i * spacing;\n      const arrowY = y;\n      this.drawArrowUp(ctx, arrowX, arrowY, arrowSize);\n    }\n  }\n\n  private drawArrowUp(ctx: CanvasRenderingContext2D, x: number, y: number, size: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x, y - size);\n    ctx.lineTo(x - size * 0.5, y + size * 0.3);\n    ctx.lineTo(x + size * 0.5, y + size * 0.3);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private drawNuclearBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    const skullScale = scale * 0.7;\n\n    // Skull head (circle)\n    ctx.beginPath();\n    ctx.arc(x, y - skullScale * 0.1, skullScale * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Eye sockets (two black circles)\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.arc(x - skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(x + skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Nose (inverted triangle)\n    ctx.beginPath();\n    ctx.moveTo(x, y + skullScale * 0.05);\n    ctx.lineTo(x - skullScale * 0.08, y + skullScale * 0.2);\n    ctx.lineTo(x + skullScale * 0.08, y + skullScale * 0.2);\n    ctx.closePath();\n    ctx.fill();\n\n    // Jaw / teeth area\n    ctx.fillStyle = '#FFFFFF';\n    ctx.beginPath();\n    ctx.rect(x - skullScale * 0.25, y + skullScale * 0.25, skullScale * 0.5, skullScale * 0.2);\n    ctx.fill();\n\n    // Teeth lines\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 1.5;\n    for (let i = 1; i <= 2; i++) {\n      const teethX = x - skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX, y + skullScale * 0.25);\n      ctx.lineTo(teethX, y + skullScale * 0.45);\n      ctx.stroke();\n\n      const teethX2 = x + skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX2, y + skullScale * 0.25);\n      ctx.lineTo(teethX2, y + skullScale * 0.45);\n      ctx.stroke();\n    }\n\n    // Crossbones (X shape behind skull)\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 3;\n    ctx.lineCap = 'round';\n\n    // Bone 1 (backslash)\n    ctx.beginPath();\n    ctx.moveTo(x - skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x + skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    // Bone 2 (forward slash)\n    ctx.beginPath();\n    ctx.moveTo(x + skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x - skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    // Bone ends (small circles at ends of bones)\n    ctx.fillStyle = '#FFFFFF';\n    const boneEndRadius = skullScale * 0.1;\n    const boneEnds = [\n      { x: x - skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y + skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x - skullScale * 0.7, y: y + skullScale * 0.5 }\n    ];\n\n    for (const end of boneEnds) {\n      ctx.beginPath();\n      ctx.arc(end.x, end.y, boneEndRadius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  private drawElectricBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x + scale * 0.2, y - scale * 0.8);\n    ctx.lineTo(x - scale * 0.1, y - scale * 0.1);\n    ctx.lineTo(x + scale * 0.3, y - scale * 0.1);\n    ctx.lineTo(x - scale * 0.2, y + scale * 0.8);\n    ctx.lineTo(x, y + scale * 0.1);\n    ctx.lineTo(x - scale * 0.3, y + scale * 0.1);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private drawDotRepellentIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.3, 0, Math.PI * 2);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.6, 0, Math.PI * 2);\n    ctx.stroke();\n\n    for (let i = 0; i < 4; i++) {\n      const angle = (i / 4) * Math.PI * 2;\n      this.drawOutwardArrow(ctx, x, y, angle, scale);\n    }\n  }\n\n  private drawOutwardArrow(ctx: CanvasRenderingContext2D, x: number, y: number, angle: number, scale: number): void {\n    const arrowX = x + Math.cos(angle) * scale * 0.45;\n    const arrowY = y + Math.sin(angle) * scale * 0.45;\n    const size = scale * 0.2;\n\n    ctx.beginPath();\n    ctx.moveTo(arrowX + Math.cos(angle) * size, arrowY + Math.sin(angle) * size);\n    ctx.lineTo(arrowX + Math.cos(angle + 2.5) * size, arrowY + Math.sin(angle + 2.5) * size);\n    ctx.lineTo(arrowX + Math.cos(angle - 2.5) * size, arrowY + Math.sin(angle - 2.5) * size);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private drawChainsawIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.5, 0, Math.PI * 2);\n    ctx.stroke();\n\n    const numTeeth = 8;\n    for (let i = 0; i < numTeeth; i++) {\n      const angle = (i / numTeeth) * Math.PI * 2;\n      const innerR = scale * 0.5;\n      const outerR = scale * 0.7;\n      ctx.beginPath();\n      ctx.moveTo(x + Math.cos(angle - 0.15) * innerR, y + Math.sin(angle - 0.15) * innerR);\n      ctx.lineTo(x + Math.cos(angle) * outerR, y + Math.sin(angle) * outerR);\n      ctx.lineTo(x + Math.cos(angle + 0.15) * innerR, y + Math.sin(angle + 0.15) * innerR);\n      ctx.fill();\n    }\n\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  private drawFlameBurstIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x, y - scale * 0.8);\n    ctx.bezierCurveTo(\n      x - scale * 0.4, y - scale * 0.3,\n      x - scale * 0.6, y + scale * 0.2,\n      x - scale * 0.2, y + scale * 0.6\n    );\n    ctx.quadraticCurveTo(x, y + scale * 0.8, x + scale * 0.2, y + scale * 0.6);\n    ctx.bezierCurveTo(\n      x + scale * 0.6, y + scale * 0.2,\n      x + scale * 0.4, y - scale * 0.3,\n      x, y - scale * 0.8\n    );\n    ctx.fill();\n\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n    ctx.beginPath();\n    ctx.moveTo(x, y - scale * 0.4);\n    ctx.bezierCurveTo(\n      x - scale * 0.2, y,\n      x - scale * 0.3, y + scale * 0.3,\n      x, y + scale * 0.5\n    );\n    ctx.bezierCurveTo(\n      x + scale * 0.3, y + scale * 0.3,\n      x + scale * 0.2, y,\n      x, y - scale * 0.4\n    );\n    ctx.fill();\n  }\n\n  isCollidingWith(playerPosition: Vector2, playerRadius: number): boolean {\n    const dx = this.position.x - playerPosition.x;\n    const dy = this.position.y - playerPosition.y;\n    const distSq = dx * dx + dy * dy;\n    const radiiSum = this.radius + playerRadius;\n    return distSq < radiiSum * radiiSum;\n  }\n\n  getPosition(): Vector2 {\n    return this.position;\n  }\n\n  getWeaponType(): WeaponType {\n    return this.weaponType;\n  }\n\n  pickup(): void {\n    this.pickedUp = true;\n  }\n\n  isActive(): boolean {\n    return !this.pickedUp;\n  }\n\n\n  bounce(playerVelocity: Vector2, playerPosition: Vector2): boolean {\n    const now = Date.now();\n    if (now - this.lastBounceTime < this.bounceCooldown) {\n      return false;\n    }\n    this.lastBounceTime = now;\n\n    // Check if this is a bounced weapon\n    if (!WeaponOrb.BOUNCED_WEAPONS.includes(this.weaponType)) {\n      return false;\n    }\n\n    const dx = this.position.x - playerPosition.x;\n    const dy = this.position.y - playerPosition.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance === 0) {\n      this.velocity.x = playerVelocity.x;\n      this.velocity.y = playerVelocity.y;\n      return true;\n    }\n\n    // Collision normal (from player to orb center)\n    const nx = dx / distance;\n    const ny = dy / distance;\n\n    // Tangent vector (perpendicular to normal)\n    const tx = -ny;\n    const ty = nx;\n\n    // Decompose player velocity into normal and tangent components\n    const vDotN = playerVelocity.x * nx + playerVelocity.y * ny;\n    const vDotT = playerVelocity.x * tx + playerVelocity.y * ty;\n\n    // Transfer momentum: orb moves away based on collision angle\n    // - Normal component pushes orb away from player\n    // - Tangent component pushes orb sideways (creates the \"nudge\" effect)\n    const restitution = 0.8; // Energy transfer factor\n    const friction = 0.6;    // Tangential transfer factor\n\n    this.velocity.x = (nx * vDotN * restitution + tx * vDotT * friction);\n    this.velocity.y = (ny * vDotN * restitution + ty * vDotT * friction);\n\n    return true;\n  }\n\n  getVelocity(): Vector2 {\n    return this.velocity;\n  }\n\n  updatePosition(dt: number, bounds: { width: number; height: number }): void {\n    if (!WeaponOrb.BOUNCED_WEAPONS.includes(this.weaponType)) return;\n\n    this.position.x += this.velocity.x * dt;\n    this.position.y += this.velocity.y * dt;\n\n    const minX = this.radius;\n    const maxX = bounds.width - this.radius;\n    const minY = this.radius;\n    const maxY = bounds.height - this.radius;\n\n    if (this.position.x <= minX) {\n      this.velocity.x = Math.abs(this.velocity.x);\n      this.position.x = minX;\n    } else if (this.position.x >= maxX) {\n      this.velocity.x = -Math.abs(this.velocity.x);\n      this.position.x = maxX;\n    }\n\n    if (this.position.y <= minY) {\n      this.velocity.y = Math.abs(this.velocity.y);\n      this.position.y = minY;\n    } else if (this.position.y >= maxY) {\n      this.velocity.y = -Math.abs(this.velocity.y);\n      this.position.y = maxY;\n    }\n  }\n}\n","import { WeaponOrb } from '../entities/WeaponOrb';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport { WEAPON_ORB_RADIUS } from '../utils/constants';\n\nexport class WeaponOrbSpawner {\n  private orbs: WeaponOrb[] = [];\n  private readonly orbCount: number = 3;\n  private readonly minSpacing: number = 100;\n  private readonly playerAvoidRadius: number = 150;\n\n  initialize(bounds: Bounds, playerPosition: Vector2): void {\n    this.orbs = [];\n    for (let i = 0; i < this.orbCount; i++) {\n      this.spawnOrb(bounds, playerPosition);\n    }\n  }\n\n  update(bounds: Bounds, playerPosition: Vector2): void {\n    while (this.orbs.length < this.orbCount) {\n      this.spawnOrb(bounds, playerPosition);\n    }\n  }\n\n  getOrbs(): WeaponOrb[] {\n    return this.orbs;\n  }\n\n  removeOrb(orb: WeaponOrb): void {\n    const index = this.orbs.indexOf(orb);\n    if (index > -1) {\n      this.orbs.splice(index, 1);\n    }\n  }\n\n  spawnOrb(bounds: Bounds, playerPosition: Vector2): void {\n    const pos = this.getRandomPosition(bounds, playerPosition);\n    const type = this.getRandomWeaponType();\n    this.orbs.push(new WeaponOrb(pos.x, pos.y, type));\n  }\n\n  private getRandomPosition(bounds: Bounds, playerPosition: Vector2): Vector2 {\n    let attempts = 0;\n    while (attempts < 100) {\n      const x = WEAPON_ORB_RADIUS + Math.random() * (bounds.width - WEAPON_ORB_RADIUS * 2);\n      const y = WEAPON_ORB_RADIUS + Math.random() * (bounds.height - WEAPON_ORB_RADIUS * 2);\n\n      const dx = x - playerPosition.x;\n      const dy = y - playerPosition.y;\n      const playerDist = Math.sqrt(dx * dx + dy * dy);\n\n      if (playerDist >= this.playerAvoidRadius && this.isPositionValid({ x, y })) {\n        return { x, y };\n      }\n      attempts++;\n    }\n    return { x: bounds.width / 2, y: bounds.height / 2 };\n  }\n\n  private isPositionValid(pos: Vector2): boolean {\n    for (const orb of this.orbs) {\n      const dx = pos.x - orb.position.x;\n      const dy = pos.y - orb.position.y;\n      if (Math.sqrt(dx * dx + dy * dy) < this.minSpacing) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private getRandomWeaponType(): WeaponType {\n    const types = [\n      WeaponType.KINETIC_BOMB,\n      WeaponType.BLASTER,\n      WeaponType.ICE_BOMB,\n      WeaponType.HOMING_MISSILE,\n      WeaponType.NUCLEAR_BOMB,\n      WeaponType.ELECTRIC_BOMB,\n      WeaponType.DOT_REPELLENT,\n      WeaponType.CHAINSAW,\n      WeaponType.FLAME_BURST\n    ];\n    return types[Math.floor(Math.random() * types.length)];\n  }\n}\n","import { WeaponType } from '../types';\nimport type { Weapon } from './Weapon';\n\ntype WeaponConstructor = new () => Weapon;\n\nclass WeaponRegistryImpl {\n  private weapons: Map<WeaponType, WeaponConstructor> = new Map();\n\n  register(type: WeaponType, weaponClass: WeaponConstructor): void {\n    this.weapons.set(type, weaponClass);\n  }\n\n  create(type: WeaponType): Weapon | null {\n    const WeaponClass = this.weapons.get(type);\n    if (!WeaponClass) return null;\n    return new WeaponClass();\n  }\n\n  getAvailableTypes(): WeaponType[] {\n    return Array.from(this.weapons.keys());\n  }\n}\n\nexport const WeaponRegistry = new WeaponRegistryImpl();\n","import { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds } from '../types';\nimport type { Player } from '../entities/Player';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport abstract class Weapon {\n  abstract readonly type: WeaponType;\n\n  protected dots: Dot[] = [];\n  protected startTime: number = 0;\n  protected isStarted: boolean = false;\n  protected killedDots: number = 0;\n\n  abstract activate(player: Player, dots: Dot[]): void;\n  abstract update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void;\n  abstract render(renderer: Renderer): void;\n\n  // Handle collision with player (for bounceable weapons like Electric/Nuclear bomb)\n  // Returns true if collision was handled/bounced\n  handlePlayerCollision(_player: Player, _playerVelocity: { x: number; y: number }): boolean {\n    return false;\n  }\n\n  // Check if weapon is currently active (for collision detection)\n  isActive(): boolean {\n    return false;\n  }\n\n  // Get weapon position (for collision detection)\n  getPosition(): { x: number; y: number } {\n    return { x: 0, y: 0 };\n  }\n\n  // Get weapon radius (for collision detection)\n  getRadius(): number {\n    return 0;\n  }\n\n  getDots(): Dot[] {\n    return this.dots.filter(d => !d.isDead());\n  }\n\n  isComplete(): boolean {\n    return false;\n  }\n\n  start(): void {\n    this.startTime = Date.now();\n    this.isStarted = true;\n  }\n\n  getElapsedTime(): number {\n    return Date.now() - this.startTime;\n  }\n\n  clear(): void {\n    for (const dot of this.dots) {\n      dot.kill();\n    }\n    this.dots = [];\n  }\n\n  getKilledDots(): number {\n    return this.killedDots;\n  }\n\n  addKilledDot(): void {\n    this.killedDots++;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { toastManager } from '../game/ToastManager';\nimport { WEAPON_ORB_RADIUS } from '../utils/constants';\n\nexport class NuclearBomb extends Weapon {\n  readonly type = WeaponType.NUCLEAR_BOMB;\n\n  private state: 'DRIFTING' | 'EXPLODING' | 'COMPLETE' = 'DRIFTING';\n  private orbPosition: Vector2 = { x: 0, y: 0 };\n  private orbVelocity: Vector2 = { x: 0, y: 0 };\n  private readonly fuseTime: number = 4000;\n  private collisionCount: number = 0;\n  private explosionRadius: number = 0;\n  private explosionStartTime: number = 0;\n  private killedDotsInExplosion: Set<Dot> = new Set();\n  private _hasKilledPlayer: boolean = false;\n  private bounds: Bounds | null = null;\n\n  private readonly flashInterval: number = 100;\n  private readonly flashGap: number = 400;\n  private lastCollisionTime: number = 0;\n  private readonly collisionCooldown: number = 100;\n  private readonly orbRadius: number = WEAPON_ORB_RADIUS;\n\n  activate(player: Player, _dots: Dot[]): void {\n    this.dots = _dots;\n    this.start();\n    this.orbPosition = { x: player.position.x, y: player.position.y };\n    this.orbVelocity = { x: 0, y: 0 };\n  }\n\n  handlePlayerCollision(player: Player, playerVelocity: Vector2): boolean {\n    const now = Date.now();\n    if (now - this.lastCollisionTime < this.collisionCooldown) {\n      return false;\n    }\n    this.lastCollisionTime = now;\n\n    const dx = this.orbPosition.x - player.position.x;\n    const dy = this.orbPosition.y - player.position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    const minSpeed = 50;\n    const playerSpeed = Math.sqrt(playerVelocity.x ** 2 + playerVelocity.y ** 2);\n\n    if (playerSpeed < minSpeed) {\n      return false;\n    }\n\n    if (distance === 0) {\n      this.orbVelocity.x = playerVelocity.x;\n      this.orbVelocity.y = playerVelocity.y;\n      return true;\n    }\n\n    const nx = dx / distance;\n    const ny = dy / distance;\n    const tx = -ny;\n    const ty = nx;\n\n    const vDotN = playerVelocity.x * nx + playerVelocity.y * ny;\n    const vDotT = playerVelocity.x * tx + playerVelocity.y * ty;\n\n    const directness = vDotN / playerSpeed;\n\n    if (directness < 0.1) {\n      return false;\n    }\n\n    const velocityMultiplier = 1.5;\n\n    if (directness > 0.7) {\n      this.orbVelocity.x = playerVelocity.x * velocityMultiplier;\n      this.orbVelocity.y = playerVelocity.y * velocityMultiplier;\n    } else {\n      const forwardFactor = directness;\n      const sidewaysFactor = 1 - directness;\n\n      this.orbVelocity.x = (nx * vDotN * forwardFactor + tx * vDotT * sidewaysFactor) * velocityMultiplier;\n      this.orbVelocity.y = (ny * vDotN * forwardFactor + ty * vDotT * sidewaysFactor) * velocityMultiplier;\n    }\n\n    return true;\n  }\n\n  getPosition(): Vector2 {\n    return this.orbPosition;\n  }\n\n  getRadius(): number {\n    return this.orbRadius;\n  }\n\n  isActive(): boolean {\n    return this.state !== 'COMPLETE';\n  }\n\n  update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    this.bounds = bounds;\n\n    switch (this.state) {\n      case 'DRIFTING': {\n        const elapsedTime = this.getElapsedTime();\n\n        this.orbPosition.x += this.orbVelocity.x * dt;\n        this.orbPosition.y += this.orbVelocity.y * dt;\n\n        const minX = this.orbRadius;\n        const maxX = bounds.width - this.orbRadius;\n        const minY = this.orbRadius;\n        const maxY = bounds.height - this.orbRadius;\n\n        if (this.orbPosition.x <= minX) {\n          this.orbVelocity.x = Math.abs(this.orbVelocity.x);\n          this.orbPosition.x = minX;\n          this.collisionCount++;\n        } else if (this.orbPosition.x >= maxX) {\n          this.orbVelocity.x = -Math.abs(this.orbVelocity.x);\n          this.orbPosition.x = maxX;\n          this.collisionCount++;\n        }\n\n        if (this.orbPosition.y <= minY) {\n          this.orbVelocity.y = Math.abs(this.orbVelocity.y);\n          this.orbPosition.y = minY;\n          this.collisionCount++;\n        } else if (this.orbPosition.y >= maxY) {\n          this.orbVelocity.y = -Math.abs(this.orbVelocity.y);\n          this.orbPosition.y = maxY;\n          this.collisionCount++;\n        }\n\n        if (elapsedTime >= this.fuseTime || this.collisionCount >= 3) {\n          this.state = 'EXPLODING';\n          this.explosionStartTime = Date.now();\n          this.explosionRadius = 0.55 * bounds.width;\n          toastManager.show('Nuclear Bomb detonated!', 'warning');\n          this.killDotsInExplosion(dots);\n          this.checkAndKillPlayer(player);\n        }\n        break;\n      }\n      case 'EXPLODING': {\n        const explosionElapsed = Date.now() - this.explosionStartTime;\n        if (explosionElapsed > 500) {\n          this.state = 'COMPLETE';\n        }\n        break;\n      }\n      case 'COMPLETE': {\n        break;\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (!this.bounds) return;\n\n    switch (this.state) {\n      case 'DRIFTING': {\n        const elapsedTime = this.getElapsedTime();\n        const progress = Math.min(elapsedTime / this.fuseTime, 1);\n        const color = this.interpolateColor('#FF6600', '#FF0000', progress);\n\n        const warningExplosionRadius = 0.55 * this.bounds.width;\n\n        const ctx = renderer.getContext();\n\n        const warningStartTime = this.fuseTime - 1500;\n        if (elapsedTime >= warningStartTime) {\n          const warningElapsed = elapsedTime - warningStartTime;\n          const flash1Start = 0;\n          const flash2Start = this.flashInterval + this.flashGap;\n\n          let shouldShowFlash = false;\n\n          if (warningElapsed >= flash1Start && warningElapsed < flash1Start + this.flashInterval) {\n            shouldShowFlash = true;\n          } else if (warningElapsed >= flash2Start && warningElapsed < flash2Start + this.flashInterval) {\n            shouldShowFlash = true;\n          }\n\n          if (shouldShowFlash) {\n            ctx.fillStyle = 'rgba(255, 165, 0, 0.6)';\n            ctx.beginPath();\n            ctx.arc(this.orbPosition.x, this.orbPosition.y, warningExplosionRadius, 0, Math.PI * 2);\n            ctx.fill();\n          }\n        }\n\n        renderer.drawCircleImmediate(\n          this.orbPosition.x,\n          this.orbPosition.y,\n          this.orbRadius,\n          color\n        );\n\n        ctx.strokeStyle = '#9B30FF';\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.arc(this.orbPosition.x, this.orbPosition.y, this.orbRadius + 2, 0, Math.PI * 2);\n        ctx.stroke();\n\n        this.drawNuclearIcon(ctx, this.orbPosition.x, this.orbPosition.y, this.orbRadius * 0.5);\n        break;\n      }\n      case 'EXPLODING': {\n        const explosionElapsed = Date.now() - this.explosionStartTime;\n        if (explosionElapsed <= 500) {\n          const alpha = 0.8 - (explosionElapsed / 500) * 0.8;\n          renderer.drawCircle(\n            this.orbPosition.x,\n            this.orbPosition.y,\n            this.explosionRadius,\n            `rgba(255, 0, 0, ${alpha})`\n          );\n        }\n        break;\n      }\n      case 'COMPLETE': {\n        break;\n      }\n    }\n  }\n\n  private interpolateColor(color1: string, color2: string, factor: number): string {\n    const r1 = parseInt(color1.slice(1, 3), 16);\n    const g1 = parseInt(color1.slice(3, 5), 16);\n    const b1 = parseInt(color1.slice(5, 7), 16);\n\n    const r2 = parseInt(color2.slice(1, 3), 16);\n    const g2 = parseInt(color2.slice(3, 5), 16);\n    const b2 = parseInt(color2.slice(5, 7), 16);\n\n    const r = Math.round(r1 + (r2 - r1) * factor);\n    const g = Math.round(g1 + (g2 - g1) * factor);\n    const b = Math.round(b1 + (b2 - b1) * factor);\n\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n  }\n\n  private drawNuclearIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.fillStyle = '#FFFFFF';\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n\n    const skullScale = scale * 0.7;\n\n    ctx.beginPath();\n    ctx.arc(x, y - skullScale * 0.1, skullScale * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.arc(x - skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(x + skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.moveTo(x, y + skullScale * 0.05);\n    ctx.lineTo(x - skullScale * 0.08, y + skullScale * 0.2);\n    ctx.lineTo(x + skullScale * 0.08, y + skullScale * 0.2);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.fillStyle = '#FFFFFF';\n    ctx.beginPath();\n    ctx.rect(x - skullScale * 0.25, y + skullScale * 0.25, skullScale * 0.5, skullScale * 0.2);\n    ctx.fill();\n\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 1.5;\n    for (let i = 1; i <= 2; i++) {\n      const teethX = x - skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX, y + skullScale * 0.25);\n      ctx.lineTo(teethX, y + skullScale * 0.45);\n      ctx.stroke();\n\n      const teethX2 = x + skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX2, y + skullScale * 0.25);\n      ctx.lineTo(teethX2, y + skullScale * 0.45);\n      ctx.stroke();\n    }\n\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 3;\n    ctx.lineCap = 'round';\n\n    ctx.beginPath();\n    ctx.moveTo(x - skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x + skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(x + skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x - skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    ctx.fillStyle = '#FFFFFF';\n    const boneEndRadius = skullScale * 0.1;\n    const boneEnds = [\n      { x: x - skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y + skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x - skullScale * 0.7, y: y + skullScale * 0.5 }\n    ];\n\n    for (const end of boneEnds) {\n      ctx.beginPath();\n      ctx.arc(end.x, end.y, boneEndRadius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  hasKilledPlayer(): boolean {\n    return this._hasKilledPlayer;\n  }\n\n  private killDotsInExplosion(dots: Dot[]): void {\n    for (const dot of dots) {\n      if (dot.isDead() || this.killedDotsInExplosion.has(dot)) continue;\n\n      const pos = dot.getPosition();\n      const dx = pos.x - this.orbPosition.x;\n      const dy = pos.y - this.orbPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.explosionRadius) {\n        dot.kill();\n        this.addKilledDot();\n        this.killedDotsInExplosion.add(dot);\n      }\n    }\n  }\n\n  private checkAndKillPlayer(player: Player): void {\n    if (this._hasKilledPlayer) return;\n\n    const dx = player.position.x - this.orbPosition.x;\n    const dy = player.position.y - this.orbPosition.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance <= this.explosionRadius) {\n      this._hasKilledPlayer = true;\n    }\n  }\n}\n","import { HighscoreEntry } from '../types';\n\nconst STORAGE_KEY = 'tilt-to-live-highscores';\nconst MAX_HIGHSCORES = 10;\n\n/**\n * Get all highscores from localStorage\n * Returns empty array if none exist\n */\nexport function getHighscores(): HighscoreEntry[] {\n  try {\n    const data = localStorage.getItem(STORAGE_KEY);\n    if (!data) return [];\n\n    const scores = JSON.parse(data) as HighscoreEntry[];\n    // Ensure sorted descending by score\n    return scores.sort((a, b) => b.score - a.score);\n  } catch (error) {\n    console.error('Failed to load highscores:', error);\n    return [];\n  }\n}\n\n/**\n * Add a new highscore\n * Maintains top 10, sorted descending\n * Returns the rank (1-based) or -1 if not in top 10\n */\nexport function addHighscore(score: number): number {\n  const highscores = getHighscores();\n\n  const newEntry: HighscoreEntry = {\n    score,\n    timestamp: Date.now()\n  };\n\n  // Add new score\n  highscores.push(newEntry);\n\n  // Sort descending by score\n  highscores.sort((a, b) => b.score - a.score);\n\n  // Keep only top 10\n  const trimmed = highscores.slice(0, MAX_HIGHSCORES);\n\n  // Find rank of new score\n  const rank = trimmed.findIndex(e => e.timestamp === newEntry.timestamp && e.score === score) + 1;\n\n  // Save to localStorage\n  try {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmed));\n  } catch (error) {\n    console.error('Failed to save highscores:', error);\n  }\n\n  return rank > 0 ? rank : -1;\n}\n\n/**\n * Check if a score would make the top 10\n */\nexport function isHighscore(score: number): boolean {\n  const highscores = getHighscores();\n\n  // If we have less than 10, any score qualifies\n  if (highscores.length < MAX_HIGHSCORES) return true;\n\n  // Check if score beats the lowest\n  return score > highscores[highscores.length - 1].score;\n}\n\n/**\n * Clear all highscores\n * Use for testing/reset\n */\nexport function clearHighscores(): void {\n  try {\n    localStorage.removeItem(STORAGE_KEY);\n  } catch (error) {\n    console.error('Failed to clear highscores:', error);\n  }\n}\n\n/**\n * Format highscore list for display\n * Returns array of formatted strings\n */\nexport function formatHighscores(entries: HighscoreEntry[]): string[] {\n  return entries.map((entry) => {\n    const date = new Date(entry.timestamp);\n    const dateStr = date.toLocaleDateString();\n    return `${entry.score} pts - ${dateStr}`;\n  });\n}\n\n/**\n * Get the highest score (for display purposes)\n */\nexport function getTopScore(): number {\n  const scores = getHighscores();\n  return scores.length > 0 ? scores[0].score : 0;\n}\n","import { GameState, Bounds, type DeathEvent } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { InputManager } from './InputManager';\nimport { Player } from '../entities/Player';\nimport { ScoringSystem } from './ScoringSystem';\nimport { CollisionSystem } from './CollisionSystem';\nimport { DifficultyManager } from './DifficultyManager';\nimport { PatternManager } from './PatternManager';\nimport { WeaponOrbSpawner } from './WeaponOrbSpawner';\nimport { WeaponRegistry } from '../weapons/WeaponRegistry';\nimport type { Weapon } from '../weapons/Weapon';\nimport { NuclearBomb } from '../weapons/NuclearBomb';\nimport { COLOR_BACKGROUND, FRAME_TIME } from '../utils/constants';\nimport { getHighscores, addHighscore } from '../utils/storage';\nimport { toastManager } from './ToastManager';\n\nexport class Game {\n  private renderer: Renderer;\n  private input: InputManager;\n  private state: GameState = GameState.MENU;\n  private lastFrameTime: number = 0;\n  private isPaused: boolean = false;\n  private accumulator: number = 0;\n\n  private player: Player | null = null;\n\n  private bounds: Bounds;\n  private timeAlive: number = 0;\n\n  private scoringSystem: ScoringSystem = new ScoringSystem();\n  private collisionSystem: CollisionSystem;\n  private difficultyManager: DifficultyManager = new DifficultyManager();\n  private patternManager: PatternManager = new PatternManager();\n  private orbSpawner: WeaponOrbSpawner = new WeaponOrbSpawner();\n  private activeWeapons: Weapon[] = [];\n  private lastDeathEvent: DeathEvent | null = null;\n  \n  private menuElement: HTMLElement;\n  private gameOverElement: HTMLElement;\n  private permissionElement: HTMLElement;\n  private newGameBtn: HTMLElement;\n  private playAgainBtn: HTMLElement;\n  private enableMotionBtn: HTMLElement;\n  private finalScoreElement: HTMLElement;\n  private newHighscoreElement: HTMLElement;\n  \n  constructor() {\n    this.renderer = new Renderer('game');\n    this.input = new InputManager();\n    this.bounds = this.renderer.getBounds();\n    this.collisionSystem = new CollisionSystem(this.bounds);\n    \n    this.menuElement = document.getElementById('menu')!;\n    this.gameOverElement = document.getElementById('game-over')!;\n    this.permissionElement = document.getElementById('permission-prompt')!;\n    this.newGameBtn = document.getElementById('new-game-btn')!;\n    this.playAgainBtn = document.getElementById('play-again-btn')!;\n    this.enableMotionBtn = document.getElementById('enable-motion-btn')!;\n    this.finalScoreElement = document.getElementById('final-score')!;\n    this.newHighscoreElement = document.getElementById('new-highscore')!;\n    \n    this.setupEventListeners();\n    this.checkPlatform();\n    this.gameLoop(0);\n    this.displayMenuHighscores();\n  }\n  \n  private checkPlatform(): void {\n    const isDesktop = !('ontouchstart' in window) && \n                      !('DeviceOrientationEvent' in window);\n    if (isDesktop) {\n      this.showElement('desktop-warning', true);\n      return;\n    }\n    this.checkOrientation();\n    window.addEventListener('orientationchange', () => this.checkOrientation());\n    window.addEventListener('resize', () => this.checkOrientation());\n  }\n  \n  private checkOrientation(): void {\n    const isLandscape = window.innerWidth > window.innerHeight;\n    this.showElement('landscape-warning', isLandscape && this.state === GameState.PLAYING);\n  }\n  \n  private showElement(id: string, show: boolean): void {\n    const el = document.getElementById(id);\n    if (el) el.style.display = show ? 'flex' : 'none';\n  }\n\n  private displayMenuHighscores(): void {\n    const menuHighscoreList = document.getElementById('menu-highscores');\n    if (menuHighscoreList) {\n      const highscores = getHighscores();\n      if (highscores.length === 0) {\n        menuHighscoreList.innerHTML = '<li style=\"color: #666;\">No scores yet</li>';\n      } else {\n        menuHighscoreList.innerHTML = highscores\n          .slice(0, 10)\n          .map((h, i) => `<li>${i + 1}. ${h.score}</li>`)\n          .join('');\n      }\n    }\n  }\n  \n  private setupEventListeners(): void {\n    this.newGameBtn.addEventListener('click', () => this.handleNewGameClick());\n    this.playAgainBtn.addEventListener('click', () => this.handleNewGameClick());\n    this.enableMotionBtn.addEventListener('click', () => this.requestMotionPermission());\n    \n    window.addEventListener('resize', () => {\n      this.bounds = this.renderer.getBounds();\n    });\n    \n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden && this.state === GameState.PLAYING) {\n        this.pause();\n      } else if (!document.hidden && this.state === GameState.PAUSED) {\n        this.resume();\n      }\n    });\n  }\n  \n  private async handleNewGameClick(): Promise<void> {\n    if (this.input.needsPermissionRequest()) {\n      this.menuElement.classList.add('hidden');\n      this.permissionElement.style.display = 'flex';\n      return;\n    }\n    \n    this.startGame();\n  }\n  \n  private async requestMotionPermission(): Promise<void> {\n    const granted = await this.input.requestPermission();\n    \n    if (granted) {\n      this.permissionElement.style.display = 'none';\n      this.startGame();\n    } else {\n      alert('Motion permission denied. The game requires device motion to play.');\n    }\n  }\n  \n  startGame(): void {\n    this.state = GameState.PLAYING;\n    this.timeAlive = 0;\n    this.lastDeathEvent = null;\n\n    this.scoringSystem.start();\n\n    this.collisionSystem.updateBounds(this.bounds);\n\n    const centerX = this.bounds.width / 2;\n    const centerY = this.bounds.height / 2;\n    this.player = new Player(centerX, centerY);\n\n    this.patternManager.clear();\n    this.orbSpawner.initialize(this.bounds, this.player.getPosition());\n    this.activeWeapons = [];\n\n    this.input.calibrateTiltBasis();\n\n    this.menuElement.classList.add('hidden');\n    this.gameOverElement.classList.add('hidden');\n    \n    toastManager.clear();\n  }\n  \n  private handleGameOver(): void {\n    const finalScore = this.scoringSystem.getScore();\n    this.state = GameState.GAME_OVER;\n\n    this.finalScoreElement.textContent = `Score: ${finalScore}`;\n\n    // Save highscore and check if it's a new high score\n    const rank = addHighscore(finalScore);\n    const isNewHighscore = rank > 0 && rank <= 3;\n    \n    // Show \"New High Score!\" message if applicable\n    if (isNewHighscore) {\n      this.newHighscoreElement.textContent = rank === 1 ? 'New #1 High Score!' : `New #${rank} High Score!`;\n      this.newHighscoreElement.style.display = 'block';\n    } else {\n      this.newHighscoreElement.style.display = 'none';\n    }\n\n    // Display highscores on death screen\n    const highscoreList = document.getElementById('gameover-highscores');\n    if (highscoreList) {\n      const highscores = getHighscores();\n      highscoreList.innerHTML = highscores\n        .slice(0, 10)\n        .map((h, i) => {\n          const isCurrentScore = rank > 0 && i + 1 === rank;\n          const style = isCurrentScore ? ' style=\"color: #FFD700; font-weight: bold;\"' : '';\n          return `<li${style}>${i + 1}. ${h.score}</li>`;\n        })\n        .join('');\n    }\n\n    const deathReasonElement = document.getElementById('death-reason');\n    if (deathReasonElement) {\n      deathReasonElement.textContent = this.lastDeathEvent?.message ?? 'Unknown';\n    }\n\n    const recentToastsList = document.getElementById('recent-toasts');\n    if (recentToastsList) {\n      const allMessages = toastManager.getAllMessages();\n      recentToastsList.innerHTML = allMessages.length > 0\n        ? allMessages.map(msg => `<li class=\"toast-${msg.type}\">${msg.text}</li>`).join('')\n        : '<li class=\"toast-info\">No recent events</li>';\n    }\n\n    this.gameOverElement.classList.remove('hidden');\n  }\n\n  pause(): void {\n    this.isPaused = true;\n  }\n\n  resume(): void {\n    this.isPaused = false;\n    this.lastFrameTime = performance.now();\n  }\n\n  private gameLoop = (currentTime: number): void => {\n    if (this.state !== GameState.PLAYING || this.isPaused) {\n      requestAnimationFrame(this.gameLoop);\n      return;\n    }\n    const deltaTime = currentTime - this.lastFrameTime;\n    this.lastFrameTime = currentTime;\n\n    this.accumulator += deltaTime;\n\n    while (this.accumulator >= FRAME_TIME) {\n      this.update(FRAME_TIME / 1000);\n      this.accumulator -= FRAME_TIME;\n    }\n\n    this.render();\n    requestAnimationFrame(this.gameLoop);\n  };\n  \n  private update(dt: number): void {\n    if (!this.player) return;\n\n    this.timeAlive += dt;\n\n    const velocity = this.input.getVelocity();\n    this.player.update(dt, velocity, this.bounds);\n\n    const score = this.scoringSystem.getScore();\n    this.difficultyManager.update(score);\n    this.patternManager.setScore(score);\n\n    this.patternManager.update(dt, this.player.getPosition(), this.bounds);\n\n    // If no dots and no pattern is actively spawning, throw in a new pattern\n    const allDots = this.patternManager.getAllDots();\n    if (allDots.length === 0 && !this.patternManager.isAnyPatternActivelySpawning()) {\n      const nextType = this.patternManager.selectNextPattern();\n      if (nextType) {\n        this.patternManager.spawnPattern(nextType, this.player.getPosition(), this.bounds);\n      }\n    }\n\n    this.orbSpawner.update(this.bounds, this.player.getPosition());\n\n    this.collisionSystem.rebuildGrid(allDots);\n\n    const orbs = this.orbSpawner.getOrbs();\n\n    // Update bounced weapon orb positions\n    for (const orb of orbs) {\n      orb.updatePosition(dt, this.bounds);\n    }\n\n    const collidingOrb = this.collisionSystem.checkPlayerOrbCollision(this.player, orbs);\n    if (collidingOrb) {\n      // Try to bounce bounced weapons first\n      const playerVelocity = this.input.getVelocity();\n      const bounced = collidingOrb.bounce(playerVelocity, this.player.getPosition());\n\n      if (!bounced) {\n        // Not a bounced weapon or bounce failed - pick it up\n        const weaponType = collidingOrb.getWeaponType();\n        const weapon = WeaponRegistry.create(weaponType);\n        if (weapon) {\n          weapon.activate(this.player, allDots);\n          this.activeWeapons.push(weapon);\n          collidingOrb.pickup();\n          this.orbSpawner.removeOrb(collidingOrb);\n          toastManager.show(`Picked up ${this.formatWeaponName(weaponType)}`, 'success');\n        }\n      }\n    }\n\n    for (let i = this.activeWeapons.length - 1; i >= 0; i--) {\n      const weapon = this.activeWeapons[i];\n      weapon.update(dt, this.player, allDots, this.bounds);\n      \n      // Check for player collision with active weapon (for bounceable weapons like Electric/Nuclear bomb)\n      if (weapon.isActive()) {\n        const playerPos = this.player.getPosition();\n        const weaponPos = weapon.getPosition();\n        const weaponRadius = weapon.getRadius();\n        const playerRadius = this.player.hitboxRadius;\n        \n        const dx = weaponPos.x - playerPos.x;\n        const dy = weaponPos.y - playerPos.y;\n        const distSq = dx * dx + dy * dy;\n        const radiiSum = weaponRadius + playerRadius;\n        \n        if (distSq < radiiSum * radiiSum) {\n          const playerVelocity = this.input.getVelocity();\n          weapon.handlePlayerCollision(this.player, playerVelocity);\n        }\n      }\n      \n      if (weapon instanceof NuclearBomb && weapon.hasKilledPlayer()) {\n        this.lastDeathEvent = {\n          message: 'Killed by Nuclear Bomb explosion',\n          type: 'nuclear_bomb',\n          timestamp: Date.now()\n        };\n        this.handleGameOver();\n        return;\n      }\n      \n      if (weapon.isComplete()) {\n        this.scoringSystem.addKills(weapon.getKilledDots());\n        this.activeWeapons.splice(i, 1);\n      }\n    }\n\n    const collidingDot = this.collisionSystem.checkPlayerDotCollision(this.player);\n    if (collidingDot) {\n      if (collidingDot.isLethal()) {\n        this.lastDeathEvent = {\n          message: 'Hit by a red dot',\n          type: 'dot',\n          timestamp: Date.now()\n        };\n        this.handleGameOver();\n      } else if (collidingDot.isFrozen()) {\n        collidingDot.kill();\n        this.scoringSystem.addKills(1);\n      }\n    }\n  }\n  \n  private render(): void {\n    this.renderer.clear(COLOR_BACKGROUND);\n\n    const orbs = this.orbSpawner.getOrbs();\n    for (let i = 0; i < orbs.length; i++) {\n      orbs[i].render(this.renderer);\n    }\n\n    const allDots = this.patternManager.getAllDots();\n    for (let i = 0; i < allDots.length; i++) {\n      allDots[i].render(this.renderer);\n    }\n\n    for (let i = 0; i < this.activeWeapons.length; i++) {\n      this.activeWeapons[i].render(this.renderer);\n    }\n\n    if (this.player) {\n      this.player.render(this.renderer);\n    }\n\n    this.renderer.flushBatches();\n    this.renderer.endFrame();\n  }\n  \n  getState(): GameState {\n    return this.state;\n  }\n  \n  getScore(): number {\n    return this.scoringSystem.getScore();\n  }\n\n  private formatWeaponName(type: string): string {\n    return type\n      .toLowerCase()\n      .split('_')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n}\n","import { Vector2, Bounds, DotState, PatternType } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { Vec2, wrapInPlace } from '../utils/math';\nimport { DOT_RADIUS, DOT_SPAWN_ANIMATION_DURATION, DOT_SPAWN_SCALE_MAX, COLOR_DOT, COLOR_DOT_SPAWNING, COLOR_DOT_FROZEN } from '../utils/constants';\n\nconst FROZEN_BORDER_MAX_THICKNESS = 8;\nconst FROZEN_BORDER_COLOR = '#00CCFF';\n\nconst SPAWN_INV_DURATION = 1 / DOT_SPAWN_ANIMATION_DURATION;\nconst SCALE_RANGE = DOT_SPAWN_SCALE_MAX - 1;\n\nexport class Dot {\n  position: Vec2;\n  velocity: Vector2;\n  state: DotState;\n  patternId: string | null = null;\n  \n  private spawnElapsed: number = 0;\n  private currentScale: number = DOT_SPAWN_SCALE_MAX;\n  readonly radius: number = DOT_RADIUS;\n  \n  // Frozen/thaw properties\n  private frozenTime: number = 0;\n  private readonly thawDuration: number = 6000; // 6 seconds (doubled)\n  private readonly preThawWarningTime: number = 500; // Start vibrating 500ms before thaw\n  private isZombie: boolean = false;\n  private readonly zombieSpeed: number = 50;\n  private vibrationOffset: Vector2 = { x: 0, y: 0 };\n  private frozenBorderThickness: number = FROZEN_BORDER_MAX_THICKNESS;\n\n  constructor(x: number, y: number, patternId: string | null = null) {\n    this.position = new Vec2(x, y);\n    this.velocity = { x: 0, y: 0 };\n    this.state = DotState.SPAWNING;\n    this.patternId = patternId;\n  }\n\n  update(dt: number, bounds: Bounds, playerPosition?: Vector2): void {\n    if (this.state === DotState.SPAWNING) {\n      this.spawnElapsed += dt * 1000;\n      const progress = this.spawnElapsed * SPAWN_INV_DURATION;\n      \n      if (progress >= 1) {\n        this.state = DotState.ACTIVE;\n        this.currentScale = 1;\n      } else {\n        this.currentScale = DOT_SPAWN_SCALE_MAX - SCALE_RANGE * progress;\n      }\n      return;\n    }\n    \n    if (this.state === DotState.FROZEN) {\n      this.frozenTime += dt * 1000;\n\n      const frozenProgress = Math.min(this.frozenTime / this.thawDuration, 1);\n      this.frozenBorderThickness = FROZEN_BORDER_MAX_THICKNESS * (1 - frozenProgress);\n\n      const timeUntilThaw = this.thawDuration - this.frozenTime;\n      if (timeUntilThaw <= this.preThawWarningTime && timeUntilThaw > 0) {\n        const shakeIntensity = 2 * (1 - timeUntilThaw / this.preThawWarningTime);\n        this.vibrationOffset.x = (Math.random() - 0.5) * shakeIntensity;\n        this.vibrationOffset.y = (Math.random() - 0.5) * shakeIntensity;\n      } else {\n        this.vibrationOffset.x = 0;\n        this.vibrationOffset.y = 0;\n      }\n\n      if (this.frozenTime >= this.thawDuration) {\n        this.thaw(playerPosition);\n      }\n      return;\n    }\n    \n    if (this.state !== DotState.ACTIVE) {\n      return;\n    }\n    \n    // If this is a zombie dot (thawed from frozen), chase the player\n    if (this.isZombie && playerPosition) {\n      const dx = playerPosition.x - this.position.x;\n      const dy = playerPosition.y - this.position.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      \n      if (dist > 0) {\n        this.velocity.x = (dx / dist) * this.zombieSpeed;\n        this.velocity.y = (dy / dist) * this.zombieSpeed;\n      }\n    }\n    \n    this.position.x += this.velocity.x * dt;\n    this.position.y += this.velocity.y * dt;\n    \n    // Don't wrap Cyclone dots - let them fly off-screen\n    if (this.patternId !== PatternType.CYCLONE) {\n      wrapInPlace(this.position, bounds);\n    }\n  }\n\n  render(renderer: Renderer): void {\n    const currentRadius = this.radius * this.currentScale;\n\n    let color: string;\n    switch (this.state) {\n      case DotState.SPAWNING:\n        color = COLOR_DOT_SPAWNING;\n        break;\n      case DotState.FROZEN:\n        color = COLOR_DOT_FROZEN;\n        break;\n      default:\n        color = COLOR_DOT;\n    }\n\n    const renderX = this.position.x + this.vibrationOffset.x;\n    const renderY = this.position.y + this.vibrationOffset.y;\n\n    renderer.drawCircle(\n      renderX,\n      renderY,\n      currentRadius,\n      color\n    );\n    \n    if (this.state === DotState.SPAWNING) {\n      const alpha = 1 - this.currentScale / DOT_SPAWN_SCALE_MAX;\n      renderer.drawCircleOutline(\n        renderX,\n        renderY,\n        currentRadius * 1.5,\n        `rgba(255,102,102,${alpha.toFixed(2)})`\n      );\n    }\n\n    if (this.state === DotState.FROZEN) {\n      // Draw light blue border as an outline that shrinks as they thaw\n      renderer.drawCircleOutline(\n        renderX,\n        renderY,\n        currentRadius + this.frozenBorderThickness,\n        FROZEN_BORDER_COLOR\n      );\n      renderer.drawCircle(\n        renderX,\n        renderY,\n        currentRadius,\n        color\n      );\n    }\n  }\n\n  isLethal(): boolean {\n    return this.state === DotState.ACTIVE;\n  }\n\n  isFrozen(): boolean {\n    return this.state === DotState.FROZEN;\n  }\n\n  freeze(): void {\n    if (this.state === DotState.ACTIVE || this.state === DotState.SPAWNING) {\n      this.state = DotState.FROZEN;\n      this.velocity.x = 0;\n      this.velocity.y = 0;\n      this.frozenTime = 0;\n      this.frozenBorderThickness = FROZEN_BORDER_MAX_THICKNESS;\n    }\n  }\n\n  thaw(playerPosition?: Vector2): void {\n    if (this.state === DotState.FROZEN) {\n      this.state = DotState.ACTIVE;\n      this.isZombie = true;\n      this.vibrationOffset.x = 0;\n      this.vibrationOffset.y = 0;\n      if (playerPosition) {\n        const dx = playerPosition.x - this.position.x;\n        const dy = playerPosition.y - this.position.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist > 0) {\n          this.velocity.x = (dx / dist) * this.zombieSpeed;\n          this.velocity.y = (dy / dist) * this.zombieSpeed;\n        }\n      }\n    }\n  }\n\n  kill(): void {\n    this.state = DotState.DEAD;\n  }\n\n  isDead(): boolean {\n    return this.state === DotState.DEAD;\n  }\n\n  getPosition(): Vector2 {\n    return this.position;\n  }\n\n  getRadius(): number {\n    return this.radius;\n  }\n\n  getEffectiveRadius(): number {\n    if (this.state === DotState.FROZEN) {\n      return this.radius + this.frozenBorderThickness;\n    }\n    return this.radius;\n  }\n}\n","import { Dot } from '../entities/Dot';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { Renderer } from '../renderer/Renderer';\n\nexport abstract class Pattern {\n  abstract readonly type: PatternType;\n  abstract readonly difficulty: Difficulty;\n\n  protected dots: Dot[] = [];\n  protected elapsedMs: number = 0;\n  protected isStarted: boolean = false;\n\n  abstract spawn(center: Vector2, bounds: Bounds): void;\n  abstract update(dt: number, playerPosition: Vector2, bounds: Bounds): void;\n\n  /**\n   * Centralized dot spawning method.\n   * Creates a dot with a spawn animation and optional initial velocity.\n   * The dot will be non-lethal during the spawn animation (500ms),\n   * then become active with the provided velocity.\n   *\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param velocity - Initial velocity (applied once spawn completes)\n   * @returns The created Dot instance\n   */\n  protected spawnDot(x: number, y: number, velocity: Vector2 = { x: 0, y: 0 }): Dot {\n    const dot = new Dot(x, y, this.type);\n    dot.velocity.x = velocity.x;\n    dot.velocity.y = velocity.y;\n    this.dots.push(dot);\n    return dot;\n  }\n\n  getDots(): Dot[] {\n    return this.dots.filter(d => !d.isDead());\n  }\n\n  isComplete(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns true if the pattern is still actively spawning dots.\n   * Override in subclasses that spawn dots over time.\n   */\n  isActivelySpawning(): boolean {\n    return false;\n  }\n\n  start(): void {\n    this.elapsedMs = 0;\n    this.isStarted = true;\n  }\n\n  getElapsedTime(): number {\n    return this.elapsedMs;\n  }\n\n  tick(dt: number): void {\n    this.elapsedMs += dt * 1000;\n  }\n\n  render(_renderer: Renderer): void {\n    // Override in subclasses to render pattern-specific visuals (e.g., warning indicators)\n  }\n\n  clear(): void {\n    for (let i = 0; i < this.dots.length; i++) {\n      this.dots[i].kill();\n    }\n    this.dots = [];\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { randomPosition } from '../utils/math';\nimport { DOT_RADIUS } from '../utils/constants';\n\nexport class ZombieSnow extends Pattern {\n  readonly type = PatternType.ZOMBIE_SNOW;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private spawnInterval: number;\n  private elapsedSinceSpawn: number = 0;\n  private readonly duration: number = 15000;\n  private readonly dotSpeed: number = 50;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.spawnInterval = 150;\n        break;\n      case Difficulty.MEDIUM:\n        this.spawnInterval = 300;\n        break;\n      default:\n        this.spawnInterval = 500;\n    }\n  }\n\n  spawn(_center: Vector2, _bounds: Bounds): void {\n    this.start();\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.elapsedMs <= this.duration) {\n      this.elapsedSinceSpawn += dt * 1000;\n      if (this.elapsedSinceSpawn >= this.spawnInterval) {\n        this.elapsedSinceSpawn = 0;\n        this.spawnDotAtRandomPosition(bounds);\n      }\n    }\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const dx = playerPosition.x - pos.x;\n      const dy = playerPosition.y - pos.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 0) {\n        dot.velocity.x = (dx / dist) * this.dotSpeed;\n        dot.velocity.y = (dy / dist) * this.dotSpeed;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnDotAtRandomPosition(bounds: Bounds): void {\n    const margin = DOT_RADIUS * 2;\n    const pos = randomPosition(bounds, margin);\n    this.spawnDot(pos.x, pos.y);\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.getDots().length === 0;\n  }\n\n  isActivelySpawning(): boolean {\n    return this.elapsedMs <= this.duration;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\nexport class SweeperLine extends Pattern {\n  readonly type = PatternType.SWEEPER_LINE;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private readonly duration: number = 20000;\n  private readonly dotSpacing: number = 20;\n  private readonly holeSize: number = 40; // Size of each hole in pixels\n\n  private isHorizontal: boolean = true;\n  private lineVelocity: number = 0;\n  private sweepSpeed: number = 150;\n  // For horizontal line: this is the Y position (sweeps up/down), offset is X\n  // For vertical line: this is the X position (sweeps left/right), offset is Y\n  private linePos: number = 0;\n  private lineOffset: number = 0;\n  private dotOffsets: number[] = []; // Fixed offsets for each dot along the line\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.sweepSpeed = 220;\n        break;\n      case Difficulty.MEDIUM:\n        this.sweepSpeed = 180;\n        break;\n      default:\n        this.sweepSpeed = 140;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n\n    // Randomly choose horizontal or vertical orientation\n    this.isHorizontal = Math.random() > 0.5;\n\n    // Random offset position for the line (where it sits on the perpendicular axis)\n    if (this.isHorizontal) {\n      // Horizontal line at random X position, sweeps up/down\n      this.lineOffset = Math.random() * (bounds.width - 200) + 100;\n    } else {\n      // Vertical line at random Y position, sweeps left/right\n      this.lineOffset = Math.random() * (bounds.height - 200) + 100;\n    }\n\n    // Start at one edge and sweep toward the other\n    if (this.isHorizontal) {\n      // Start at top or bottom\n      this.lineVelocity = Math.random() > 0.5 ? this.sweepSpeed : -this.sweepSpeed;\n      this.linePos = this.lineVelocity > 0 ? -50 : bounds.height + 50;\n    } else {\n      // Start at left or right\n      this.lineVelocity = Math.random() > 0.5 ? this.sweepSpeed : -this.sweepSpeed;\n      this.linePos = this.lineVelocity > 0 ? -50 : bounds.width + 50;\n    }\n\n    // Generate the line with holes\n    this.generateLineWithHoles(bounds);\n  }\n\n  private generateLineWithHoles(bounds: Bounds): void {\n    const numHoles = Math.floor(Math.random() * 2) + 2; // 2-3 holes\n    const lineLength = this.isHorizontal ? bounds.height : bounds.width;\n    const numDots = Math.floor((lineLength - 100) / this.dotSpacing);\n\n    // Generate hole positions (indices where dots should NOT spawn)\n    const holeSet = new Set<number>();\n    const holeWidthDots = Math.ceil(this.holeSize / this.dotSpacing);\n\n    for (let h = 0; h < numHoles; h++) {\n      // Random position along the line, avoiding edges\n      const holeCenter = Math.floor(Math.random() * (numDots - 10)) + 5;\n      for (let i = -Math.floor(holeWidthDots / 2); i <= Math.floor(holeWidthDots / 2); i++) {\n        holeSet.add(holeCenter + i);\n      }\n    }\n\n    // Spawn dots at fixed offsets along the line\n    const startOffset = (lineLength - (numDots * this.dotSpacing)) / 2;\n\n    for (let i = 0; i < numDots; i++) {\n      if (!holeSet.has(i)) {\n        const offset = startOffset + (i * this.dotSpacing);\n        this.dotOffsets.push(offset);\n\n        // Spawn dot - it will be positioned correctly in the first update\n        if (this.isHorizontal) {\n          // Horizontal line: dots vary in X (offset), same Y (sweeps)\n          this.spawnDot(this.lineOffset + offset - (lineLength / 2), this.linePos, { x: 0, y: 0 });\n        } else {\n          // Vertical line: dots vary in Y (offset), same X (sweeps)\n          this.spawnDot(this.linePos, this.lineOffset + offset - (lineLength / 2), { x: 0, y: 0 });\n        }\n      }\n    }\n  }\n\n  update(dt: number, _playerPosition: Vector2, bounds: Bounds): void {\n    // Move the line\n    this.linePos += this.lineVelocity * dt;\n\n    // Reverse direction when we go off-screen (sweep back and forth forever)\n    if (this.isHorizontal) {\n      if (this.lineVelocity > 0 && this.linePos > bounds.height + 50) {\n        this.lineVelocity = -this.sweepSpeed;\n      } else if (this.lineVelocity < 0 && this.linePos < -50) {\n        this.lineVelocity = this.sweepSpeed;\n      }\n    } else {\n      if (this.lineVelocity > 0 && this.linePos > bounds.width + 50) {\n        this.lineVelocity = -this.sweepSpeed;\n      } else if (this.lineVelocity < 0 && this.linePos < -50) {\n        this.lineVelocity = this.sweepSpeed;\n      }\n    }\n\n    // Update all dot positions to maintain formation\n    const lineLength = this.isHorizontal ? bounds.height : bounds.width;\n    for (let i = 0; i < this.dots.length; i++) {\n      const dot = this.dots[i];\n      \n      // Skip frozen dots - they should not move\n      if (dot.isFrozen()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n      \n      // During spawn animation, keep dot at its initial position\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n      \n      const offset = this.dotOffsets[i];\n\n      // Keep dots in formation - position them along the moving line\n      if (this.isHorizontal) {\n        // Horizontal line: X varies by offset, Y is the sweeping position\n        dot.position.x = this.lineOffset + offset - (lineLength / 2);\n        dot.position.y = this.linePos;\n      } else {\n        // Vertical line: Y varies by offset, X is the sweeping position\n        dot.position.x = this.linePos;\n        dot.position.y = this.lineOffset + offset - (lineLength / 2);\n      }\n\n      // Call update for state management (spawn animations, etc)\n      dot.update(dt, bounds, _playerPosition);\n    }\n\n    // Clean up dead dots\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      if (this.dots[i].isDead()) {\n        this.dots.splice(i, 1);\n        this.dotOffsets.splice(i, 1);\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.dots.length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\nexport class SparseGrid extends Pattern {\n  readonly type = PatternType.SPARSE_GRID;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private readonly dotSpeed: number = 20;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.dotSpeed = 40;\n        break;\n      case Difficulty.MEDIUM:\n        this.dotSpeed = 30;\n        break;\n      default:\n        this.dotSpeed = 20;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnGrid(bounds);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const dx = playerPosition.x - pos.x;\n      const dy = playerPosition.y - pos.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance > 0) {\n        const speed = distance > 50 ? this.dotSpeed : this.dotSpeed * (distance / 50);\n        dot.velocity.x = (dx / distance) * speed;\n        dot.velocity.y = (dy / distance) * speed;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnGrid(bounds: Bounds): void {\n    const margin = 100;\n    const spacing = 85;\n    const cols = Math.floor((bounds.width - margin * 2) / spacing);\n    const rows = Math.floor((bounds.height - margin * 2) / spacing);\n\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        const x = margin + col * spacing + spacing / 2;\n        const y = margin + row * spacing + spacing / 2;\n        this.spawnDot(x, y, { x: 0, y: 0 });\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { DOT_RADIUS } from '../utils/constants';\n\ninterface DotOffset {\n  x: number;\n  y: number;\n}\n\nexport class BouncingBall extends Pattern {\n  readonly type = PatternType.BOUNCING_BALL;\n  difficulty: Difficulty = Difficulty.MEDIUM;\n\n  private readonly duration: number = 30000;\n  private readonly ballRadius: number = 120;\n  private readonly dotCount: number = 200;\n  private centerPosition: Vector2 = { x: 0, y: 0 };\n  private centerVelocity: Vector2 = { x: 0, y: 0 };\n  private dotOffsets: DotOffset[] = [];\n  private speed: number = 120;\n\n  constructor(difficulty: Difficulty = Difficulty.MEDIUM) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.speed = 180;\n        break;\n      case Difficulty.MEDIUM:\n        this.speed = 120;\n        break;\n      default:\n        this.speed = 80;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.centerPosition = {\n      x: bounds.width / 2,\n      y: bounds.height / 2\n    };\n\n    const angle = Math.random() * Math.PI * 2;\n    this.centerVelocity = {\n      x: Math.cos(angle) * this.speed,\n      y: Math.sin(angle) * this.speed\n    };\n\n    this.spawnDots();\n  }\n\n  private spawnDots(): void {\n    this.dotOffsets = [];\n\n    const dotsPerRing = 20;\n    const ringCount = Math.ceil(this.dotCount / dotsPerRing);\n\n    for (let ring = 0; ring < ringCount; ring++) {\n      const ringRadius = (this.ballRadius * (ring + 1)) / ringCount;\n      const dotsInThisRing = Math.min(dotsPerRing, this.dotCount - this.dotOffsets.length);\n\n      for (let i = 0; i < dotsInThisRing; i++) {\n        const angle = (i / dotsInThisRing) * Math.PI * 2;\n        this.dotOffsets.push({\n          x: Math.cos(angle) * ringRadius,\n          y: Math.sin(angle) * ringRadius\n        });\n      }\n\n      if (this.dotOffsets.length >= this.dotCount) break;\n    }\n\n    for (let i = 0; i < this.dotOffsets.length; i++) {\n      const offset = this.dotOffsets[i];\n      this.spawnDot(\n        this.centerPosition.x + offset.x,\n        this.centerPosition.y + offset.y,\n        { x: this.centerVelocity.x, y: this.centerVelocity.y }\n      );\n    }\n  }\n\n  update(dt: number, _playerPosition: Vector2, bounds: Bounds): void {\n    this.centerPosition.x += this.centerVelocity.x * dt;\n    this.centerPosition.y += this.centerVelocity.y * dt;\n\n    const minX = this.ballRadius + DOT_RADIUS;\n    const maxX = bounds.width - this.ballRadius - DOT_RADIUS;\n    const minY = this.ballRadius + DOT_RADIUS;\n    const maxY = bounds.height - this.ballRadius - DOT_RADIUS;\n\n    if (this.centerPosition.x <= minX) {\n      this.centerPosition.x = minX;\n      this.centerVelocity.x = Math.abs(this.centerVelocity.x);\n    } else if (this.centerPosition.x >= maxX) {\n      this.centerPosition.x = maxX;\n      this.centerVelocity.x = -Math.abs(this.centerVelocity.x);\n    }\n\n    if (this.centerPosition.y <= minY) {\n      this.centerPosition.y = minY;\n      this.centerVelocity.y = Math.abs(this.centerVelocity.y);\n    } else if (this.centerPosition.y >= maxY) {\n      this.centerPosition.y = maxY;\n      this.centerVelocity.y = -Math.abs(this.centerVelocity.y);\n    }\n\n    for (let i = 0; i < this.dots.length; i++) {\n      const dot = this.dots[i];\n      \n      // Skip frozen dots - they should not move\n      if (dot.isFrozen()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n      \n      const offset = this.dotOffsets[i];\n\n      if (offset && !dot.isDead()) {\n        // Calculate where the dot should be (expected position)\n        const expectedX = this.centerPosition.x + offset.x;\n        const expectedY = this.centerPosition.y + offset.y;\n        \n        // Calculate displacement caused by external forces (like DotRepellent)\n        const displacementX = dot.position.x - expectedX;\n        const displacementY = dot.position.y - expectedY;\n        \n        // Apply displacement to center position (allows DotRepellent to push the ball)\n        this.centerPosition.x += displacementX;\n        this.centerPosition.y += displacementY;\n        \n        // Re-calculate expected position after center displacement\n        const newExpectedX = this.centerPosition.x + offset.x;\n        const newExpectedY = this.centerPosition.y + offset.y;\n        \n        // Set dot to its proper relative position in the formation\n        dot.position.x = newExpectedX;\n        dot.position.y = newExpectedY;\n        dot.velocity.x = this.centerVelocity.x;\n        dot.velocity.y = this.centerVelocity.y;\n      }\n\n      dot.update(dt, bounds, _playerPosition);\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2, DotState } from '../types';\nimport { randomPosition } from '../utils/math';\nimport { DOT_RADIUS } from '../utils/constants';\nimport { Dot } from '../entities/Dot';\nimport { Renderer } from '../renderer/Renderer';\n\nexport class GatlingPoint extends Pattern {\n  readonly type = PatternType.GATLING_POINT;\n  difficulty: Difficulty = Difficulty.MEDIUM;\n\n  private shootDuration: number;\n  private readonly dotSpeed: number = 400;\n  private shootInterval: number = 100;\n  private elapsedSinceSpawn: number = 0;\n  private spawnPoint: Vector2 = { x: 0, y: 0 };\n  private spawnPointDot: Dot | null = null;\n  private readonly spawnPointRadius: number = DOT_RADIUS * 2.5;\n  private spawnPointDead: boolean = false;\n\n  constructor(difficulty: Difficulty = Difficulty.MEDIUM) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.shootDuration = 6000;\n        this.shootInterval = 50;\n        break;\n      case Difficulty.MEDIUM:\n        this.shootDuration = 4500;\n        this.shootInterval = 80;\n        break;\n      default:\n        this.shootDuration = 3000;\n        this.shootInterval = 100;\n    }\n  }\n\n  spawn(_center: Vector2, _bounds: Bounds): void {\n    this.start();\n    const margin = 50;\n    this.spawnPoint = randomPosition(_bounds, margin);\n    \n    this.spawnPointDot = new Dot(this.spawnPoint.x, this.spawnPoint.y, this.type);\n    this.spawnPointDot.state = DotState.ACTIVE;\n    // Use Object.defineProperty to override the readonly radius for the spawn point\n    Object.defineProperty(this.spawnPointDot, 'radius', {\n      value: this.spawnPointRadius,\n      writable: false,\n      configurable: true\n    });\n    this.dots.push(this.spawnPointDot);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.spawnPointDot && !this.spawnPointDead) {\n      if (this.spawnPointDot.isDead()) {\n        this.spawnPointDead = true;\n      } else if (this.spawnPointDot.isFrozen()) {\n        // Spawn point frozen - stop spawning\n      } else if (this.elapsedMs <= this.shootDuration) {\n        this.elapsedSinceSpawn += dt * 1000;\n        if (this.elapsedSinceSpawn >= this.shootInterval) {\n          this.elapsedSinceSpawn = 0;\n          this.spawnDotAtPoint(playerPosition);\n        }\n      }\n    }\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n      const vel = dot.velocity;\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      if (pos.x < DOT_RADIUS || pos.x > bounds.width - DOT_RADIUS) {\n        vel.x = -vel.x * 0.5;\n      }\n      if (pos.y < DOT_RADIUS || pos.y > bounds.height - DOT_RADIUS) {\n        vel.y = -vel.y * 0.5;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnDotAtPoint(playerPosition: Vector2): void {\n    const dx = playerPosition.x - this.spawnPoint.x;\n    const dy = playerPosition.y - this.spawnPoint.y;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    if (dist > 0) {\n      this.spawnDot(this.spawnPoint.x, this.spawnPoint.y, {\n        x: (dx / dist) * this.dotSpeed,\n        y: (dy / dist) * this.dotSpeed\n      });\n    } else {\n      this.spawnDot(this.spawnPoint.x, this.spawnPoint.y);\n    }\n  }\n\n  isComplete(): boolean {\n    if (this.spawnPointDead || (this.spawnPointDot && this.spawnPointDot.isFrozen())) {\n      return this.getDots().length === 0;\n    }\n    return this.elapsedMs > this.shootDuration && this.getDots().length === 0;\n  }\n\n  isActivelySpawning(): boolean {\n    if (this.spawnPointDead || (this.spawnPointDot && this.spawnPointDot.isFrozen())) {\n      return false;\n    }\n    return this.elapsedMs <= this.shootDuration;\n  }\n\n  getSpawnPointDot(): Dot | null {\n    return this.spawnPointDot;\n  }\n\n  isSpawnPointDead(): boolean {\n    return this.spawnPointDead;\n  }\n  render(renderer: Renderer): void {\n    super.render?.(renderer);\n\n    if (this.spawnPointDot && !this.spawnPointDot.isDead() && !this.spawnPointDot.isFrozen()) {\n      const pos = this.spawnPointDot.getPosition();\n      const pulse = 1 + Math.sin(this.elapsedMs * 0.005) * 0.2;\n      \n      renderer.drawCircleOutline(\n        pos.x,\n        pos.y,\n        this.spawnPointRadius * pulse,\n        '#FFD700',\n        3\n      );\n      \n      renderer.drawCircleOutline(\n        pos.x,\n        pos.y,\n        this.spawnPointRadius * pulse * 1.3,\n        'rgba(255, 215, 0, 0.3)',\n        1\n      );\n    }\n  }\n}\n","import { Pattern } from './Pattern';\nimport { Dot } from '../entities/Dot';\nimport { PatternType, Difficulty, Bounds, Vector2, DotState } from '../types';\nimport { DOT_RADIUS, DOT_SPAWN_ANIMATION_DURATION } from '../utils/constants';\nimport { Renderer } from '../renderer/Renderer';\n\nexport class BulletHell extends Pattern {\n  readonly type = PatternType.BULLET_HELL;\n  difficulty: Difficulty = Difficulty.HARD;\n\n  private duration: number = 15000;\n  private readonly baseDotSpeed: number = 250;\n  private readonly warningDuration: number = DOT_SPAWN_ANIMATION_DURATION;\n  private readonly spawnInterval: number = 150; // Spawn every 150ms\n\n  private originX: number = 0;\n  private originY: number = 0;\n  private hasStartedSpawning: boolean = false;\n  private spawnAccumulator: number = 0;\n  private patternPhase: number = 0;\n  private spawnTimeoutId: number | null = null;\n\n  constructor(difficulty: Difficulty = Difficulty.HARD) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.duration = 15000;\n        break;\n      case Difficulty.MEDIUM:\n        this.duration = 12000;\n        break;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.hasStartedSpawning = false;\n    this.spawnAccumulator = 0;\n    this.patternPhase = 0;\n\n    // Always spawn from top center for classic bullet hell feel\n    this.originX = bounds.width / 2;\n    this.originY = -30;\n\n    this.spawnTimeoutId = window.setTimeout(() => {\n      this.hasStartedSpawning = true;\n    }, this.warningDuration);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.hasStartedSpawning && this.elapsedMs <= this.duration + this.warningDuration) {\n      this.spawnAccumulator += dt * 1000;\n      \n      // Spawn bullets based on interval\n      while (this.spawnAccumulator >= this.spawnInterval) {\n        this.spawnAccumulator -= this.spawnInterval;\n        this.spawnBulletWave(playerPosition);\n      }\n    }\n\n    // Update pattern phase for geometric animations\n    this.patternPhase += dt * 0.5;\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      \n      // Skip frozen dots - they should not move\n      if (dot.isFrozen()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n      \n      const pos = dot.getPosition();\n\n      if (pos.x < -DOT_RADIUS || pos.x > bounds.width + DOT_RADIUS ||\n          pos.y < -DOT_RADIUS || pos.y > bounds.height + DOT_RADIUS) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      dot.position.x += dot.velocity.x * dt;\n      dot.position.y += dot.velocity.y * dt;\n    }\n  }\n\n  render(renderer: Renderer): void {\n    super.render?.(renderer);\n\n    if (!this.hasStartedSpawning && this.isStarted) {\n      const progress = Math.min(this.elapsedMs / this.warningDuration, 1);\n      const scale = 1.5 - 0.5 * progress;\n      const alpha = 1 - progress;\n\n      renderer.drawCircle(\n        this.originX,\n        this.originY,\n        DOT_RADIUS * scale * 2,\n        `rgba(255, 102, 102, ${alpha.toFixed(2)})`\n      );\n\n      renderer.drawCircleOutline(\n        this.originX,\n        this.originY,\n        DOT_RADIUS * scale * 3,\n        `rgba(255, 0, 0, ${alpha.toFixed(2)})`\n      );\n    }\n  }\n\n  private spawnBulletWave(playerPosition: Vector2): void {\n    const time = this.elapsedMs * 0.001;\n    const patternType = Math.floor(time / 3) % 4; // Change pattern every 3 seconds\n\n    switch (patternType) {\n      case 0:\n        this.spawnSpiral();\n        break;\n      case 1:\n        this.spawnCircleBurst();\n        break;\n      case 2:\n        this.spawnAimedStreams(playerPosition);\n        break;\n      case 3:\n        this.spawnWavePattern();\n        break;\n    }\n  }\n\n  private spawnSpiral(): void {\n    // Classic bullet hell spiral\n    const arms = 3;\n    const bulletsPerArm = 2;\n    const spiralSpeed = 2.0;\n    \n    for (let arm = 0; arm < arms; arm++) {\n      const baseAngle = this.patternPhase * spiralSpeed + (arm * Math.PI * 2 / arms);\n      \n      for (let i = 0; i < bulletsPerArm; i++) {\n        const angle = baseAngle + i * 0.1;\n        const speed = this.baseDotSpeed * (0.8 + i * 0.1);\n        \n        const dot = new Dot(this.originX, this.originY, this.type);\n        dot.velocity.x = Math.cos(angle) * speed;\n        dot.velocity.y = Math.sin(angle) * speed;\n        dot.state = DotState.ACTIVE;\n        this.dots.push(dot);\n      }\n    }\n  }\n\n  private spawnCircleBurst(): void {\n    // Full circle of bullets radiating outward\n    const bulletCount = 16;\n    const angleStep = (Math.PI * 2) / bulletCount;\n    \n    for (let i = 0; i < bulletCount; i++) {\n      const angle = i * angleStep + this.patternPhase * 0.5;\n      const dot = new Dot(this.originX, this.originY, this.type);\n      dot.velocity.x = Math.cos(angle) * this.baseDotSpeed;\n      dot.velocity.y = Math.sin(angle) * this.baseDotSpeed;\n      dot.state = DotState.ACTIVE;\n      this.dots.push(dot);\n    }\n  }\n\n  private spawnAimedStreams(playerPosition: Vector2): void {\n    // Multiple streams aimed at player position\n    const streamCount = 5;\n    const baseAngle = Math.atan2(\n      playerPosition.y - this.originY,\n      playerPosition.x - this.originX\n    );\n    \n    for (let i = 0; i < streamCount; i++) {\n      const spread = (i - Math.floor(streamCount / 2)) * 0.15;\n      const angle = baseAngle + spread;\n      const speed = this.baseDotSpeed * (0.9 + Math.random() * 0.2);\n      \n      const dot = new Dot(this.originX, this.originY, this.type);\n      dot.velocity.x = Math.cos(angle) * speed;\n      dot.velocity.y = Math.sin(angle) * speed;\n      dot.state = DotState.ACTIVE;\n      this.dots.push(dot);\n    }\n  }\n\n  private spawnWavePattern(): void {\n    // Sine wave pattern of bullets\n    const waveWidth = Math.PI;\n    const bulletsInWave = 7;\n    const baseAngle = Math.PI / 2 + Math.sin(this.patternPhase * 2) * 0.3; // Slight sweeping\n    \n    for (let i = 0; i < bulletsInWave; i++) {\n      const waveOffset = (i / (bulletsInWave - 1) - 0.5) * waveWidth;\n      const angle = baseAngle + waveOffset;\n      const speed = this.baseDotSpeed * (0.7 + Math.abs(waveOffset) * 0.3);\n      \n      const dot = new Dot(this.originX, this.originY, this.type);\n      dot.velocity.x = Math.cos(angle) * speed;\n      dot.velocity.y = Math.sin(angle) * speed;\n      dot.state = DotState.ACTIVE;\n      this.dots.push(dot);\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration + this.warningDuration && this.getDots().length === 0;\n  }\n\n  isActivelySpawning(): boolean {\n    return this.elapsedMs <= this.duration + this.warningDuration;\n  }\n\n  clear(): void {\n    if (this.spawnTimeoutId !== null) {\n      window.clearTimeout(this.spawnTimeoutId);\n      this.spawnTimeoutId = null;\n    }\n    this.hasStartedSpawning = false;\n    super.clear();\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\nexport class ContainmentRing extends Pattern {\n  readonly type = PatternType.CONTAINMENT_RING;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private readonly ringRadius: number = 100;\n  private readonly dotSpeed: number = 30;\n  private readonly dotCount: number = 40;\n  private readonly innerRadius: number = 20;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n  }\n\n  spawn(center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnRing(center, bounds);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const dx = playerPosition.x - pos.x;\n      const dy = playerPosition.y - pos.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > this.innerRadius) {\n        dot.velocity.x = (dx / dist) * this.dotSpeed;\n        dot.velocity.y = (dy / dist) * this.dotSpeed;\n      } else {\n        dot.velocity.x = 0;\n        dot.velocity.y = 0;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnRing(center: Vector2, _bounds: Bounds): void {\n    const gapCount = Math.floor(Math.random() * 5);\n    const gapSize = gapCount > 0 ? 2 : 0;\n    const gaps: Array<[number, number]> = [];\n\n    for (let g = 0; g < gapCount; g++) {\n      const gapCenter = (this.dotCount * g) / gapCount + Math.floor(this.dotCount / (gapCount * 2));\n      const gapStart = gapCenter - gapSize;\n      const gapEnd = gapCenter + gapSize;\n      gaps.push([gapStart, gapEnd]);\n    }\n\n    for (let i = 0; i < this.dotCount; i++) {\n      const inGap = gaps.some(([start, end]) => i >= start && i <= end);\n      if (inGap) continue;\n\n      const angle = (2 * Math.PI * i) / this.dotCount;\n      const x = center.x + this.ringRadius * Math.cos(angle);\n      const y = center.y + this.ringRadius * Math.sin(angle);\n      this.spawnDot(x, y);\n    }\n  }\n\n  isComplete(): boolean {\n    return this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\n\nexport class Cyclone extends Pattern {\n  readonly type = PatternType.CYCLONE;\n  difficulty: Difficulty = Difficulty.HARD;\n\n  private readonly duration: number = 25000;\n  private circleRadius: number = 50;\n  private dotSpeed: number = 150;\n\n  constructor(difficulty: Difficulty = Difficulty.HARD) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.dotSpeed = 300;\n        this.circleRadius = 80;\n        break;\n      case Difficulty.MEDIUM:\n        this.dotSpeed = 200;\n        this.circleRadius = 60;\n        break;\n      default:\n        this.dotSpeed = 150;\n        this.circleRadius = 50;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnDots(bounds);\n  }\n\n  update(dt: number, _playerPosition: Vector2, bounds: Bounds): void {\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      // Remove dots that have flown off-screen\n      if (pos.x < -50 || pos.x > bounds.width + 50 ||\n          pos.y < -50 || pos.y > bounds.height + 50) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      dot.update(dt, bounds, _playerPosition);\n    }\n  }\n\n  private spawnDots(bounds: Bounds): void {\n    // Randomly pick one of the four corners\n    const corners = [\n      { x: bounds.width * 0.15, y: bounds.height * 0.15 },      // Top-left\n      { x: bounds.width * 0.85, y: bounds.height * 0.15 },      // Top-right\n      { x: bounds.width * 0.15, y: bounds.height * 0.85 },      // Bottom-left\n      { x: bounds.width * 0.85, y: bounds.height * 0.85 },      // Bottom-right\n    ];\n    const corner = corners[Math.floor(Math.random() * corners.length)];\n    const dotCount = 150;\n\n    for (let i = 0; i < dotCount; i++) {\n      const angle = (i / dotCount) * Math.PI * 2;\n      const offsetAngle = angle + (Math.random() - 0.5) * 0.2;\n      const radius = this.circleRadius * (0.8 + Math.random() * 0.4);\n      const x = corner.x + Math.cos(offsetAngle) * radius;\n      const y = corner.y + Math.sin(offsetAngle) * radius;\n\n      const velAngle = offsetAngle + Math.PI / 2 + (Math.random() - 0.5) * 0.5;\n      const speed = this.dotSpeed * (0.5 + Math.random() * 1);\n      this.spawnDot(x, y, {\n        x: Math.cos(velAngle) * speed,\n        y: Math.sin(velAngle) * speed\n      });\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\ninterface ClockHand {\n  angle: number; // Current rotation angle in radians\n  speed: number; // Rotation speed in radians per second\n  length: number; // Length of the hand in pixels\n  dotCount: number; // Number of dots on this hand\n  gaps: number[]; // Indices where dots should be skipped (for gaps)\n  dots: Array<{ index: number; distance: number; angleOffset: number }>; // Dot info\n}\n\nexport class ClockSweep extends Pattern {\n  readonly type = PatternType.CLOCK_SWEEP;\n  difficulty: Difficulty = Difficulty.MEDIUM;\n\n  private readonly duration: number = 25000; // 25 seconds\n  private center: Vector2 = { x: 0, y: 0 };\n  private hands: ClockHand[] = [];\n  private spawnProgress: number = 0;\n  private readonly spawnDuration: number = 2000; // 2 seconds to spawn\n  private hasFinishedSpawning: boolean = false;\n\n  // Second hand: fast, long, sparse\n  private readonly secondHandSpeed = 1.5; // radians/sec (fast)\n  private readonly secondHandLength = 400;\n  private readonly secondHandDotCount = 15;\n\n  // Minute hand: still pretty long, slower, with gaps\n  private readonly minuteHandSpeed = 0.4; // radians/sec\n  private readonly minuteHandLength = 350;\n  private readonly minuteHandDotCount = 20;\n\n\n  // Hour hand: short, dense\n  private readonly hourHandSpeed = 0.15; // radians/sec (slow)\n  private readonly hourHandLength = 200;\n  private readonly hourHandDotCount = 25;\n\n  constructor(difficulty: Difficulty = Difficulty.MEDIUM) {\n    super();\n    this.difficulty = difficulty;\n\n    // Adjust difficulty\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.hands = [\n          this.createHand(this.secondHandSpeed * 1.3, this.secondHandLength, this.secondHandDotCount, []),\n          this.createHand(this.minuteHandSpeed * 1.2, this.minuteHandLength, this.minuteHandDotCount, [8, 9, 10]),\n          this.createHand(this.hourHandSpeed * 1.2, this.hourHandLength, this.hourHandDotCount + 5, []),\n        ];\n        break;\n      case Difficulty.MEDIUM:\n        this.hands = [\n          this.createHand(this.secondHandSpeed, this.secondHandLength, this.secondHandDotCount, []),\n          this.createHand(this.minuteHandSpeed, this.minuteHandLength, this.minuteHandDotCount, [9, 10, 11]),\n          this.createHand(this.hourHandSpeed, this.hourHandLength, this.hourHandDotCount, []),\n        ];\n        break;\n      default: // EASY\n        this.hands = [\n          this.createHand(this.secondHandSpeed * 0.8, this.secondHandLength * 0.9, this.secondHandDotCount - 3, []),\n          this.createHand(this.minuteHandSpeed * 0.8, this.minuteHandLength * 0.9, this.minuteHandDotCount - 3, [9, 10]),\n          this.createHand(this.hourHandSpeed * 0.8, this.hourHandLength * 0.9, this.hourHandDotCount - 5, []),\n        ];\n    }\n  }\n\n  private createHand(speed: number, length: number, dotCount: number, gapIndices: number[]): ClockHand {\n    const dots: Array<{ index: number; distance: number; angleOffset: number }> = [];\n    const spacing = length / (dotCount - 1);\n\n    for (let i = 0; i < dotCount; i++) {\n      if (gapIndices.includes(i)) continue;\n      dots.push({\n        index: i,\n        distance: i * spacing,\n        angleOffset: 0,\n      });\n    }\n\n    return {\n      angle: Math.random() * Math.PI * 2, // Random starting angle\n      speed,\n      length,\n      dotCount,\n      gaps: gapIndices,\n      dots,\n    };\n  }\n\n  spawn(center: Vector2, _bounds: Bounds): void {\n    this.start();\n    this.center = center;\n    this.spawnProgress = 0;\n    this.hasFinishedSpawning = false;\n\n    // Create all dots at the center initially\n    for (const hand of this.hands) {\n      for (const _dotInfo of hand.dots) {\n        // Spawn dot at center - it will grow outward during spawn animation\n        this.spawnDot(this.center.x, this.center.y, { x: 0, y: 0 });\n      }\n    }\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    // Handle spawn animation\n    if (!this.hasFinishedSpawning) {\n      this.spawnProgress += dt * 1000;\n      if (this.spawnProgress >= this.spawnDuration) {\n        this.hasFinishedSpawning = true;\n        this.spawnProgress = this.spawnDuration;\n      }\n    }\n\n    const spawnRatio = this.hasFinishedSpawning ? 1 : this.spawnProgress / this.spawnDuration;\n\n    // Update hand angles\n    for (const hand of this.hands) {\n      hand.angle += hand.speed * dt;\n    }\n\n    // Update all dot positions\n    let dotIndex = 0;\n    for (const hand of this.hands) {\n      for (const dotInfo of hand.dots) {\n        if (dotIndex >= this.dots.length) break;\n\n        const dot = this.dots[dotIndex];\n        dotIndex++;\n\n        // Skip frozen dots - they stay in place\n        if (dot.isFrozen()) {\n          dot.update(dt, bounds, playerPosition);\n          continue;\n        }\n\n        // During spawn animation, keep dot at center\n        if (!dot.isLethal()) {\n          dot.update(dt, bounds, playerPosition);\n          continue;\n        }\n\n        // Calculate target position based on hand angle and dot distance\n        // Apply spawn ratio to grow outward from center\n        const currentDistance = dotInfo.distance * spawnRatio;\n        const x = this.center.x + Math.cos(hand.angle) * currentDistance;\n        const y = this.center.y + Math.sin(hand.angle) * currentDistance;\n\n        dot.position.x = x;\n        dot.position.y = y;\n\n        // Clear velocity (we're controlling position directly)\n        dot.velocity.x = 0;\n        dot.velocity.y = 0;\n\n        // Continue rotation movement after spawn complete\n        if (this.hasFinishedSpawning) {\n          // The dots will appear to rotate as we update their positions each frame\n          // based on the current hand angle\n        }\n\n        dot.update(dt, bounds, playerPosition);\n      }\n    }\n\n    // Clean up dead dots\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      if (this.dots[i].isDead()) {\n        this.dots.splice(i, 1);\n        // Also need to remove from hand.dots - but for simplicity, we just skip dead dots above\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.dots.length === 0;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport class Blaster extends Weapon {\n  readonly type = WeaponType.BLASTER;\n\n  private state: 'AIMING' | 'FIRING' | 'COMPLETE' = 'AIMING';\n  private aimTime: number = 1000;\n  private aimStartTime: number = 0;\n  private beamPosition: number = 0;\n  private prevBeamPosition: number = 0;\n  private beamAngle: number = 0;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n  private playerAngle: number = 0;\n  private beamOriginPosition: Vector2 = { x: 0, y: 0 };\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.dots = dots;\n    this.aimStartTime = Date.now();\n\n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n    this.beamAngle = this.playerAngle;\n\n    this.state = 'AIMING';\n  }\n\n  update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    if (this.state === 'COMPLETE') return;\n\n    const elapsed = Date.now() - this.aimStartTime;\n\n    if (this.state === 'AIMING') {\n      this.playerPosition = player.getPosition();\n      this.playerAngle = player.directionAngle;\n\n      if (elapsed >= this.aimTime) {\n        this.state = 'FIRING';\n        this.beamAngle = this.playerAngle;\n        this.beamOriginPosition = { ...this.playerPosition };\n      }\n    } else if (this.state === 'FIRING') {\n      this.prevBeamPosition = this.beamPosition;\n      this.beamPosition += 500 * dt;\n      this.checkBeamCollision(dots);\n      \n      if (this.beamPosition > Math.max(bounds.width, bounds.height)) {\n        this.state = 'COMPLETE';\n      }\n    }\n  }\n\n  checkBeamCollision(dots: Dot[]): void {\n    if (!dots || dots.length === 0) return;\n\n    const cos = Math.cos(this.beamAngle);\n    const sin = Math.sin(this.beamAngle);\n\n    for (const dot of dots) {\n      if (!dot.isDead()) {\n        const dotPos = dot.getPosition();\n        const dotRadius = dot.getRadius();\n\n        const dx = dotPos.x - this.beamOriginPosition.x;\n        const dy = dotPos.y - this.beamOriginPosition.y;\n\n        const localX = dx * cos + dy * sin;\n        const localY = dx * sin - dy * cos;\n\n        const halfWidth = 50 + dotRadius;\n        const halfLength = 100 + dotRadius;\n\n        const inWidth = Math.abs(localY) <= halfWidth;\n\n        if (!inWidth) continue;\n\n        const sweepStart = this.prevBeamPosition - halfLength;\n        const sweepEnd = this.beamPosition + halfLength;\n\n        const inSweepRange = localX >= sweepStart && localX <= sweepEnd;\n\n        if (inSweepRange) {\n          dot.kill();\n          this.addKilledDot();\n        }\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'COMPLETE') return;\n\n    const ctx = renderer.getContext();\n\n    if (this.state === 'AIMING') {\n      const x = this.playerPosition.x;\n      const y = this.playerPosition.y;\n\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(this.playerAngle);\n\n      ctx.fillStyle = 'rgb(128, 0, 128)';\n      ctx.fillRect(0, -6, 20, 12);\n\n      ctx.restore();\n    } else if (this.state === 'FIRING') {\n      const x = this.beamOriginPosition.x + this.beamPosition * Math.cos(this.beamAngle);\n      const y = this.beamOriginPosition.y + this.beamPosition * Math.sin(this.beamAngle);\n\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(this.beamAngle);\n\n      ctx.fillStyle = 'rgba(128, 0, 255, 0.78)';\n      ctx.fillRect(-5, -75, 10, 150);\n\n      ctx.restore();\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { WEAPON_COLORS } from '../utils/constants';\n\nexport class Chainsaw extends Weapon {\n  readonly type = WeaponType.CHAINSAW;\n\n  private readonly duration: number = 5000;\n  private readonly chainsawRadius: number = 50;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n\n  private readonly warningStartTime: number = 4200;\n  private readonly flashDuration: number = 100;\n  private readonly flashGap: number = 300;\n\n  activate(player: Player, _dots: Dot[]): void {\n    this.start();\n    this.playerPosition = player.getPosition();\n  }\n\n  update(_dt: number, player: Player, dots: Dot[], _bounds: Bounds): void {\n    if (this.getElapsedTime() >= this.duration) return;\n    if (!dots || dots.length === 0) return;\n    this.playerPosition = player.getPosition();\n\n    for (const dot of dots) {\n      if (dot.isDead()) continue;\n      const pos = dot.getPosition();\n      const dx = pos.x - this.playerPosition.x;\n      const dy = pos.y - this.playerPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.chainsawRadius) {\n        dot.kill();\n        this.addKilledDot();\n      }\n    }\n  }\n\n  private shouldShowVisual(): boolean {\n    const elapsed = this.getElapsedTime();\n\n    if (elapsed < this.warningStartTime) {\n      return true;\n    }\n\n    const warningElapsed = elapsed - this.warningStartTime;\n    const isFirstFlashOff = warningElapsed < this.flashDuration;\n    const isSecondFlashOff = warningElapsed >= this.flashGap &&\n                              warningElapsed < this.flashGap + this.flashDuration;\n\n    return !isFirstFlashOff && !isSecondFlashOff;\n  }\n\n  render(renderer: Renderer): void {\n    if (!this.shouldShowVisual()) return;\n    \n    const elapsed = this.getElapsedTime();\n    const rotation = (elapsed / 50) % (Math.PI * 2); // Spinning rotation\n    const numTeeth = 8;\n    const innerRadius = this.chainsawRadius * 0.7;\n    const outerRadius = this.chainsawRadius;\n    \n    // Draw base circle (semi-transparent)\n    renderer.drawCircle(this.playerPosition.x, this.playerPosition.y, this.chainsawRadius, WEAPON_COLORS.CHAINSAW + '66');\n    \n    // Draw spinning triangular teeth\n    const ctx = renderer.getContext();\n    ctx.save();\n    ctx.translate(this.playerPosition.x, this.playerPosition.y);\n    ctx.rotate(rotation);\n    \n    ctx.fillStyle = '#E0E0E0';\n    for (let i = 0; i < numTeeth; i++) {\n      const angle = (i / numTeeth) * Math.PI * 2;\n      const nextAngle = ((i + 1) / numTeeth) * Math.PI * 2;\n      \n      // Draw triangular tooth\n      ctx.beginPath();\n      ctx.moveTo(\n        Math.cos(angle) * innerRadius,\n        Math.sin(angle) * innerRadius\n      );\n      ctx.lineTo(\n        Math.cos(angle + (nextAngle - angle) * 0.5) * outerRadius,\n        Math.sin(angle + (nextAngle - angle) * 0.5) * outerRadius\n      );\n      ctx.lineTo(\n        Math.cos(nextAngle) * innerRadius,\n        Math.sin(nextAngle) * innerRadius\n      );\n      ctx.closePath();\n      ctx.fill();\n    }\n    \n    // Draw center hub\n    ctx.fillStyle = '#808080';\n    ctx.beginPath();\n    ctx.arc(0, 0, innerRadius * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.restore();\n  }\n\n  isComplete(): boolean {\n    return this.getElapsedTime() >= this.duration;\n  }\n\n  getChainsawRadius(): number {\n    return this.chainsawRadius;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport class DotRepellent extends Weapon {\n  readonly type = WeaponType.DOT_REPELLENT;\n\n  private readonly duration: number = 8000;\n  private readonly fieldRadius: number = 100;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n\n  activate(player: Player, _dots: Dot[]): void {\n    this.start();\n    this.dots = [];\n    this.playerPosition = player.getPosition();\n  }\n\n  update(_dt: number, player: Player, dots: Dot[], _bounds: Bounds): void {\n    const elapsed = this.getElapsedTime();\n    if (elapsed >= this.duration) return;\n    if (!dots || dots.length === 0) return;\n\n    this.playerPosition = player.getPosition();\n\n    for (const dot of dots) {\n      if (dot.isDead()) continue;\n\n      const dotPos = dot.getPosition();\n      const dx = dotPos.x - this.playerPosition.x;\n      const dy = dotPos.y - this.playerPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < this.fieldRadius && distance > 0) {\n        const push = 5 * (1 - distance / this.fieldRadius);\n        dot.position.x += (dx / distance) * push;\n        dot.position.y += (dy / distance) * push;\n      }\n    }\n  }\n\n  render(_renderer: Renderer): void {\n    const ctx = _renderer.getContext();\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.arc(\n      this.playerPosition.x,\n      this.playerPosition.y,\n      this.fieldRadius,\n      0,\n      Math.PI * 2\n    );\n    ctx.strokeStyle = 'rgba(128, 128, 128, 0.3)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  isComplete(): boolean {\n    return this.getElapsedTime() >= this.duration;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { toastManager } from '../game/ToastManager';\n\ninterface ChainNode {\n  x: number;\n  y: number;\n  radius: number;\n  activatedAt: number;\n  chainDepth: number;\n  parentX?: number;\n  parentY?: number;\n}\n\ninterface LightningArc {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  createdAt: number;\n  chainDepth: number;\n}\n\nexport class ElectricBomb extends Weapon {\n  readonly type = WeaponType.ELECTRIC_BOMB;\n\n  private state: 'ROLLING' | 'CHAINING' | 'COMPLETE' = 'ROLLING';\n  private orbPosition: Vector2 = { x: 0, y: 0 };\n  private orbVelocity: Vector2 = { x: 0, y: 0 };\n  private chainNodes: ChainNode[] = [];\n  private lightningArcs: LightningArc[] = [];\n  private dotsToProcess: Dot[] = [];\n  private readonly initialRadiusFactor: number = 0.15;\n  private readonly chainRadiusFactor: number = 0.10;\n  private readonly maxChainDepth: number = 50;\n  private orbSpeed: number = 300;\n  private orbRadius: number = 12;\n  private rollingDuration: number = 2000;\n  private chainDelayMs: number = 80;\n  private lastChainTime: number = 0;\n  private bounds: Bounds | null = null;\n  private lastCollisionTime: number = 0;\n  private readonly collisionCooldown: number = 100;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.dots = dots;\n    this.start();\n\n    this.orbPosition = { ...player.getPosition() };\n\n    const angle = Math.random() * Math.PI * 2;\n    this.orbVelocity = {\n      x: Math.cos(angle) * this.orbSpeed,\n      y: Math.sin(angle) * this.orbSpeed\n    };\n\n    this.state = 'ROLLING';\n  }\n\n  update(_dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    if (this.bounds === null) {\n      this.bounds = bounds;\n    }\n\n    switch (this.state) {\n      case 'ROLLING':\n        this.updateRolling(_dt, bounds);\n        break;\n\n      case 'CHAINING':\n        this.updateChaining(dots, player, bounds);\n        break;\n\n      case 'COMPLETE':\n        break;\n    }\n  }\n\n  getPosition(): Vector2 {\n    return this.orbPosition;\n  }\n\n  getRadius(): number {\n    return this.orbRadius;\n  }\n\n  handlePlayerCollision(_player: Player, playerVelocity: Vector2): boolean {\n    const now = Date.now();\n    if (now - this.lastCollisionTime < this.collisionCooldown) {\n      return false;\n    }\n    this.lastCollisionTime = now;\n\n    const dx = this.orbPosition.x - _player.position.x;\n    const dy = this.orbPosition.y - _player.position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    const minSpeed = 50;\n    const playerSpeed = Math.sqrt(playerVelocity.x ** 2 + playerVelocity.y ** 2);\n\n    if (playerSpeed < minSpeed) {\n      return false;\n    }\n\n    if (distance === 0) {\n      this.orbVelocity.x = playerVelocity.x;\n      this.orbVelocity.y = playerVelocity.y;\n      return true;\n    }\n\n    const nx = dx / distance;\n    const ny = dy / distance;\n    const tx = -ny;\n    const ty = nx;\n\n    const vDotN = playerVelocity.x * nx + playerVelocity.y * ny;\n    const vDotT = playerVelocity.x * tx + playerVelocity.y * ty;\n\n    const directness = vDotN / playerSpeed;\n\n    if (directness < 0.1) {\n      return false;\n    }\n\n    const velocityMultiplier = 1.5;\n\n    if (directness > 0.7) {\n      this.orbVelocity.x = playerVelocity.x * velocityMultiplier;\n      this.orbVelocity.y = playerVelocity.y * velocityMultiplier;\n    } else {\n      const forwardFactor = directness;\n      const sidewaysFactor = 1 - directness;\n\n      this.orbVelocity.x = (nx * vDotN * forwardFactor + tx * vDotT * sidewaysFactor) * velocityMultiplier;\n      this.orbVelocity.y = (ny * vDotN * forwardFactor + ty * vDotT * sidewaysFactor) * velocityMultiplier;\n    }\n\n    return true;\n  }\n\n  private updateRolling(dt: number, bounds: Bounds): void {\n    this.orbPosition.x += this.orbVelocity.x * dt;\n    this.orbPosition.y += this.orbVelocity.y * dt;\n\n    if (this.orbPosition.x - this.orbRadius < 0) {\n      this.orbPosition.x = this.orbRadius;\n      this.orbVelocity.x = Math.abs(this.orbVelocity.x);\n    } else if (this.orbPosition.x + this.orbRadius > bounds.width) {\n      this.orbPosition.x = bounds.width - this.orbRadius;\n      this.orbVelocity.x = -Math.abs(this.orbVelocity.x);\n    }\n\n    if (this.orbPosition.y - this.orbRadius < 0) {\n      this.orbPosition.y = this.orbRadius;\n      this.orbVelocity.y = Math.abs(this.orbVelocity.y);\n    } else if (this.orbPosition.y + this.orbRadius > bounds.height) {\n      this.orbPosition.y = bounds.height - this.orbRadius;\n      this.orbVelocity.y = -Math.abs(this.orbVelocity.y);\n    }\n\n    if (this.getElapsedTime() >= this.rollingDuration) {\n      this.triggerInitialExplosion();\n    }\n  }\n\n  private triggerInitialExplosion(): void {\n    this.state = 'CHAINING';\n    this.lastChainTime = Date.now();\n    toastManager.show('Electric Bomb discharged!', 'warning');\n\n    const radius = (this.bounds?.width ?? 800) * this.initialRadiusFactor;\n    \n    this.chainNodes.push({\n      x: this.orbPosition.x,\n      y: this.orbPosition.y,\n      radius,\n      activatedAt: Date.now(),\n      chainDepth: 0\n    });\n\n    this.findAndElectrifyDots(this.chainNodes[0]);\n  }\n\n  private findAndElectrifyDots(node: ChainNode): void {\n    for (const dot of this.dots) {\n      if (dot.isDead()) continue;\n      \n      const pos = dot.getPosition();\n      const dx = pos.x - node.x;\n      const dy = pos.y - node.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      if (distance <= node.radius) {\n        dot.kill();\n        this.addKilledDot();\n        \n        this.lightningArcs.push({\n          x1: node.x,\n          y1: node.y,\n          x2: pos.x,\n          y2: pos.y,\n          createdAt: Date.now(),\n          chainDepth: node.chainDepth\n        });\n        \n        const newNode: ChainNode = {\n          x: pos.x,\n          y: pos.y,\n          radius: (this.bounds?.width ?? 800) * this.chainRadiusFactor,\n          activatedAt: Date.now(),\n          chainDepth: node.chainDepth + 1,\n          parentX: node.x,\n          parentY: node.y\n        };\n        \n        this.chainNodes.push(newNode);\n        this.dotsToProcess.push(dot);\n      }\n    }\n  }\n\n  private updateChaining(dots: Dot[], player: Player, _bounds: Bounds): void {\n    if (!dots || dots.length === 0) {\n      this.state = 'COMPLETE';\n      return;\n    }\n\n    const now = Date.now();\n\n    if (now - this.lastChainTime < this.chainDelayMs) {\n      return;\n    }\n\n    this.lastChainTime = now;\n\n    const pendingNodes = this.chainNodes.filter(n =>\n      n.chainDepth > 0 &&\n      now - n.activatedAt < 100 &&\n      n.chainDepth < this.maxChainDepth\n    );\n\n    if (pendingNodes.length === 0) {\n      this.checkPlayerHit(player);\n\n      const activeNodes = this.chainNodes.filter(n =>\n        now - n.activatedAt < 600\n      );\n\n      // Complete if no active nodes OR if only the initial node (depth 0) exists\n      // (meaning the chain never started because no dots were in range)\n      const hasChainNodes = this.chainNodes.some(n => n.chainDepth > 0);\n\n      if (activeNodes.length === 0 || !hasChainNodes) {\n        this.state = 'COMPLETE';\n      }\n      return;\n    }\n\n    for (const node of pendingNodes) {\n      this.findAndElectrifyDots(node);\n    }\n\n    this.checkPlayerHit(player);\n  }\n\n  private checkPlayerHit(_player: Player): void {\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'ROLLING') {\n      renderer.drawCircle(\n        this.orbPosition.x,\n        this.orbPosition.y,\n        this.orbRadius,\n        '#00FFFF'\n      );\n\n      renderer.drawCircleOutline(\n        this.orbPosition.x,\n        this.orbPosition.y,\n        this.orbRadius + 4,\n        'rgba(0, 255, 255, 0.5)',\n        2\n      );\n    } else if (this.state === 'CHAINING' || this.state === 'COMPLETE') {\n      this.renderChainNodes(renderer);\n      this.renderLightning(renderer);\n    }\n  }\n\n  private renderChainNodes(renderer: Renderer): void {\n    const now = Date.now();\n    const fadeTime = 500;\n\n    this.chainNodes = this.chainNodes.filter(node => now - node.activatedAt < fadeTime + 100);\n\n    for (const node of this.chainNodes) {\n      const age = now - node.activatedAt;\n      const opacity = Math.max(0, 1 - age / fadeTime);\n\n      if (opacity > 0) {\n        renderer.drawCircle(\n          node.x,\n          node.y,\n          node.radius,\n          `rgba(0, 255, 255, ${opacity * 0.3})`\n        );\n\n        renderer.drawCircleOutline(\n          node.x,\n          node.y,\n          node.radius,\n          `rgba(0, 255, 255, ${opacity})`,\n          3\n        );\n      }\n    }\n  }\n\n  private renderLightning(renderer: Renderer): void {\n    const now = Date.now();\n    const lightningFadeTime = 500;\n\n    this.lightningArcs = this.lightningArcs.filter(arc => now - arc.createdAt < lightningFadeTime);\n\n    for (const arc of this.lightningArcs) {\n      const age = now - arc.createdAt;\n      const opacity = Math.max(0, 1 - age / lightningFadeTime);\n\n      if (opacity > 0) {\n        this.drawJaggedLightning(\n          renderer,\n          arc.x1,\n          arc.y1,\n          arc.x2,\n          arc.y2,\n          opacity,\n          arc.chainDepth\n        );\n      }\n    }\n  }\n\n  private drawJaggedLightning(\n    renderer: Renderer,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    opacity: number,\n    chainDepth: number\n  ): void {\n    const segments = 3 + Math.min(chainDepth, 3);\n    const jitter = 6 + chainDepth * 2;\n    const color = `rgba(0, 200, 255, ${opacity})`;\n    const glowColor = `rgba(100, 230, 255, ${opacity * 0.5})`;\n\n    const points: { x: number; y: number }[] = [];\n    points.push({ x: x1, y: y1 });\n\n    for (let i = 1; i < segments; i++) {\n      const t = i / segments;\n      const baseX = x1 + (x2 - x1) * t;\n      const baseY = y1 + (y2 - y1) * t;\n\n      const offsetX = (Math.random() - 0.5) * jitter * 2;\n      const offsetY = (Math.random() - 0.5) * jitter * 2;\n\n      points.push({ x: baseX + offsetX, y: baseY + offsetY });\n    }\n\n    points.push({ x: x2, y: y2 });\n\n    for (let i = 0; i < points.length - 1; i++) {\n      renderer.drawLine(\n        points[i].x,\n        points[i].y,\n        points[i + 1].x,\n        points[i + 1].y,\n        glowColor,\n        4\n      );\n    }\n\n    for (let i = 0; i < points.length - 1; i++) {\n      renderer.drawLine(\n        points[i].x,\n        points[i].y,\n        points[i + 1].x,\n        points[i + 1].y,\n        color,\n        2\n      );\n    }\n  }\n\n  isActive(): boolean {\n    return this.state === 'ROLLING';\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  hasKilledPlayer(): boolean {\n    return false;\n  }\n\n  getExplosionCount(): number {\n    return this.chainNodes.length;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\ninterface FlameParticle {\n  x: number;\n  y: number;\n  age: number;\n  maxAge: number;\n}\n\ninterface FireTrail {\n  x: number;\n  y: number;\n  startTime: number;\n  duration: number;\n}\n\nexport class FlameBurst extends Weapon {\n  readonly type = WeaponType.FLAME_BURST;\n  \n  private readonly FLAME_DURATION_MS = 3000;\n  private readonly CONE_ANGLE_RAD = Math.PI / 3;\n  private readonly FLAME_REACH_PX = 200;\n  private readonly TRAIL_DURATION_MS = 1000;\n  private readonly PARTICLE_MAX_AGE_MS = 200;\n  private readonly PARTICLE_AGE_VARIANCE_MS = 100;\n  private readonly PARTICLES_PER_FRAME = 5;\n  private readonly FRAME_TIME_MS = 16;\n  \n  private playerPosition: Vector2 = { x: 0, y: 0 };\n  private playerAngle: number = 0;\n  private flames: FlameParticle[] = [];\n  private trails: FireTrail[] = [];\n  private flameActive: boolean = false;\n  private complete: boolean = false;\n  \n  activate(player: Player, _dots: Dot[]): void {\n    this.start();\n    this.dots = _dots;\n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n    this.flames = [];\n    this.trails = [];\n    this.flameActive = true;\n    this.complete = false;\n  }\n  \n  update(_dt: number, player: Player, dots: Dot[], _bounds: Bounds): void {\n    if (this.complete) return;\n    \n    const elapsed = this.getElapsedTime();\n    \n    if (elapsed >= this.FLAME_DURATION_MS) {\n      this.flameActive = false;\n      const now = Date.now();\n      this.trails = this.trails.filter(trail => now - trail.startTime < trail.duration);\n      if (this.trails.length === 0) {\n        this.complete = true;\n      }\n      return;\n    }\n    \n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n    \n    this.spawnFlameParticles();\n    \n    this.flames = this.flames.filter(flame => {\n      flame.age += this.FRAME_TIME_MS;\n      return flame.age < flame.maxAge;\n    });\n    \n    if (Math.random() < 0.3) {\n      this.spawnFireTrail();\n    }\n    \n    const now = Date.now();\n    this.trails = this.trails.filter(trail => now - trail.startTime < trail.duration);\n    \n    this.killDotsInFlameCone(dots);\n  }\n  \n  private spawnFlameParticles(): void {\n    for (let i = 0; i < this.PARTICLES_PER_FRAME; i++) {\n      const angleOffset = (Math.random() - 0.5) * this.CONE_ANGLE_RAD;\n      const angle = this.playerAngle + angleOffset;\n      const distance = Math.random() * this.FLAME_REACH_PX;\n      const jitterX = (Math.random() - 0.5) * 20;\n      const jitterY = (Math.random() - 0.5) * 20;\n      \n      this.flames.push({\n        x: this.playerPosition.x + Math.cos(angle) * distance + jitterX,\n        y: this.playerPosition.y + Math.sin(angle) * distance + jitterY,\n        age: 0,\n        maxAge: this.PARTICLE_MAX_AGE_MS + Math.random() * this.PARTICLE_AGE_VARIANCE_MS\n      });\n    }\n  }\n  \n  private spawnFireTrail(): void {\n    const angleOffset = (Math.random() - 0.5) * this.CONE_ANGLE_RAD;\n    const angle = this.playerAngle + angleOffset;\n    const distance = 20 + Math.random() * 60;\n    \n    this.trails.push({\n      x: this.playerPosition.x + Math.cos(angle) * distance,\n      y: this.playerPosition.y + Math.sin(angle) * distance,\n      startTime: Date.now(),\n      duration: this.TRAIL_DURATION_MS\n    });\n  }\n  \n  private killDotsInFlameCone(dots: Dot[]): void {\n    if (!dots || dots.length === 0) return;\n    \n    const halfConeAngle = this.CONE_ANGLE_RAD / 2;\n\n    for (const dot of dots) {\n      if (dot.isDead()) continue;\n      \n      const dotPos = dot.getPosition();\n      const dx = dotPos.x - this.playerPosition.x;\n      const dy = dotPos.y - this.playerPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      if (distance > this.FLAME_REACH_PX) continue;\n      \n      const dotAngle = Math.atan2(dy, dx);\n      let angleDiff = dotAngle - this.playerAngle;\n      \n      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;\n      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;\n      \n      if (Math.abs(angleDiff) <= halfConeAngle) {\n        dot.kill();\n        this.addKilledDot();\n      }\n    }\n  }\n  \n  render(renderer: Renderer): void {\n    if (this.complete) return;\n    \n    const ctx = renderer.getContext();\n    const now = Date.now();\n    \n    this.renderTrails(ctx, now);\n    \n    if (!this.flameActive) return;\n    \n    this.renderFlameCone(ctx);\n    this.renderFlameParticles(ctx);\n  }\n  \n  private renderTrails(ctx: CanvasRenderingContext2D, now: number): void {\n    for (const trail of this.trails) {\n      const age = now - trail.startTime;\n      const progress = age / trail.duration;\n      const alpha = Math.max(0, 1 - progress);\n      const radius = 8 + progress * 5;\n      \n      ctx.beginPath();\n      ctx.arc(trail.x, trail.y, radius, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.6})`;\n      ctx.fill();\n      \n      ctx.beginPath();\n      ctx.arc(trail.x, trail.y, radius * 0.5, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, 200, 50, ${alpha * 0.8})`;\n      ctx.fill();\n    }\n  }\n  \n  private renderFlameCone(ctx: CanvasRenderingContext2D): void {\n    ctx.save();\n    ctx.translate(this.playerPosition.x, this.playerPosition.y);\n    ctx.rotate(this.playerAngle);\n    \n    const coneGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.FLAME_REACH_PX);\n    coneGradient.addColorStop(0, 'rgba(255, 150, 0, 0.3)');\n    coneGradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');\n    coneGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');\n    \n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.arc(0, 0, this.FLAME_REACH_PX, -this.CONE_ANGLE_RAD / 2, this.CONE_ANGLE_RAD / 2);\n    ctx.closePath();\n    ctx.fillStyle = coneGradient;\n    ctx.fill();\n    \n    ctx.restore();\n  }\n  \n  private renderFlameParticles(ctx: CanvasRenderingContext2D): void {\n    for (const flame of this.flames) {\n      const progress = flame.age / flame.maxAge;\n      const alpha = Math.max(0, 1 - progress);\n      const size = 6 + progress * 8;\n      \n      ctx.beginPath();\n      ctx.arc(flame.x, flame.y, size, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, ${Math.floor(100 + progress * 50)}, 0, ${alpha * 0.5})`;\n      ctx.fill();\n      \n      ctx.beginPath();\n      ctx.arc(flame.x, flame.y, size * 0.4, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, ${Math.floor(200 + progress * 55)}, ${Math.floor(50 + progress * 100)}, ${alpha * 0.8})`;\n      ctx.fill();\n    }\n  }\n  \n  isComplete(): boolean {\n    return this.complete;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { distance } from '../utils/math';\n\ninterface Missile {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  angle: number;\n  target: Dot | null;\n  active: boolean;\n}\n\ninterface Explosion {\n  x: number;\n  y: number;\n  startTime: number;\n  duration: number;\n  mainRadius: number;\n  subExplosions: { x: number; y: number; radius: number }[];\n  hasAppliedDamage: boolean;\n  active: boolean;\n}\n\nconst MISSILE_RADIUS = 6;\nconst MISSILE_COLOR = '#FF6B00';\nconst MISSILE_TRAIL_COLOR = 'rgba(255, 107, 0, 0.3)';\nconst MAX_TURN_RATE = 5 * Math.PI / 180;\n\nconst EXPLOSION_MAIN_RADIUS = 45;\nconst EXPLOSION_SUB_RADIUS = 15;\nconst EXPLOSION_DURATION_MS = 500;\nconst EXPLOSION_SUB_DELAY_MS = 250;\nconst EXPLOSION_COLOR = '#FFD700';\n\nexport class HomingMissile extends Weapon {\n  readonly type = WeaponType.HOMING_MISSILE;\n\n  private missiles: Missile[] = [];\n  private explosions: Explosion[] = [];\n  private readonly missileSpeed: number = 800;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.dots = dots;\n    this.missiles = [];\n    this.explosions = [];\n\n    const playerPos = player.getPosition();\n    const baseAngle = player.directionAngle;\n    const playerVel = player.velocity;\n\n    const playerSpeedInfluence = Math.sqrt(playerVel.x ** 2 + playerVel.y ** 2) * 0.5;\n    const effectiveSpeed = this.missileSpeed + playerSpeedInfluence;\n\n    const angles = [baseAngle - Math.PI / 6, baseAngle, baseAngle + Math.PI / 6];\n\n    for (const launchAngle of angles) {\n      const missile: Missile = {\n        x: playerPos.x,\n        y: playerPos.y,\n        vx: Math.cos(launchAngle) * effectiveSpeed,\n        vy: Math.sin(launchAngle) * effectiveSpeed,\n        angle: launchAngle,\n        target: null,\n        active: true\n      };\n      this.missiles.push(missile);\n    }\n  }\n\n  private findBestTarget(missile: Missile, dots: Dot[]): Dot | null {\n    if (!dots || dots.length === 0) return null;\n    \n    let bestTarget: Dot | null = null;\n    let bestScore = Infinity;\n\n    for (const dot of dots) {\n      if (dot.isDead()) continue;\n\n      const dotPos = dot.getPosition();\n      const dist = distance(missile, dotPos);\n\n      const angleToDot = Math.atan2(dotPos.y - missile.y, dotPos.x - missile.x);\n      const angleDiff = Math.abs(this.normalizeAngle(angleToDot - missile.angle));\n\n      const score = dist * (1 + angleDiff);\n\n      if (score < bestScore) {\n        bestScore = score;\n        bestTarget = dot;\n      }\n    }\n\n    return bestTarget;\n  }\n\n  private normalizeAngle(angle: number): number {\n    while (angle > Math.PI) angle -= 2 * Math.PI;\n    while (angle < -Math.PI) angle += 2 * Math.PI;\n    return angle;\n  }\n\n  private createExplosion(x: number, y: number): void {\n    const subExplosions = [];\n    for (let i = 0; i < 4; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const dist = Math.random() * EXPLOSION_MAIN_RADIUS * 0.6;\n      subExplosions.push({\n        x: Math.cos(angle) * dist,\n        y: Math.sin(angle) * dist,\n        radius: EXPLOSION_SUB_RADIUS * (0.8 + Math.random() * 0.4)\n      });\n    }\n\n    const explosion: Explosion = {\n      x,\n      y,\n      startTime: Date.now(),\n      duration: EXPLOSION_DURATION_MS,\n      mainRadius: EXPLOSION_MAIN_RADIUS,\n      subExplosions,\n      hasAppliedDamage: false,\n      active: true\n    };\n    this.explosions.push(explosion);\n  }\n\n  private applyExplosionDamage(explosion: Explosion, dots: Dot[]): void {\n    if (explosion.hasAppliedDamage) return;\n\n    for (const dot of dots) {\n      if (dot.isDead()) continue;\n\n      const dotPos = dot.getPosition();\n      const dist = distance({ x: explosion.x, y: explosion.y }, dotPos);\n\n      if (dist < explosion.mainRadius + dot.getRadius()) {\n        dot.kill();\n        this.addKilledDot();\n      }\n    }\n\n    explosion.hasAppliedDamage = true;\n  }\n\n  update(_dt: number, _player: Player, dots: Dot[], bounds: Bounds): void {\n    const now = Date.now();\n\n    this.missiles = this.missiles.filter(m => m.active);\n    this.explosions = this.explosions.filter(e => e.active);\n\n    for (const explosion of this.explosions) {\n      const elapsed = now - explosion.startTime;\n      if (elapsed >= explosion.duration) {\n        explosion.active = false;\n      }\n      if (!explosion.hasAppliedDamage) {\n        this.applyExplosionDamage(explosion, dots);\n      }\n    }\n\n    for (const missile of this.missiles) {\n      if (!missile.active) continue;\n\n      if (!missile.target || missile.target.isDead()) {\n        missile.target = this.findBestTarget(missile, dots);\n      }\n\n      if (missile.target) {\n        const targetPos = missile.target.getPosition();\n        const angleToTarget = Math.atan2(\n          targetPos.y - missile.y,\n          targetPos.x - missile.x\n        );\n\n        const angleDiff = this.normalizeAngle(angleToTarget - missile.angle);\n\n        const turnAmount = Math.max(-MAX_TURN_RATE, Math.min(MAX_TURN_RATE, angleDiff));\n        missile.angle += turnAmount;\n\n        const currentSpeed = Math.sqrt(missile.vx ** 2 + missile.vy ** 2);\n        missile.vx = Math.cos(missile.angle) * currentSpeed;\n        missile.vy = Math.sin(missile.angle) * currentSpeed;\n      }\n\n      missile.x += missile.vx * _dt;\n      missile.y += missile.vy * _dt;\n\n      if (\n        missile.x < -MISSILE_RADIUS ||\n        missile.x > bounds.width + MISSILE_RADIUS ||\n        missile.y < -MISSILE_RADIUS ||\n        missile.y > bounds.height + MISSILE_RADIUS\n      ) {\n        missile.active = false;\n        continue;\n      }\n\n      for (const dot of dots) {\n        if (dot.isDead()) continue;\n\n        const dotPos = dot.getPosition();\n        const dist = distance(missile, dotPos);\n\n        if (dist < MISSILE_RADIUS + dot.getRadius()) {\n          this.createExplosion(missile.x, missile.y);\n          missile.active = false;\n          break;\n        }\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    const ctx = renderer.getContext();\n    const now = Date.now();\n\n    for (const missile of this.missiles) {\n      if (!missile.active) continue;\n\n      ctx.save();\n      ctx.translate(missile.x, missile.y);\n      ctx.rotate(missile.angle);\n\n      ctx.beginPath();\n      ctx.moveTo(-15, 0);\n      ctx.lineTo(-MISSILE_RADIUS, 0);\n      ctx.strokeStyle = MISSILE_TRAIL_COLOR;\n      ctx.lineWidth = 4;\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.moveTo(MISSILE_RADIUS * 1.5, 0);\n      ctx.lineTo(-MISSILE_RADIUS, -MISSILE_RADIUS * 0.6);\n      ctx.lineTo(-MISSILE_RADIUS, MISSILE_RADIUS * 0.6);\n      ctx.closePath();\n      ctx.fillStyle = MISSILE_COLOR;\n      ctx.fill();\n\n      ctx.restore();\n    }\n\n    for (const explosion of this.explosions) {\n      if (!explosion.active) continue;\n\n      const elapsed = now - explosion.startTime;\n      const progress = elapsed / explosion.duration;\n      const opacity = 1 - progress;\n\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      ctx.fillStyle = EXPLOSION_COLOR;\n\n      ctx.beginPath();\n      ctx.arc(explosion.x, explosion.y, explosion.mainRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      if (elapsed >= EXPLOSION_SUB_DELAY_MS) {\n        for (const sub of explosion.subExplosions) {\n          ctx.beginPath();\n          ctx.arc(\n            explosion.x + sub.x,\n            explosion.y + sub.y,\n            sub.radius,\n            0,\n            Math.PI * 2\n          );\n          ctx.fill();\n        }\n      }\n\n      ctx.restore();\n    }\n  }\n\n  isComplete(): boolean {\n    return this.missiles.every(m => !m.active) && this.explosions.every(e => !e.active);\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport interface FrozenDot {\n  dot: Dot;\n  frozenTime: number;\n}\n\nexport class IceBomb extends Weapon {\n  readonly type = WeaponType.ICE_BOMB;\n\n  private state: 'EXPLODING' | 'FADING' | 'COMPLETE' = 'EXPLODING';\n  private bounds: Bounds | null = null;\n  private explosionRadius: number = 0;\n  private explosionCenter: { x: number; y: number } = { x: 0, y: 0 };\n  private explosionStartTime: number = 0;\n  private frozenDotsCount: number = 0;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.explosionStartTime = Date.now();\n    this.explosionCenter = { x: player.position.x, y: player.position.y };\n    this.dots = dots;\n    \n    // Calculate explosion radius based on bounds\n    this.explosionRadius = 0.3 * (dots.length > 0 ? 800 : 800); // Default to reasonable size\n    \n    // Freeze dots in explosion radius\n    this.freezeDotsInRadius(dots);\n    \n    this.state = 'EXPLODING';\n  }\n\n  update(_dt: number, _player: Player, dots: Dot[], bounds: Bounds): void {\n    if (!this.bounds) {\n      this.bounds = bounds;\n      this.explosionRadius = 0.3 * bounds.width;\n    }\n\n    // Continuously freeze dots that enter the radius while effect is active\n    if (this.state === 'EXPLODING' || this.state === 'FADING') {\n      this.freezeDotsInRadius(dots);\n    }\n\n    if (this.state === 'EXPLODING') {\n      const elapsed = Date.now() - this.explosionStartTime;\n      if (elapsed >= 500) {\n        this.state = 'FADING';\n      }\n    } else if (this.state === 'FADING') {\n      const elapsed = Date.now() - this.explosionStartTime;\n      // Effect lasts 6000ms to match dot freeze duration (doubled)\n      if (elapsed >= 6000) {\n        this.state = 'COMPLETE';\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'EXPLODING' || this.state === 'FADING') {\n      const elapsed = Date.now() - this.explosionStartTime;\n      let alpha = 0.6;\n      \n      if (this.state === 'FADING') {\n        // Fade out over 5500ms (from 500ms to 6000ms)\n        alpha = 0.6 * (1 - (elapsed - 500) / 5500);\n      }\n      \n      if (alpha > 0) {\n        renderer.drawCircle(\n          this.explosionCenter.x,\n          this.explosionCenter.y,\n          this.explosionRadius,\n          `rgba(0, 204, 255, ${alpha})` // Blue explosion\n        );\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  private freezeDotsInRadius(dots: Dot[]): void {\n    if (!dots || dots.length === 0) return;\n\n    for (const dot of dots) {\n      if (dot.isDead() || dot.isFrozen()) {\n        continue;\n      }\n\n      const pos = dot.getPosition();\n      const dx = pos.x - this.explosionCenter.x;\n      const dy = pos.y - this.explosionCenter.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.explosionRadius) {\n        dot.freeze();\n        this.frozenDotsCount++;\n      }\n    }\n  }\n\n  getFrozenDotsCount(): number {\n    return this.frozenDotsCount;\n  }\n\n  getExplosionRadius(): number {\n    return this.explosionRadius;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport class KineticBomb extends Weapon {\n  readonly type = WeaponType.KINETIC_BOMB;\n\n  private state: 'COLLAPSING' | 'EXPLODING' | 'COMPLETE' = 'COLLAPSING';\n  private explosionCenter: Vector2 = { x: 0, y: 0 };\n  private explosionRadius: number = 0;\n  private bounds: Bounds | null = null;\n  private killedDotsInExplosion: Set<Dot> = new Set();\n\n  activate(player: Player, dots: Dot[]): void {\n    this.dots = dots;\n    this.explosionCenter = { x: player.position.x, y: player.position.y };\n    this.start();\n  }\n\n  update(_dt: number, _player: Player, dots: Dot[], bounds: Bounds): void {\n    if (!this.bounds) this.bounds = bounds;\n    const elapsedTime = this.getElapsedTime();\n\n    switch (this.state) {\n      case 'COLLAPSING':\n        if (elapsedTime >= 100) {\n          this.state = 'EXPLODING';\n          this.explosionRadius = 0.45 * bounds.width;\n        }\n        break;\n\n      case 'EXPLODING':\n        // Continuously kill dots that enter the explosion\n        this.killDotsInExplosion(dots);\n        \n        // Complete after 1 second total (100ms collapse + 900ms explosion)\n        if (elapsedTime >= 1000) {\n          this.state = 'COMPLETE';\n        }\n        break;\n\n      case 'COMPLETE':\n        break;\n    }\n  }\n\n  render(renderer: Renderer): void {\n    const elapsedTime = this.getElapsedTime();\n\n    if (this.state === 'COLLAPSING') {\n      const collapseRadius = 50 * (1 - elapsedTime / 100);\n      if (collapseRadius > 0) {\n        renderer.drawCircle(\n          this.explosionCenter.x,\n          this.explosionCenter.y,\n          Math.max(0, collapseRadius),\n          '#FF4500'\n        );\n      }\n    } else if (this.state === 'EXPLODING') {\n      // Translucent explosion that fades over time\n      const explosionElapsed = elapsedTime - 100;\n      const explosionDuration = 900;\n      const fadeOpacity = 1 - (explosionElapsed / explosionDuration);\n      \n      if (fadeOpacity > 0) {\n        renderer.drawCircle(\n          this.explosionCenter.x,\n          this.explosionCenter.y,\n          this.explosionRadius,\n          `rgba(255, 69, 0, ${fadeOpacity * 0.7})`\n        );\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  private killDotsInExplosion(dots: Dot[]): void {\n    for (const dot of dots) {\n      if (dot.isDead() || this.killedDotsInExplosion.has(dot)) continue;\n\n      const pos = dot.getPosition();\n      const dx = pos.x - this.explosionCenter.x;\n      const dy = pos.y - this.explosionCenter.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.explosionRadius) {\n        dot.kill();\n        this.addKilledDot();\n        this.killedDotsInExplosion.add(dot);\n      }\n    }\n  }\n}\n","import { Game } from './game/Game';\nimport { PatternRegistry } from './patterns/PatternRegistry';\nimport { WeaponRegistry } from './weapons/WeaponRegistry';\nimport { PatternType } from './types';\nimport { WeaponType } from './types';\nimport { toastManager } from './game/ToastManager';\n\nimport { ZombieSnow } from './patterns/ZombieSnow';\nimport { SweeperLine } from './patterns/SweeperLine';\nimport { SparseGrid } from './patterns/SparseGrid';\nimport { BouncingBall } from './patterns/BouncingBall';\nimport { GatlingPoint } from './patterns/GatlingPoint';\nimport { BulletHell } from './patterns/BulletHell';\nimport { ContainmentRing } from './patterns/ContainmentRing';\nimport { Cyclone } from './patterns/Cyclone';\nimport { ClockSweep } from './patterns/ClockSweep';\n\nimport { Blaster } from './weapons/Blaster';\nimport { Chainsaw } from './weapons/Chainsaw';\nimport { DotRepellent } from './weapons/DotRepellent';\nimport { ElectricBomb } from './weapons/ElectricBomb';\nimport { FlameBurst } from './weapons/FlameBurst';\nimport { HomingMissile } from './weapons/HomingMissile';\nimport { IceBomb } from './weapons/IceBomb';\nimport { KineticBomb } from './weapons/KineticBomb';\nimport { NuclearBomb } from './weapons/NuclearBomb';\n\nPatternRegistry.register(PatternType.ZOMBIE_SNOW, ZombieSnow);\nPatternRegistry.register(PatternType.SWEEPER_LINE, SweeperLine);\nPatternRegistry.register(PatternType.SPARSE_GRID, SparseGrid);\nPatternRegistry.register(PatternType.BOUNCING_BALL, BouncingBall);\nPatternRegistry.register(PatternType.GATLING_POINT, GatlingPoint);\nPatternRegistry.register(PatternType.BULLET_HELL, BulletHell);\nPatternRegistry.register(PatternType.CONTAINMENT_RING, ContainmentRing);\nPatternRegistry.register(PatternType.CYCLONE, Cyclone);\nPatternRegistry.register(PatternType.CLOCK_SWEEP, ClockSweep);\n\nWeaponRegistry.register(WeaponType.BLASTER, Blaster);\nWeaponRegistry.register(WeaponType.CHAINSAW, Chainsaw);\nWeaponRegistry.register(WeaponType.DOT_REPELLENT, DotRepellent);\nWeaponRegistry.register(WeaponType.ELECTRIC_BOMB, ElectricBomb);\nWeaponRegistry.register(WeaponType.FLAME_BURST, FlameBurst);\nWeaponRegistry.register(WeaponType.HOMING_MISSILE, HomingMissile);\nWeaponRegistry.register(WeaponType.ICE_BOMB, IceBomb);\nWeaponRegistry.register(WeaponType.KINETIC_BOMB, KineticBomb);\nWeaponRegistry.register(WeaponType.NUCLEAR_BOMB, NuclearBomb);\n\ntoastManager.setupGlobalErrorHandler();\n\nnew Game();"],"names":["GameState","DotState","PatternType","WeaponType","Difficulty","Renderer","canvasId","canvas","ctx","scale","callback","color","x","y","radius","batch","lineWidth","i","c","byWidth","group","o","x1","y1","x2","y2","width","angle","length","cos","sin","endX","endY","headLength","headAngle","height","text","fontSize","points","PLAYER_VISUAL_RADIUS","PLAYER_HITBOX_RADIUS","PLAYER_MAX_SPEED","PLAYER_ARROW_LENGTH","DOT_RADIUS","DOT_SPAWN_ANIMATION_DURATION","DOT_SPAWN_SCALE_MAX","WEAPON_ORB_RADIUS","COLOR_PLAYER","COLOR_PLAYER_ARROW","COLOR_DOT","COLOR_DOT_SPAWNING","COLOR_DOT_FROZEN","COLOR_BACKGROUND","WEAPON_COLORS","TARGET_FPS","FRAME_TIME","InputManager","basis","error","gamma","beta","orientation","tiltX","tiltY","event","reference","gammaDelta","betaDelta","gameCoords","normalizedX","normalizedY","value","min","max","Vec2","v","other","scalar","mag","distance","a","b","dx","dy","wrapInPlace","position","bounds","circleCollision","radiusA","radiusB","distanceSq","radiiSum","randomPosition","margin","Player","dt","inputVelocity","shouldWrap","renderer","arrowStartX","arrowStartY","ScoringSystem","count","difficulty","bonuses","timeBonus","CELL_SIZE","NEARBY_OFFSETS","CollisionSystem","_bounds","cellX","cellY","dots","dot","pos","key","cell","player","playerPos","playerRadius","nearbyKeys","j","dotPos","dotRadius","orbs","orb","orbPos","orbRadius","DifficultyManager","score","PatternRegistryImpl","type","patternClass","PatternClass","PatternRegistry","ToastManager","duration","toast","removed","element","colors","id","index","t","stack","message","title","filename","lineno","colno","content","header","messageDiv","locationDiv","stackHeader","stackTrace","buttonContainer","reloadButton","copyButton","fullError","toastManager","PATTERN_DIFFICULTY_MAP","SCORE_THRESHOLDS","PatternManager","playerPosition","nextType","pattern","availableTypes","allTypes","candidateTypes","randomIndex","completedPattern","word","WeaponOrb","weaponType","borderColor","iconScale","branchX","branchY","arrowSize","spacing","arrowX","arrowY","size","skullScale","teethX","teethX2","boneEndRadius","boneEnds","end","numTeeth","innerR","outerR","distSq","playerVelocity","now","nx","ny","tx","ty","vDotN","vDotT","restitution","friction","minX","maxX","minY","maxY","WeaponOrbSpawner","attempts","types","WeaponRegistryImpl","weaponClass","WeaponClass","WeaponRegistry","Weapon","_player","_playerVelocity","d","NuclearBomb","_dots","minSpeed","playerSpeed","directness","velocityMultiplier","forwardFactor","sidewaysFactor","elapsedTime","progress","warningExplosionRadius","warningStartTime","warningElapsed","flash1Start","flash2Start","shouldShowFlash","explosionElapsed","alpha","color1","color2","factor","r1","g1","b1","r2","g2","b2","r","g","STORAGE_KEY","MAX_HIGHSCORES","getHighscores","data","addHighscore","highscores","newEntry","trimmed","rank","e","Game","isLandscape","show","el","menuHighscoreList","h","centerX","centerY","finalScore","highscoreList","deathReasonElement","recentToastsList","allMessages","msg","currentTime","deltaTime","velocity","allDots","collidingOrb","weapon","weaponPos","weaponRadius","collidingDot","FROZEN_BORDER_MAX_THICKNESS","FROZEN_BORDER_COLOR","SPAWN_INV_DURATION","SCALE_RANGE","Dot","patternId","frozenProgress","timeUntilThaw","shakeIntensity","dist","currentRadius","renderX","renderY","Pattern","_renderer","ZombieSnow","_center","SweeperLine","numHoles","lineLength","numDots","holeSet","holeWidthDots","holeCenter","startOffset","offset","_playerPosition","SparseGrid","speed","cols","rows","row","col","BouncingBall","dotsPerRing","ringCount","ring","ringRadius","dotsInThisRing","expectedX","expectedY","displacementX","displacementY","newExpectedX","newExpectedY","GatlingPoint","vel","pulse","BulletHell","time","arm","baseAngle","angleStep","spread","waveWidth","bulletsInWave","waveOffset","ContainmentRing","center","gapCount","gapSize","gaps","gapCenter","gapStart","gapEnd","start","Cyclone","corners","corner","dotCount","offsetAngle","velAngle","ClockSweep","gapIndices","hand","_dotInfo","spawnRatio","dotIndex","dotInfo","currentDistance","Blaster","elapsed","localX","localY","halfWidth","halfLength","sweepStart","sweepEnd","Chainsaw","_dt","isFirstFlashOff","isSecondFlashOff","rotation","innerRadius","outerRadius","nextAngle","DotRepellent","push","ElectricBomb","node","newNode","pendingNodes","n","activeNodes","hasChainNodes","fadeTime","age","opacity","lightningFadeTime","arc","chainDepth","segments","jitter","glowColor","baseX","baseY","offsetX","offsetY","FlameBurst","trail","flame","angleOffset","jitterX","jitterY","halfConeAngle","angleDiff","coneGradient","MISSILE_RADIUS","MISSILE_COLOR","MISSILE_TRAIL_COLOR","MAX_TURN_RATE","EXPLOSION_MAIN_RADIUS","EXPLOSION_SUB_RADIUS","EXPLOSION_DURATION_MS","EXPLOSION_SUB_DELAY_MS","EXPLOSION_COLOR","HomingMissile","playerVel","playerSpeedInfluence","effectiveSpeed","angles","launchAngle","missile","bestTarget","bestScore","angleToDot","subExplosions","explosion","m","targetPos","angleToTarget","turnAmount","currentSpeed","sub","IceBomb","KineticBomb","collapseRadius","fadeOpacity"],"mappings":"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"}