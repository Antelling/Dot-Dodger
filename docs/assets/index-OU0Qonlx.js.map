{"version":3,"file":"index-OU0Qonlx.js","sources":["../../src/types/index.ts","../../src/renderer/Renderer.ts","../../src/utils/constants.ts","../../src/game/InputManager.ts","../../src/utils/math.ts","../../src/entities/Player.ts","../../src/game/ScoringSystem.ts","../../src/game/CollisionSystem.ts","../../src/game/DifficultyManager.ts","../../src/patterns/PatternRegistry.ts","../../src/game/ToastManager.ts","../../src/game/PatternManager.ts","../../src/entities/WeaponOrb.ts","../../src/game/WeaponOrbSpawner.ts","../../src/weapons/WeaponRegistry.ts","../../src/weapons/Weapon.ts","../../src/weapons/NuclearBomb.ts","../../src/utils/storage.ts","../../src/game/Game.ts","../../src/entities/Dot.ts","../../src/patterns/Pattern.ts","../../src/patterns/ZombieSnow.ts","../../src/patterns/SweeperLine.ts","../../src/patterns/SparseGrid.ts","../../src/patterns/BouncingBall.ts","../../src/patterns/GatlingPoint.ts","../../src/patterns/BulletHell.ts","../../src/patterns/ContainmentRing.ts","../../src/patterns/Cyclone.ts","../../src/weapons/Blaster.ts","../../src/weapons/Chainsaw.ts","../../src/weapons/DotRepellent.ts","../../src/weapons/ElectricBomb.ts","../../src/weapons/FlameBurst.ts","../../src/weapons/HomingMissile.ts","../../src/weapons/IceBomb.ts","../../src/weapons/KineticBomb.ts","../../src/main.ts"],"sourcesContent":["export interface Vector2 {\n  x: number;\n  y: number;\n}\n\nexport enum GameState {\n  MENU = 'MENU',\n  PLAYING = 'PLAYING',\n  GAME_OVER = 'GAME_OVER',\n  PAUSED = 'PAUSED'\n}\n\nexport enum DotState {\n  SPAWNING = 'SPAWNING',\n  ACTIVE = 'ACTIVE',\n  FROZEN = 'FROZEN',\n  DEAD = 'DEAD'\n}\n\nexport enum PatternType {\n  ZOMBIE_SNOW = 'ZOMBIE_SNOW',\n  SWEEPER_LINE = 'SWEEPER_LINE',\n  SPARSE_GRID = 'SPARSE_GRID',\n  BOUNCING_BALL = 'BOUNCING_BALL',\n  GATLING_POINT = 'GATLING_POINT',\n  BULLET_HELL = 'BULLET_HELL',\n  CONTAINMENT_RING = 'CONTAINMENT_RING',\n  CYCLONE = 'CYCLONE'\n}\n\nexport enum WeaponType {\n  KINETIC_BOMB = 'KINETIC_BOMB',\n  BLASTER = 'BLASTER',\n  ICE_BOMB = 'ICE_BOMB',\n  HOMING_MISSILE = 'HOMING_MISSILE',\n  NUCLEAR_BOMB = 'NUCLEAR_BOMB',\n  ELECTRIC_BOMB = 'ELECTRIC_BOMB',\n  DOT_REPELLENT = 'DOT_REPELLENT',\n  CHAINSAW = 'CHAINSAW',\n  FLAME_BURST = 'FLAME_BURST'\n}\n\nexport enum Difficulty {\n  EASY = 'EASY',\n  MEDIUM = 'MEDIUM',\n  HARD = 'HARD'\n}\n\nexport interface Entity {\n  position: Vector2;\n  velocity: Vector2;\n  radius: number;\n}\n\nexport interface HighscoreEntry {\n  score: number;\n  timestamp: number;\n}\n\nexport interface PlayerConfig {\n  hitboxRadius: number;\n  maxSpeed: number;\n}\n\nexport interface DotConfig {\n  radius: number;\n  spawnAnimationDuration: number;\n}\n\nexport interface WeaponOrbConfig {\n  radius: number;\n  alwaysOnArena: number;\n}\n\nexport interface Bounds {\n  width: number;\n  height: number;\n}\n\nexport interface DeathEvent {\n  message: string;\n  type: 'dot' | 'nuclear_bomb' | 'electric_bomb';\n  timestamp: number;\n}\n","interface CircleBatch {\n  x: number;\n  y: number;\n  radius: number;\n}\n\ninterface CircleOutlineBatch {\n  x: number;\n  y: number;\n  radius: number;\n  lineWidth: number;\n}\n\nexport class Renderer {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private width: number = 0;\n  private height: number = 0;\n  private dpr: number = 1;\n\n  private circleBatches: Map<string, CircleBatch[]> = new Map();\n  private outlineBatches: Map<string, CircleOutlineBatch[]> = new Map();\n\n  private static readonly TWO_PI = Math.PI * 2;\n  private static readonly SCALE = 1.3;\n\n  constructor(canvasId: string = 'game') {\n    const canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    if (!canvas) {\n      throw new Error(`Canvas element with id \"${canvasId}\" not found`);\n    }\n    this.canvas = canvas;\n    \n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get 2D context');\n    }\n    this.ctx = ctx;\n    \n    this.resize();\n    window.addEventListener('resize', () => this.resize());\n  }\n\n  resize(): void {\n    this.dpr = window.devicePixelRatio || 1;\n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n    \n    // Set canvas backing store to physical pixel size for crisp rendering\n    this.canvas.width = Math.floor(this.width * this.dpr);\n    this.canvas.height = Math.floor(this.height * this.dpr);\n    \n    // Keep CSS size at logical pixels\n    this.canvas.style.width = `${this.width}px`;\n    this.canvas.style.height = `${this.height}px`;\n  }\n\n  getBounds(): { width: number; height: number } {\n    return { width: this.width / Renderer.SCALE, height: this.height / Renderer.SCALE };\n  }\n\n  clear(color: string = '#000000'): void {\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.save();\n    this.ctx.scale(this.dpr * Renderer.SCALE, this.dpr * Renderer.SCALE);\n  }\n\n  endFrame(): void {\n    this.ctx.restore();\n  }\n\n  // Queue a circle - renders when flushBatches() is called\n  drawCircle(x: number, y: number, radius: number, color: string): void {\n    let batch = this.circleBatches.get(color);\n    if (!batch) {\n      batch = [];\n      this.circleBatches.set(color, batch);\n    }\n    batch.push({ x, y, radius });\n  }\n\n  drawCircleOutline(x: number, y: number, radius: number, color: string, lineWidth: number = 2): void {\n    let batch = this.outlineBatches.get(color);\n    if (!batch) {\n      batch = [];\n      this.outlineBatches.set(color, batch);\n    }\n    batch.push({ x, y, radius, lineWidth });\n  }\n\n  // Must be called once per frame after all entities rendered\n  flushBatches(): void {\n    const ctx = this.ctx;\n    \n    ctx.fillStyle = '';\n    this.circleBatches.forEach((batch, color) => {\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      for (let i = 0; i < batch.length; i++) {\n        const c = batch[i];\n        ctx.moveTo(c.x + c.radius, c.y);\n        ctx.arc(c.x, c.y, c.radius, 0, Renderer.TWO_PI);\n      }\n      ctx.fill();\n    });\n    this.circleBatches.clear();\n    \n    ctx.strokeStyle = '';\n    this.outlineBatches.forEach((batch, color) => {\n      const byWidth = new Map<number, CircleOutlineBatch[]>();\n      for (let i = 0; i < batch.length; i++) {\n        const o = batch[i];\n        let group = byWidth.get(o.lineWidth);\n        if (!group) {\n          group = [];\n          byWidth.set(o.lineWidth, group);\n        }\n        group.push(o);\n      }\n      \n      byWidth.forEach((group, lineWidth) => {\n        ctx.strokeStyle = color;\n        ctx.lineWidth = lineWidth;\n        ctx.beginPath();\n        for (let i = 0; i < group.length; i++) {\n          const o = group[i];\n          ctx.moveTo(o.x + o.radius, o.y);\n          ctx.arc(o.x, o.y, o.radius, 0, Renderer.TWO_PI);\n        }\n        ctx.stroke();\n      });\n    });\n    this.outlineBatches.clear();\n  }\n\n  drawCircleImmediate(x: number, y: number, radius: number, color: string): void {\n    this.ctx.fillStyle = color;\n    this.ctx.beginPath();\n    this.ctx.arc(x, y, radius, 0, Renderer.TWO_PI);\n    this.ctx.fill();\n  }\n\n  drawLine(x1: number, y1: number, x2: number, y2: number, color: string, width: number = 2): void {\n    this.ctx.beginPath();\n    this.ctx.moveTo(x1, y1);\n    this.ctx.lineTo(x2, y2);\n    this.ctx.strokeStyle = color;\n    this.ctx.lineWidth = width;\n    this.ctx.stroke();\n  }\n\n  drawArrow(x: number, y: number, angle: number, length: number, color: string = '#00CC00'): void {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const endX = x + cos * length;\n    const endY = y + sin * length;\n    \n    const ctx = this.ctx;\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 3;\n    \n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n    \n    const headLength = 8;\n    const headAngle = Math.PI / 6;\n    \n    ctx.beginPath();\n    ctx.moveTo(endX, endY);\n    ctx.lineTo(\n      endX - headLength * Math.cos(angle - headAngle),\n      endY - headLength * Math.sin(angle - headAngle)\n    );\n    ctx.moveTo(endX, endY);\n    ctx.lineTo(\n      endX - headLength * Math.cos(angle + headAngle),\n      endY - headLength * Math.sin(angle + headAngle)\n    );\n    ctx.stroke();\n  }\n\n  drawRect(x: number, y: number, width: number, height: number, color: string): void {\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(x, y, width, height);\n  }\n\n  drawText(text: string, x: number, y: number, color: string = '#FFFFFF', fontSize: number = 16): void {\n    this.ctx.font = `${fontSize}px Arial`;\n    this.ctx.fillStyle = color;\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(text, x, y);\n  }\n\n  drawTextLeft(text: string, x: number, y: number, color: string = '#FFFFFF', fontSize: number = 16): void {\n    this.ctx.font = `${fontSize}px Arial`;\n    this.ctx.fillStyle = color;\n    this.ctx.textAlign = 'left';\n    this.ctx.textBaseline = 'top';\n    this.ctx.fillText(text, x, y);\n  }\n\n  drawPolygon(points: { x: number; y: number }[], color: string): void {\n    if (points.length < 3) return;\n    \n    const ctx = this.ctx;\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      ctx.lineTo(points[i].x, points[i].y);\n    }\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  getContext(): CanvasRenderingContext2D {\n    return this.ctx;\n  }\n}\n","export const PLAYER_VISUAL_RADIUS = 10;\nexport const PLAYER_HITBOX_RADIUS = PLAYER_VISUAL_RADIUS * 0.5;\nexport const PLAYER_MAX_SPEED = 800;\nexport const PLAYER_ARROW_LENGTH = 15;\n\nexport const DOT_RADIUS = 8;\nexport const DOT_SPAWN_ANIMATION_DURATION = 1000;\nexport const DOT_SPAWN_SCALE_MAX = 1.5;\n\nexport const WEAPON_ORB_RADIUS = 20;\nexport const WEAPON_ORB_COUNT = 3;\nexport const WEAPON_ORB_MIN_SPACING = 100;\n\nexport const WRAP_ENABLED = true;\n\nexport const SCORE_KILL = 10;\nexport const SCORE_PATTERN_BONUS_MIN = 50;\nexport const SCORE_PATTERN_BONUS_MAX = 200;\nexport const SCORE_TIME_DIVISOR = 10;\n\nexport const DIFFICULTY_EASY_MAX_SCORE = 500;\nexport const DIFFICULTY_MEDIUM_MAX_SCORE = 1500;\n\nexport const PATTERN_SELECTION_INTERVAL = 8000;\n\nexport const COLOR_PLAYER = '#00FF00';\nexport const COLOR_PLAYER_ARROW = '#00CC00';\nexport const COLOR_DOT = '#FF0000';\nexport const COLOR_DOT_SPAWNING = '#FF6666';\nexport const COLOR_DOT_FROZEN = '#00FFFF';\nexport const COLOR_BACKGROUND = '#000000';\n\nexport const WEAPON_COLORS: Record<string, string> = {\n  KINETIC_BOMB: '#FF6600',\n  BLASTER: '#9900FF',\n  ICE_BOMB: '#00CCFF',\n  HOMING_MISSILE: '#FFFF00',\n  NUCLEAR_BOMB: '#FF0000',\n  ELECTRIC_BOMB: '#00FFFF',\n  DOT_REPELLENT: '#808080',\n  CHAINSAW: '#0066FF',\n  FLAME_BURST: '#FF9900'\n};\n\nexport const TARGET_FPS = 60;\nexport const FRAME_TIME = 1000 / TARGET_FPS;\n","import { Vector2 } from '../types';\nimport { PLAYER_MAX_SPEED } from '../utils/constants';\n\nexport type PermissionState = 'unknown' | 'pending' | 'granted' | 'denied';\n\ninterface TiltBasis {\n  gamma: number;\n  beta: number;\n}\n\nexport class InputManager {\n  private velocity: Vector2 = { x: 0, y: 0 };\n  private permissionState: PermissionState = 'unknown';\n  private tiltBasis: TiltBasis | null = null;\n\n  constructor() {\n    this.checkPermissionAvailability();\n    this.trackScreenOrientation();\n  }\n\n  private trackScreenOrientation(): void {\n    window.addEventListener('orientationchange', () => {});\n  }\n\n  setTiltBasis(basis: TiltBasis): void {\n    this.tiltBasis = basis;\n  }\n\n  getCurrentTiltBasis(): TiltBasis | null {\n    return this.tiltBasis;\n  }\n\n  private checkPermissionAvailability(): void {\n    if (typeof (DeviceOrientationEvent as any).requestPermission === 'function') {\n      this.permissionState = 'pending';\n    } else if (window.DeviceOrientationEvent) {\n      this.permissionState = 'granted';\n      this.enableDeviceOrientation();\n    } else {\n      this.permissionState = 'denied';\n    }\n  }\n\n  async requestPermission(): Promise<boolean> {\n    if (this.permissionState === 'granted') {\n      return true;\n    }\n\n    if (typeof (DeviceOrientationEvent as any).requestPermission === 'function') {\n      try {\n        const permissionPromise = (DeviceOrientationEvent as any).requestPermission() as Promise<'granted' | 'denied' | 'prompt'>;\n        const permission = await permissionPromise;\n\n        if (permission === 'granted') {\n          this.permissionState = 'granted';\n          this.enableDeviceOrientation();\n          return true;\n        } else {\n          this.permissionState = 'denied';\n          return false;\n        }\n      } catch (error) {\n        console.error('Device orientation permission error:', error);\n        this.permissionState = 'denied';\n        return false;\n      }\n    }\n\n    return (this.permissionState as PermissionState) === 'granted';\n  }\n\n  private enableDeviceOrientation(): void {\n    window.addEventListener('deviceorientation', this.handleOrientation.bind(this));\n  }\n\n  private lastTilt: TiltBasis = { gamma: 0, beta: 45 };\n\n  calibrateTiltBasis(): void {\n    this.tiltBasis = { ...this.lastTilt };\n  }\n\n  private getScreenOrientation(): number {\n    if (screen.orientation) {\n      return screen.orientation.angle;\n    }\n    return 0;\n  }\n\n  private transformTiltToGameCoords(gamma: number, beta: number, orientation: number): { x: number; y: number } {\n    const tiltX = gamma;\n    const tiltY = beta - 45;\n    \n    switch (orientation) {\n      case 0:\n        return { x: tiltX, y: tiltY };\n      case 90:\n      case -270:\n        return { x: -tiltY, y: tiltX };\n      case 180:\n      case -180:\n        return { x: -tiltX, y: -tiltY };\n      case -90:\n      case 270:\n        return { x: tiltY, y: -tiltX };\n      default:\n        return { x: tiltX, y: tiltY };\n    }\n  }\n\n  private handleOrientation(event: DeviceOrientationEvent): void {\n    if (event.gamma === null || event.beta === null) {\n      return;\n    }\n    \n    const gamma = event.gamma;\n    const beta = event.beta;\n    this.lastTilt = { gamma, beta };\n    \n    const orientation = this.getScreenOrientation();\n    const reference = this.tiltBasis;\n    \n    let gammaDelta = gamma;\n    let betaDelta = beta - 45;\n    \n    if (reference !== null) {\n      gammaDelta = gamma - reference.gamma;\n      betaDelta = (beta - 45) - (reference.beta - 45);\n    }\n    \n    const gameCoords = this.transformTiltToGameCoords(gammaDelta, betaDelta + 45, orientation);\n    \n    const normalizedX = this.clamp(gameCoords.x / 22.5, -1, 1);\n    const normalizedY = this.clamp(gameCoords.y / 22.5, -1, 1);\n    \n    this.velocity.x = normalizedX * PLAYER_MAX_SPEED;\n    this.velocity.y = normalizedY * PLAYER_MAX_SPEED;\n  }\n\n  private clamp(value: number, min: number, max: number): number {\n    return Math.max(min, Math.min(max, value));\n  }\n\n  getVelocity(): Vector2 {\n    return { x: this.velocity.x, y: this.velocity.y };\n  }\n\n  getPermissionState(): PermissionState {\n    return this.permissionState;\n  }\n\n  needsPermissionRequest(): boolean {\n    return this.permissionState === 'pending';\n  }\n\n  destroy(): void {\n    window.removeEventListener('deviceorientation', this.handleOrientation.bind(this));\n  }\n}\n","import { Vector2, Bounds } from '../types';\n\nexport class Vec2 implements Vector2 {\n  constructor(public x: number = 0, public y: number = 0) {}\n\n  static from(v: Vector2): Vec2 {\n    return new Vec2(v.x, v.y);\n  }\n\n  add(other: Vector2): Vec2 {\n    return new Vec2(this.x + other.x, this.y + other.y);\n  }\n\n  subtract(other: Vector2): Vec2 {\n    return new Vec2(this.x - other.x, this.y - other.y);\n  }\n\n  multiply(scalar: number): Vec2 {\n    return new Vec2(this.x * scalar, this.y * scalar);\n  }\n\n  divide(scalar: number): Vec2 {\n    if (scalar === 0) throw new Error('Division by zero');\n    return new Vec2(this.x / scalar, this.y / scalar);\n  }\n\n  magnitude(): number {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  normalize(): Vec2 {\n    const mag = this.magnitude();\n    if (mag === 0) return new Vec2(0, 0);\n    return this.divide(mag);\n  }\n\n  dot(other: Vector2): number {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  angleTo(other: Vector2): number {\n    return Math.atan2(other.y - this.y, other.x - this.x);\n  }\n\n  clone(): Vec2 {\n    return new Vec2(this.x, this.y);\n  }\n\n  set(x: number, y: number): void {\n    this.x = x;\n    this.y = y;\n  }\n\n  addInPlace(other: Vector2): void {\n    this.x += other.x;\n    this.y += other.y;\n  }\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value));\n}\n\nexport function distance(a: Vector2, b: Vector2): number {\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function wrap(position: Vector2, bounds: Bounds): Vector2 {\n  let x = position.x;\n  let y = position.y;\n  if (bounds.width > 0 && bounds.height > 0) {\n    while (x < 0) x += bounds.width;\n    while (y < 0) y += bounds.height;\n    x = x % bounds.width;\n    y = y % bounds.height;\n  }\n  return { x, y };\n}\n\nexport function wrapInPlace(position: Vector2, bounds: Bounds): void {\n  if (bounds.width > 0 && bounds.height > 0) {\n    while (position.x < 0) position.x += bounds.width;\n    while (position.y < 0) position.y += bounds.height;\n    position.x = position.x % bounds.width;\n    position.y = position.y % bounds.height;\n  }\n}\n\nexport function circleCollision(\n  a: Vector2,\n  radiusA: number,\n  b: Vector2,\n  radiusB: number\n): boolean {\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  const distanceSq = dx * dx + dy * dy;\n  const radiiSum = radiusA + radiusB;\n  return distanceSq < radiiSum * radiiSum;\n}\n\nexport function lerp(a: number, b: number, t: number): number {\n  return a + (b - a) * t;\n}\n\nexport function randomRange(min: number, max: number): number {\n  return min + Math.random() * (max - min);\n}\n\nexport function randomPosition(bounds: Bounds, margin: number = 0): Vector2 {\n  return {\n    x: margin + Math.random() * (bounds.width - margin * 2),\n    y: margin + Math.random() * (bounds.height - margin * 2)\n  };\n}\n","import { Vector2, Bounds } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { Vec2, wrapInPlace } from '../utils/math';\nimport { PLAYER_HITBOX_RADIUS, PLAYER_VISUAL_RADIUS, PLAYER_ARROW_LENGTH, COLOR_PLAYER, COLOR_PLAYER_ARROW } from '../utils/constants';\n\nexport class Player {\n  position: Vec2;\n  velocity: Vector2 = { x: 0, y: 0 };\n  directionAngle: number = 0;\n  readonly hitboxRadius: number = PLAYER_HITBOX_RADIUS;\n\n  constructor(x: number, y: number) {\n    this.position = new Vec2(x, y);\n  }\n\n  update(dt: number, inputVelocity: Vector2, bounds: Bounds, shouldWrap: boolean = true): void {\n    this.velocity.x = inputVelocity.x;\n    this.velocity.y = inputVelocity.y;\n    \n    if (this.velocity.x !== 0 || this.velocity.y !== 0) {\n      this.directionAngle = Math.atan2(this.velocity.y, this.velocity.x);\n    }\n    \n    this.position.x += this.velocity.x * dt;\n    this.position.y += this.velocity.y * dt;\n    \n    if (shouldWrap) {\n      wrapInPlace(this.position, bounds);\n    } else {\n      this.position.x = Math.max(0, Math.min(bounds.width, this.position.x));\n      this.position.y = Math.max(0, Math.min(bounds.height, this.position.y));\n    }\n  }\n\n  setPosition(x: number, y: number): void {\n    this.position.x = x;\n    this.position.y = y;\n  }\n\n  render(renderer: Renderer): void {\n    renderer.drawCircleImmediate(\n      this.position.x,\n      this.position.y,\n      PLAYER_VISUAL_RADIUS,\n      COLOR_PLAYER\n    );\n    \n    const arrowStartX = this.position.x + Math.cos(this.directionAngle) * (PLAYER_VISUAL_RADIUS + 2);\n    const arrowStartY = this.position.y + Math.sin(this.directionAngle) * (PLAYER_VISUAL_RADIUS + 2);\n    \n    renderer.drawArrow(\n      arrowStartX,\n      arrowStartY,\n      this.directionAngle,\n      PLAYER_ARROW_LENGTH,\n      COLOR_PLAYER_ARROW\n    );\n  }\n\n  getPosition(): Vector2 {\n    return this.position;\n  }\n}\n","export class ScoringSystem {\n  private score: number = 0;\n  private kills: number = 0;\n  private startTime: number = 0;\n\n  start(): void {\n    this.score = 0;\n    this.kills = 0;\n    this.startTime = Date.now();\n  }\n\n  addKill(): void {\n    this.kills++;\n  }\n\n  addKills(count: number): void {\n    this.kills += count;\n  }\n\n  addPatternBonus(difficulty: string): void {\n    const bonuses = { EASY: 50, MEDIUM: 100, HARD: 200 };\n    this.score += bonuses[difficulty as keyof typeof bonuses] || 50;\n  }\n\n  getScore(): number {\n    const timeBonus = Math.floor((Date.now() - this.startTime) / 10000);\n    return this.score + this.kills * 10 + timeBonus;\n  }\n\n  getKills(): number {\n    return this.kills;\n  }\n\n  getTimeAlive(): number {\n    return Date.now() - this.startTime;\n  }\n}\n","import { Bounds } from '../types';\nimport { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponOrb } from '../entities/WeaponOrb';\nimport { circleCollision } from '../utils/math';\n\nconst CELL_SIZE = 100;\n\n// Pre-allocated array for nearby cell offsets - avoids allocation during collision checks\nconst NEARBY_OFFSETS = [\n  [-1, -1], [0, -1], [1, -1],\n  [-1, 0], [0, 0], [1, 0],\n  [-1, 1], [0, 1], [1, 1]\n];\n\nexport class CollisionSystem {\n  // Use numeric key instead of string to avoid allocations\n  private grid: Map<number, Dot[]> = new Map();\n  \n  // Pre-allocated array for nearby keys - reused each frame\n  private nearbyKeys: number[] = new Array(9);\n\n  constructor(_bounds: Bounds) {\n  }\n  \n  // Use numeric key: cellX * 10000 + cellY (assumes grid < 10000 cells wide)\n  private getCellKey(x: number, y: number): number {\n    const cellX = Math.floor(x / CELL_SIZE);\n    const cellY = Math.floor(y / CELL_SIZE);\n    return cellX * 10000 + cellY;\n  }\n  \n  private getNearbyKeys(x: number, y: number): number[] {\n    const cellX = Math.floor(x / CELL_SIZE);\n    const cellY = Math.floor(y / CELL_SIZE);\n    \n    for (let i = 0; i < 9; i++) {\n      const [dx, dy] = NEARBY_OFFSETS[i];\n      this.nearbyKeys[i] = (cellX + dx) * 10000 + (cellY + dy);\n    }\n    return this.nearbyKeys;\n  }\n  \n  rebuildGrid(dots: Dot[]): void {\n    // Clear and reuse map instead of creating new one\n    this.grid.clear();\n\n    for (let i = 0; i < dots.length; i++) {\n      const dot = dots[i];\n      if (!dot.isLethal() && !dot.isFrozen()) continue;\n\n      const pos = dot.getPosition();\n      const key = this.getCellKey(pos.x, pos.y);\n\n      let cell = this.grid.get(key);\n      if (!cell) {\n        cell = [];\n        this.grid.set(key, cell);\n      }\n\n      cell.push(dot);\n    }\n  }\n  \n  checkPlayerDotCollision(player: Player): Dot | null {\n    const playerPos = player.getPosition();\n    const playerRadius = player.hitboxRadius;\n    \n    const nearbyKeys = this.getNearbyKeys(playerPos.x, playerPos.y);\n    \n    for (let i = 0; i < 9; i++) {\n      const cell = this.grid.get(nearbyKeys[i]);\n      if (!cell) continue;\n      \n      for (let j = 0; j < cell.length; j++) {\n        const dot = cell[j];\n        const dotPos = dot.getPosition();\n        const dotRadius = dot.getEffectiveRadius();\n\n        if (circleCollision(playerPos, playerRadius, dotPos, dotRadius)) {\n          return dot;\n        }\n      }\n    }\n    \n    return null;\n  }\n  \n  checkPlayerOrbCollision(player: Player, orbs: WeaponOrb[]): WeaponOrb | null {\n    const playerPos = player.getPosition();\n    const playerRadius = player.hitboxRadius;\n    \n    for (let i = 0; i < orbs.length; i++) {\n      const orb = orbs[i];\n      if (!orb.isActive()) continue;\n      \n      const orbPos = orb.getPosition();\n      const orbRadius = orb.radius;\n      \n      if (circleCollision(playerPos, playerRadius, orbPos, orbRadius)) {\n        return orb;\n      }\n    }\n    \n    return null;\n  }\n\n  updateBounds(_bounds: Bounds): void {\n  }\n}\n","import { Difficulty } from '../types';\n\nexport class DifficultyManager {\n  private currentDifficulty: Difficulty = Difficulty.EASY;\n  private readonly mediumThreshold: number = 500;\n  private readonly hardThreshold: number = 1500;\n\n  update(score: number): void {\n    if (score >= this.hardThreshold) {\n      this.currentDifficulty = Difficulty.HARD;\n    } else if (score >= this.mediumThreshold) {\n      this.currentDifficulty = Difficulty.MEDIUM;\n    } else {\n      this.currentDifficulty = Difficulty.EASY;\n    }\n  }\n\n  getDifficulty(): Difficulty {\n    return this.currentDifficulty;\n  }\n\n  getSpawnRateMultiplier(): number {\n    const multipliers = {\n      [Difficulty.EASY]: 1.0,\n      [Difficulty.MEDIUM]: 1.5,\n      [Difficulty.HARD]: 2.0\n    };\n    return multipliers[this.currentDifficulty];\n  }\n\n  getMaxDots(): number {\n    const maxDots = {\n      [Difficulty.EASY]: 150,\n      [Difficulty.MEDIUM]: 225,\n      [Difficulty.HARD]: 300\n    };\n    return maxDots[this.currentDifficulty];\n  }\n}\n","import { PatternType } from '../types';\nimport type { Pattern } from './Pattern';\n\ntype PatternConstructor = new () => Pattern;\n\nclass PatternRegistryImpl {\n  private patterns: Map<PatternType, PatternConstructor> = new Map();\n\n  register(type: PatternType, patternClass: PatternConstructor): void {\n    this.patterns.set(type, patternClass);\n  }\n\n  create(type: PatternType): Pattern | null {\n    const PatternClass = this.patterns.get(type);\n    if (!PatternClass) return null;\n    return new PatternClass();\n  }\n\n  getAvailableTypes(): PatternType[] {\n    return Array.from(this.patterns.keys());\n  }\n}\n\nexport const PatternRegistry = new PatternRegistryImpl();\n","export interface ToastMessage {\n  id: number;\n  text: string;\n  type: 'info' | 'success' | 'warning' | 'error';\n  createdAt: number;\n  duration: number;\n}\n\nexport class ToastManager {\n  private toasts: ToastMessage[] = [];\n  private allMessages: ToastMessage[] = [];\n  private container: HTMLElement;\n  private errorOverlay: HTMLElement | null = null;\n  private nextId: number = 0;\n  private readonly maxToasts: number = 5;\n  private readonly defaultDuration: number = 3000;\n\n  constructor() {\n    this.container = document.createElement('div');\n    this.container.id = 'toast-container';\n    this.container.style.cssText = `\n      position: fixed;\n      bottom: 20px;\n      right: 20px;\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n      z-index: 1000;\n      pointer-events: none;\n      font-family: Arial, sans-serif;\n    `;\n    document.body.appendChild(this.container);\n  }\n\n  show(text: string, type: ToastMessage['type'] = 'info', duration?: number): void {\n    const toast: ToastMessage = {\n      id: this.nextId++,\n      text,\n      type,\n      createdAt: Date.now(),\n      duration: duration ?? this.defaultDuration\n    };\n\n    this.toasts.push(toast);\n    this.allMessages.push(toast);\n\n    if (this.allMessages.length > 100) {\n      this.allMessages = this.allMessages.slice(-50);\n    }\n\n    if (this.toasts.length > this.maxToasts) {\n      const removed = this.toasts.shift();\n      if (removed) {\n        this.removeToastElement(removed.id);\n      }\n    }\n\n    this.renderToast(toast);\n    this.scheduleRemoval(toast);\n  }\n\n  private renderToast(toast: ToastMessage): void {\n    const element = document.createElement('div');\n    element.id = `toast-${toast.id}`;\n    \n    const colors = this.getColorsForType(toast.type);\n    \n    element.style.cssText = `\n      background: ${colors.background};\n      color: ${colors.text};\n      padding: 10px 16px;\n      border-radius: 4px;\n      font-size: 14px;\n      max-width: 280px;\n      word-wrap: break-word;\n      opacity: 0;\n      transform: translateX(20px);\n      transition: opacity 0.3s ease, transform 0.3s ease;\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n      border-left: 3px solid ${colors.border};\n    `;\n    element.textContent = toast.text;\n\n    this.container.appendChild(element);\n\n    requestAnimationFrame(() => {\n      element.style.opacity = '1';\n      element.style.transform = 'translateX(0)';\n    });\n  }\n\n  private getColorsForType(type: ToastMessage['type']): { background: string; text: string; border: string } {\n    switch (type) {\n      case 'success':\n        return {\n          background: 'rgba(0, 100, 0, 0.9)',\n          text: '#90EE90',\n          border: '#00FF00'\n        };\n      case 'warning':\n        return {\n          background: 'rgba(100, 80, 0, 0.9)',\n          text: '#FFE4B5',\n          border: '#FFD700'\n        };\n      case 'error':\n        return {\n          background: 'rgba(100, 0, 0, 0.9)',\n          text: '#FFB6C1',\n          border: '#FF4444'\n        };\n      case 'info':\n      default:\n        return {\n          background: 'rgba(30, 30, 30, 0.9)',\n          text: '#E0E0E0',\n          border: '#888888'\n        };\n    }\n  }\n\n  private scheduleRemoval(toast: ToastMessage): void {\n    setTimeout(() => {\n      this.removeToast(toast.id);\n    }, toast.duration);\n  }\n\n  private removeToast(id: number): void {\n    const index = this.toasts.findIndex(t => t.id === id);\n    if (index !== -1) {\n      this.toasts.splice(index, 1);\n      this.removeToastElement(id);\n    }\n  }\n\n  private removeToastElement(id: number): void {\n    const element = document.getElementById(`toast-${id}`);\n    if (element) {\n      element.style.opacity = '0';\n      element.style.transform = 'translateX(20px)';\n      setTimeout(() => {\n        element.remove();\n      }, 300);\n    }\n  }\n\n  clear(): void {\n    this.toasts.forEach(toast => {\n      this.removeToastElement(toast.id);\n    });\n    this.toasts = [];\n    this.allMessages = [];\n  }\n\n  getRecentMessages(count: number = 5): ToastMessage[] {\n    return this.toasts.slice(-count);\n  }\n\n  getAllMessages(): ToastMessage[] {\n    return this.allMessages;\n  }\n\n  setupGlobalErrorHandler(): void {\n    window.addEventListener('error', (event) => {\n      const stack = event.error?.stack ?? 'No stack trace available';\n      this.showFatalError('Runtime Error', event.message, stack, event.filename, event.lineno, event.colno);\n    });\n\n    window.addEventListener('unhandledrejection', (event) => {\n      const error = event.reason;\n      const message = error instanceof Error ? error.message : String(error);\n      const stack = error instanceof Error ? (error.stack ?? 'No stack trace available') : 'No stack trace available';\n      this.showFatalError('Unhandled Promise Rejection', message, stack);\n    });\n  }\n\n  private showFatalError(title: string, message: string, stack: string, filename?: string, lineno?: number, colno?: number): void {\n    if (this.errorOverlay) return;\n\n    this.errorOverlay = document.createElement('div');\n    this.errorOverlay.id = 'fatal-error-overlay';\n    this.errorOverlay.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100vw;\n      height: 100vh;\n      background: rgba(0, 0, 0, 0.95);\n      z-index: 9999;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      justify-content: flex-start;\n      padding: 40px;\n      box-sizing: border-box;\n      font-family: 'Courier New', monospace;\n      overflow-y: auto;\n    `;\n\n    const content = document.createElement('div');\n    content.style.cssText = `\n      max-width: 900px;\n      width: 100%;\n      background: #1a1a1a;\n      border: 2px solid #ff4444;\n      border-radius: 8px;\n      padding: 30px;\n      box-shadow: 0 0 30px rgba(255, 68, 68, 0.3);\n    `;\n\n    const header = document.createElement('h1');\n    header.textContent = 'âš ï¸ ' + title;\n    header.style.cssText = `\n      color: #ff4444;\n      margin: 0 0 20px 0;\n      font-size: 24px;\n      font-family: Arial, sans-serif;\n    `;\n\n    const messageDiv = document.createElement('div');\n    messageDiv.textContent = message;\n    messageDiv.style.cssText = `\n      color: #ffffff;\n      font-size: 16px;\n      margin-bottom: 10px;\n      padding: 10px;\n      background: rgba(255, 68, 68, 0.1);\n      border-radius: 4px;\n      font-family: Arial, sans-serif;\n    `;\n\n    content.appendChild(header);\n    content.appendChild(messageDiv);\n\n    if (filename) {\n      const locationDiv = document.createElement('div');\n      locationDiv.textContent = `Location: ${filename}:${lineno ?? '?'}:${colno ?? '?'}`;\n      locationDiv.style.cssText = `\n        color: #aaaaaa;\n        font-size: 12px;\n        margin-bottom: 20px;\n        font-family: Arial, sans-serif;\n      `;\n      content.appendChild(locationDiv);\n    }\n\n    const stackHeader = document.createElement('div');\n    stackHeader.textContent = 'Stack Trace:';\n    stackHeader.style.cssText = `\n      color: #ff8844;\n      font-size: 14px;\n      margin: 20px 0 10px 0;\n      font-weight: bold;\n      font-family: Arial, sans-serif;\n    `;\n    content.appendChild(stackHeader);\n\n    const stackTrace = document.createElement('pre');\n    stackTrace.textContent = stack;\n    stackTrace.style.cssText = `\n      color: #cccccc;\n      font-size: 12px;\n      line-height: 1.5;\n      background: #0a0a0a;\n      padding: 15px;\n      border-radius: 4px;\n      overflow-x: auto;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n      max-height: 400px;\n      overflow-y: auto;\n      border: 1px solid #333;\n      margin: 0;\n    `;\n    content.appendChild(stackTrace);\n\n    const buttonContainer = document.createElement('div');\n    buttonContainer.style.cssText = `\n      display: flex;\n      gap: 10px;\n      margin-top: 20px;\n    `;\n\n    const reloadButton = document.createElement('button');\n    reloadButton.textContent = 'ðŸ”„ Reload Game';\n    reloadButton.style.cssText = `\n      padding: 12px 24px;\n      font-size: 14px;\n      background: #ff4444;\n      color: white;\n      border: none;\n      border-radius: 4px;\n      cursor: pointer;\n      font-family: Arial, sans-serif;\n      font-weight: bold;\n    `;\n    reloadButton.onmouseover = () => reloadButton.style.background = '#ff6666';\n    reloadButton.onmouseout = () => reloadButton.style.background = '#ff4444';\n    reloadButton.onclick = () => window.location.reload();\n\n    const copyButton = document.createElement('button');\n    copyButton.textContent = 'ðŸ“‹ Copy Error';\n    copyButton.style.cssText = `\n      padding: 12px 24px;\n      font-size: 14px;\n      background: #444444;\n      color: white;\n      border: none;\n      border-radius: 4px;\n      cursor: pointer;\n      font-family: Arial, sans-serif;\n      font-weight: bold;\n    `;\n    copyButton.onmouseover = () => copyButton.style.background = '#555555';\n    copyButton.onmouseout = () => copyButton.style.background = '#444444';\n    copyButton.onclick = () => {\n      const fullError = `${title}\\n${message}\\n${filename ? `Location: ${filename}:${lineno}:${colno}\\n` : ''}\\nStack Trace:\\n${stack}`;\n      navigator.clipboard.writeText(fullError).then(() => {\n        copyButton.textContent = 'âœ… Copied!';\n        setTimeout(() => copyButton.textContent = 'ðŸ“‹ Copy Error', 2000);\n      });\n    };\n\n    buttonContainer.appendChild(reloadButton);\n    buttonContainer.appendChild(copyButton);\n    content.appendChild(buttonContainer);\n\n    this.errorOverlay.appendChild(content);\n    document.body.appendChild(this.errorOverlay);\n\n    console.error(`[FATAL ERROR] ${title}:`, message, '\\nStack:', stack);\n  }\n}\n\nexport const toastManager = new ToastManager();\n","import { Pattern } from '../patterns/Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { PatternRegistry } from '../patterns/PatternRegistry';\nimport { Dot } from '../entities/Dot';\nimport { toastManager } from './ToastManager';\n\nconst PATTERN_DIFFICULTY_MAP: Map<PatternType, Difficulty> = new Map([\n  [PatternType.ZOMBIE_SNOW, Difficulty.EASY],\n  [PatternType.SPARSE_GRID, Difficulty.EASY],\n  [PatternType.CONTAINMENT_RING, Difficulty.EASY],\n  [PatternType.SWEEPER_LINE, Difficulty.MEDIUM],\n  [PatternType.GATLING_POINT, Difficulty.MEDIUM],\n  [PatternType.BOUNCING_BALL, Difficulty.MEDIUM],\n  [PatternType.BULLET_HELL, Difficulty.HARD],\n  [PatternType.CYCLONE, Difficulty.HARD],\n]);\n\nconst SCORE_THRESHOLDS = {\n  EASY_MAX: 500,\n  MEDIUM_MAX: 1500,\n};\n\nexport class PatternManager {\n  private activePatterns: Pattern[] = [];\n  private patternTimer: number = 0;\n  private nextPatternInterval: number = 3000;\n  private currentScore: number = 0;\n  private allDotsCache: Dot[] = [];\n\n  private readonly minInterval: number = 2000;\n  private readonly maxInterval: number = 4000;\n\n  constructor() {\n    this.nextPatternInterval = this.getRandomInterval();\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    this.patternTimer += dt * 1000;\n    if (this.patternTimer >= this.nextPatternInterval) {\n      this.patternTimer = 0;\n      this.nextPatternInterval = this.getRandomInterval();\n      const nextType = this.selectNextPattern();\n      if (nextType) {\n        this.spawnPattern(nextType, playerPosition, bounds);\n      }\n    }\n\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      const pattern = this.activePatterns[i];\n      pattern.tick(dt);\n      pattern.update(dt, playerPosition, bounds);\n    }\n\n    this.removeCompletedPatterns();\n    this.rebuildDotsCache();\n  }\n\n  addPattern(pattern: Pattern): void {\n    if (this.isPatternTypeActive(pattern.type)) {\n      return;\n    }\n    this.activePatterns.push(pattern);\n  }\n\n  removePattern(pattern: Pattern): void {\n    const index = this.activePatterns.indexOf(pattern);\n    if (index !== -1) {\n      pattern.clear();\n      this.activePatterns.splice(index, 1);\n    }\n  }\n\n  getActivePatterns(): Pattern[] {\n    return this.activePatterns;\n  }\n\n  getAllDots(): Dot[] {\n    return this.allDotsCache;\n  }\n\n  private rebuildDotsCache(): void {\n    this.allDotsCache.length = 0;\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      const dots = this.activePatterns[i].getDots();\n      for (let j = 0; j < dots.length; j++) {\n        this.allDotsCache.push(dots[j]);\n      }\n    }\n  }\n\n  setScore(score: number): void {\n    this.currentScore = score;\n  }\n\n  getAvailablePatternTypes(): PatternType[] {\n    const availableTypes: PatternType[] = [];\n    const allTypes = PatternRegistry.getAvailableTypes();\n\n    for (const type of allTypes) {\n      const difficulty = PATTERN_DIFFICULTY_MAP.get(type);\n      if (!difficulty) continue;\n\n      if (this.isDifficultyAvailable(difficulty)) {\n        availableTypes.push(type);\n      }\n    }\n\n    return availableTypes;\n  }\n\n  selectNextPattern(): PatternType | null {\n    const availableTypes = this.getAvailablePatternTypes();\n    \n    const candidateTypes = availableTypes.filter(\n      type => !this.isPatternTypeActive(type)\n    );\n\n    if (candidateTypes.length === 0) {\n      return null;\n    }\n\n    const randomIndex = Math.floor(Math.random() * candidateTypes.length);\n    return candidateTypes[randomIndex];\n  }\n\n  spawnPattern(type: PatternType, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.isPatternTypeActive(type)) {\n      return;\n    }\n\n    const pattern = PatternRegistry.create(type);\n    if (!pattern) {\n      console.warn(`Failed to create pattern of type: ${type}`);\n      return;\n    }\n\n    toastManager.show(`Pattern: ${this.formatPatternName(type)}`, 'info');\n    pattern.spawn(playerPosition, bounds);\n    pattern.start();\n    this.activePatterns.push(pattern);\n  }\n\n  private isPatternTypeActive(type: PatternType): boolean {\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      if (this.activePatterns[i].type === type) return true;\n    }\n    return false;\n  }\n\n  private isDifficultyAvailable(difficulty: Difficulty): boolean {\n    switch (difficulty) {\n      case Difficulty.EASY:\n        return this.currentScore < SCORE_THRESHOLDS.EASY_MAX;\n      case Difficulty.MEDIUM:\n        return this.currentScore >= SCORE_THRESHOLDS.EASY_MAX && \n               this.currentScore < SCORE_THRESHOLDS.MEDIUM_MAX;\n      case Difficulty.HARD:\n        return this.currentScore >= SCORE_THRESHOLDS.MEDIUM_MAX;\n      default:\n        return false;\n    }\n  }\n\n  private removeCompletedPatterns(): void {\n    for (let i = this.activePatterns.length - 1; i >= 0; i--) {\n      if (this.activePatterns[i].isComplete()) {\n        const completedPattern = this.activePatterns[i];\n        completedPattern.clear();\n        this.activePatterns.splice(i, 1);\n        toastManager.show(`Pattern ended: ${this.formatPatternName(completedPattern.type)}`, 'info');\n      }\n    }\n  }\n\n  clear(): void {\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      this.activePatterns[i].clear();\n    }\n    this.activePatterns = [];\n    this.patternTimer = 0;\n    this.allDotsCache.length = 0;\n  }\n\n  getPatternTimer(): number {\n    return this.patternTimer;\n  }\n\n  getPatternInterval(): number {\n    return this.nextPatternInterval;\n  }\n\n  private getRandomInterval(): number {\n    return this.minInterval + Math.random() * (this.maxInterval - this.minInterval);\n  }\n\n  private formatPatternName(type: PatternType): string {\n    return type\n      .toLowerCase()\n      .split('_')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n}\n","import { Vector2 } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { WeaponType } from '../types';\nimport { WEAPON_ORB_RADIUS, WEAPON_COLORS } from '../utils/constants';\n\nexport class WeaponOrb {\n  position: Vector2;\n  weaponType: WeaponType;\n  pickedUp: boolean = false;\n  readonly radius: number = WEAPON_ORB_RADIUS;\n\n  // Weapons that bounce when collided with\n  private static readonly BOUNCED_WEAPONS: WeaponType[] = [\n    WeaponType.NUCLEAR_BOMB,\n    WeaponType.ELECTRIC_BOMB\n  ];\n\n  // Bounce physics state for bounced weapons\n  private velocity: Vector2 = { x: 0, y: 0 };\n  private lastBounceTime: number = 0;\n  private readonly bounceCooldown: number = 100;\n\n  constructor(x: number, y: number, weaponType: WeaponType) {\n    this.position = { x, y };\n    this.weaponType = weaponType;\n  }\n\n  render(renderer: Renderer): void {\n    if (this.pickedUp) return;\n\n    const color = WEAPON_COLORS[this.weaponType] || '#FFFFFF';\n\n    renderer.drawCircleImmediate(\n      this.position.x,\n      this.position.y,\n      this.radius,\n      color\n    );\n\n    const isBouncedWeapon = WeaponOrb.BOUNCED_WEAPONS.includes(this.weaponType);\n    const borderColor = isBouncedWeapon ? '#9B30FF' : '#FFFFFF';\n\n    const ctx = renderer.getContext();\n    ctx.strokeStyle = borderColor;\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.arc(this.position.x, this.position.y, this.radius + 2, 0, Math.PI * 2);\n    ctx.stroke();\n\n    this.drawIcon(ctx, this.position.x, this.position.y, this.radius);\n  }\n\n  private drawIcon(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number): void {\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n    ctx.fillStyle = '#FFFFFF';\n\n    const iconScale = radius * 0.5;\n\n    switch (this.weaponType) {\n      case WeaponType.KINETIC_BOMB:\n        this.drawKineticBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.BLASTER:\n        this.drawBlasterIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.ICE_BOMB:\n        this.drawIceBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.HOMING_MISSILE:\n        this.drawHomingMissileIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.NUCLEAR_BOMB:\n        this.drawNuclearBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.ELECTRIC_BOMB:\n        this.drawElectricBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.DOT_REPELLENT:\n        this.drawDotRepellentIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.CHAINSAW:\n        this.drawChainsawIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.FLAME_BURST:\n        this.drawFlameBurstIcon(ctx, x, y, iconScale);\n        break;\n    }\n  }\n\n  private drawKineticBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.3, 0, Math.PI * 2);\n    ctx.fill();\n\n    for (let i = 0; i < 8; i++) {\n      const angle = (i / 8) * Math.PI * 2;\n      ctx.beginPath();\n      ctx.moveTo(x + Math.cos(angle) * scale * 0.4, y + Math.sin(angle) * scale * 0.4);\n      ctx.lineTo(x + Math.cos(angle) * scale * 0.8, y + Math.sin(angle) * scale * 0.8);\n      ctx.stroke();\n    }\n  }\n\n  private drawBlasterIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.fillRect(x - scale * 0.8, y - scale * 0.15, scale * 1.6, scale * 0.3);\n    ctx.fillRect(x - scale * 0.9, y - scale * 0.4, scale * 0.3, scale * 0.8);\n    ctx.fillRect(x + scale * 0.6, y - scale * 0.4, scale * 0.3, scale * 0.8);\n  }\n\n  private drawIceBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    for (let i = 0; i < 6; i++) {\n      const angle = (i / 6) * Math.PI * 2;\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(angle) * scale * 0.8, y + Math.sin(angle) * scale * 0.8);\n      ctx.stroke();\n      const branchX = x + Math.cos(angle) * scale * 0.5;\n      const branchY = y + Math.sin(angle) * scale * 0.5;\n      ctx.beginPath();\n      ctx.moveTo(branchX, branchY);\n      ctx.lineTo(branchX + Math.cos(angle + Math.PI / 4) * scale * 0.3, branchY + Math.sin(angle + Math.PI / 4) * scale * 0.3);\n      ctx.moveTo(branchX, branchY);\n      ctx.lineTo(branchX + Math.cos(angle - Math.PI / 4) * scale * 0.3, branchY + Math.sin(angle - Math.PI / 4) * scale * 0.3);\n      ctx.stroke();\n    }\n  }\n\n  private drawHomingMissileIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    const arrowSize = scale * 0.25;\n    const spacing = scale * 0.35;\n\n    for (let i = -1; i <= 1; i++) {\n      const arrowX = x + i * spacing;\n      const arrowY = y;\n      this.drawArrowUp(ctx, arrowX, arrowY, arrowSize);\n    }\n  }\n\n  private drawArrowUp(ctx: CanvasRenderingContext2D, x: number, y: number, size: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x, y - size);\n    ctx.lineTo(x - size * 0.5, y + size * 0.3);\n    ctx.lineTo(x + size * 0.5, y + size * 0.3);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private drawNuclearBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    const skullScale = scale * 0.7;\n\n    // Skull head (circle)\n    ctx.beginPath();\n    ctx.arc(x, y - skullScale * 0.1, skullScale * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Eye sockets (two black circles)\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.arc(x - skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(x + skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Nose (inverted triangle)\n    ctx.beginPath();\n    ctx.moveTo(x, y + skullScale * 0.05);\n    ctx.lineTo(x - skullScale * 0.08, y + skullScale * 0.2);\n    ctx.lineTo(x + skullScale * 0.08, y + skullScale * 0.2);\n    ctx.closePath();\n    ctx.fill();\n\n    // Jaw / teeth area\n    ctx.fillStyle = '#FFFFFF';\n    ctx.beginPath();\n    ctx.rect(x - skullScale * 0.25, y + skullScale * 0.25, skullScale * 0.5, skullScale * 0.2);\n    ctx.fill();\n\n    // Teeth lines\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 1.5;\n    for (let i = 1; i <= 2; i++) {\n      const teethX = x - skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX, y + skullScale * 0.25);\n      ctx.lineTo(teethX, y + skullScale * 0.45);\n      ctx.stroke();\n\n      const teethX2 = x + skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX2, y + skullScale * 0.25);\n      ctx.lineTo(teethX2, y + skullScale * 0.45);\n      ctx.stroke();\n    }\n\n    // Crossbones (X shape behind skull)\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 3;\n    ctx.lineCap = 'round';\n\n    // Bone 1 (backslash)\n    ctx.beginPath();\n    ctx.moveTo(x - skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x + skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    // Bone 2 (forward slash)\n    ctx.beginPath();\n    ctx.moveTo(x + skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x - skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    // Bone ends (small circles at ends of bones)\n    ctx.fillStyle = '#FFFFFF';\n    const boneEndRadius = skullScale * 0.1;\n    const boneEnds = [\n      { x: x - skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y + skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x - skullScale * 0.7, y: y + skullScale * 0.5 }\n    ];\n\n    for (const end of boneEnds) {\n      ctx.beginPath();\n      ctx.arc(end.x, end.y, boneEndRadius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  private drawElectricBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x + scale * 0.2, y - scale * 0.8);\n    ctx.lineTo(x - scale * 0.1, y - scale * 0.1);\n    ctx.lineTo(x + scale * 0.3, y - scale * 0.1);\n    ctx.lineTo(x - scale * 0.2, y + scale * 0.8);\n    ctx.lineTo(x, y + scale * 0.1);\n    ctx.lineTo(x - scale * 0.3, y + scale * 0.1);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private drawDotRepellentIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.3, 0, Math.PI * 2);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.6, 0, Math.PI * 2);\n    ctx.stroke();\n\n    for (let i = 0; i < 4; i++) {\n      const angle = (i / 4) * Math.PI * 2;\n      this.drawOutwardArrow(ctx, x, y, angle, scale);\n    }\n  }\n\n  private drawOutwardArrow(ctx: CanvasRenderingContext2D, x: number, y: number, angle: number, scale: number): void {\n    const arrowX = x + Math.cos(angle) * scale * 0.45;\n    const arrowY = y + Math.sin(angle) * scale * 0.45;\n    const size = scale * 0.2;\n\n    ctx.beginPath();\n    ctx.moveTo(arrowX + Math.cos(angle) * size, arrowY + Math.sin(angle) * size);\n    ctx.lineTo(arrowX + Math.cos(angle + 2.5) * size, arrowY + Math.sin(angle + 2.5) * size);\n    ctx.lineTo(arrowX + Math.cos(angle - 2.5) * size, arrowY + Math.sin(angle - 2.5) * size);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private drawChainsawIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.5, 0, Math.PI * 2);\n    ctx.stroke();\n\n    const numTeeth = 8;\n    for (let i = 0; i < numTeeth; i++) {\n      const angle = (i / numTeeth) * Math.PI * 2;\n      const innerR = scale * 0.5;\n      const outerR = scale * 0.7;\n      ctx.beginPath();\n      ctx.moveTo(x + Math.cos(angle - 0.15) * innerR, y + Math.sin(angle - 0.15) * innerR);\n      ctx.lineTo(x + Math.cos(angle) * outerR, y + Math.sin(angle) * outerR);\n      ctx.lineTo(x + Math.cos(angle + 0.15) * innerR, y + Math.sin(angle + 0.15) * innerR);\n      ctx.fill();\n    }\n\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  private drawFlameBurstIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x, y - scale * 0.8);\n    ctx.bezierCurveTo(\n      x - scale * 0.4, y - scale * 0.3,\n      x - scale * 0.6, y + scale * 0.2,\n      x - scale * 0.2, y + scale * 0.6\n    );\n    ctx.quadraticCurveTo(x, y + scale * 0.8, x + scale * 0.2, y + scale * 0.6);\n    ctx.bezierCurveTo(\n      x + scale * 0.6, y + scale * 0.2,\n      x + scale * 0.4, y - scale * 0.3,\n      x, y - scale * 0.8\n    );\n    ctx.fill();\n\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n    ctx.beginPath();\n    ctx.moveTo(x, y - scale * 0.4);\n    ctx.bezierCurveTo(\n      x - scale * 0.2, y,\n      x - scale * 0.3, y + scale * 0.3,\n      x, y + scale * 0.5\n    );\n    ctx.bezierCurveTo(\n      x + scale * 0.3, y + scale * 0.3,\n      x + scale * 0.2, y,\n      x, y - scale * 0.4\n    );\n    ctx.fill();\n  }\n\n  isCollidingWith(playerPosition: Vector2, playerRadius: number): boolean {\n    const dx = this.position.x - playerPosition.x;\n    const dy = this.position.y - playerPosition.y;\n    const distSq = dx * dx + dy * dy;\n    const radiiSum = this.radius + playerRadius;\n    return distSq < radiiSum * radiiSum;\n  }\n\n  getPosition(): Vector2 {\n    return this.position;\n  }\n\n  getWeaponType(): WeaponType {\n    return this.weaponType;\n  }\n\n  pickup(): void {\n    this.pickedUp = true;\n  }\n\n  isActive(): boolean {\n    return !this.pickedUp;\n  }\n\n\n  bounce(playerVelocity: Vector2, playerPosition: Vector2): boolean {\n    const now = Date.now();\n    if (now - this.lastBounceTime < this.bounceCooldown) {\n      return false;\n    }\n    this.lastBounceTime = now;\n\n    // Check if this is a bounced weapon\n    if (!WeaponOrb.BOUNCED_WEAPONS.includes(this.weaponType)) {\n      return false;\n    }\n\n    const dx = this.position.x - playerPosition.x;\n    const dy = this.position.y - playerPosition.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance === 0) {\n      this.velocity.x = playerVelocity.x;\n      this.velocity.y = playerVelocity.y;\n      return true;\n    }\n\n    // Collision normal (from player to orb center)\n    const nx = dx / distance;\n    const ny = dy / distance;\n\n    // Tangent vector (perpendicular to normal)\n    const tx = -ny;\n    const ty = nx;\n\n    // Decompose player velocity into normal and tangent components\n    const vDotN = playerVelocity.x * nx + playerVelocity.y * ny;\n    const vDotT = playerVelocity.x * tx + playerVelocity.y * ty;\n\n    // Transfer momentum: orb moves away based on collision angle\n    // - Normal component pushes orb away from player\n    // - Tangent component pushes orb sideways (creates the \"nudge\" effect)\n    const restitution = 0.8; // Energy transfer factor\n    const friction = 0.6;    // Tangential transfer factor\n\n    this.velocity.x = (nx * vDotN * restitution + tx * vDotT * friction);\n    this.velocity.y = (ny * vDotN * restitution + ty * vDotT * friction);\n\n    return true;\n  }\n\n  getVelocity(): Vector2 {\n    return this.velocity;\n  }\n\n  updatePosition(dt: number, bounds: { width: number; height: number }): void {\n    if (!WeaponOrb.BOUNCED_WEAPONS.includes(this.weaponType)) return;\n\n    this.position.x += this.velocity.x * dt;\n    this.position.y += this.velocity.y * dt;\n\n    const minX = this.radius;\n    const maxX = bounds.width - this.radius;\n    const minY = this.radius;\n    const maxY = bounds.height - this.radius;\n\n    if (this.position.x <= minX) {\n      this.velocity.x = Math.abs(this.velocity.x);\n      this.position.x = minX;\n    } else if (this.position.x >= maxX) {\n      this.velocity.x = -Math.abs(this.velocity.x);\n      this.position.x = maxX;\n    }\n\n    if (this.position.y <= minY) {\n      this.velocity.y = Math.abs(this.velocity.y);\n      this.position.y = minY;\n    } else if (this.position.y >= maxY) {\n      this.velocity.y = -Math.abs(this.velocity.y);\n      this.position.y = maxY;\n    }\n  }\n}\n","import { WeaponOrb } from '../entities/WeaponOrb';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport { WEAPON_ORB_RADIUS } from '../utils/constants';\n\nexport class WeaponOrbSpawner {\n  private orbs: WeaponOrb[] = [];\n  private readonly orbCount: number = 3;\n  private readonly minSpacing: number = 100;\n  private readonly playerAvoidRadius: number = 150;\n\n  initialize(bounds: Bounds, playerPosition: Vector2): void {\n    this.orbs = [];\n    for (let i = 0; i < this.orbCount; i++) {\n      this.spawnOrb(bounds, playerPosition);\n    }\n  }\n\n  update(bounds: Bounds, playerPosition: Vector2): void {\n    while (this.orbs.length < this.orbCount) {\n      this.spawnOrb(bounds, playerPosition);\n    }\n  }\n\n  getOrbs(): WeaponOrb[] {\n    return this.orbs;\n  }\n\n  removeOrb(orb: WeaponOrb): void {\n    const index = this.orbs.indexOf(orb);\n    if (index > -1) {\n      this.orbs.splice(index, 1);\n    }\n  }\n\n  spawnOrb(bounds: Bounds, playerPosition: Vector2): void {\n    const pos = this.getRandomPosition(bounds, playerPosition);\n    const type = this.getRandomWeaponType();\n    this.orbs.push(new WeaponOrb(pos.x, pos.y, type));\n  }\n\n  private getRandomPosition(bounds: Bounds, playerPosition: Vector2): Vector2 {\n    let attempts = 0;\n    while (attempts < 100) {\n      const x = WEAPON_ORB_RADIUS + Math.random() * (bounds.width - WEAPON_ORB_RADIUS * 2);\n      const y = WEAPON_ORB_RADIUS + Math.random() * (bounds.height - WEAPON_ORB_RADIUS * 2);\n\n      const dx = x - playerPosition.x;\n      const dy = y - playerPosition.y;\n      const playerDist = Math.sqrt(dx * dx + dy * dy);\n\n      if (playerDist >= this.playerAvoidRadius && this.isPositionValid({ x, y })) {\n        return { x, y };\n      }\n      attempts++;\n    }\n    return { x: bounds.width / 2, y: bounds.height / 2 };\n  }\n\n  private isPositionValid(pos: Vector2): boolean {\n    for (const orb of this.orbs) {\n      const dx = pos.x - orb.position.x;\n      const dy = pos.y - orb.position.y;\n      if (Math.sqrt(dx * dx + dy * dy) < this.minSpacing) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private getRandomWeaponType(): WeaponType {\n    const types = [\n      WeaponType.KINETIC_BOMB,\n      WeaponType.BLASTER,\n      WeaponType.ICE_BOMB,\n      WeaponType.HOMING_MISSILE,\n      WeaponType.NUCLEAR_BOMB,\n      WeaponType.ELECTRIC_BOMB,\n      WeaponType.DOT_REPELLENT,\n      WeaponType.CHAINSAW,\n      WeaponType.FLAME_BURST\n    ];\n    return types[Math.floor(Math.random() * types.length)];\n  }\n}\n","import { WeaponType } from '../types';\nimport type { Weapon } from './Weapon';\n\ntype WeaponConstructor = new () => Weapon;\n\nclass WeaponRegistryImpl {\n  private weapons: Map<WeaponType, WeaponConstructor> = new Map();\n\n  register(type: WeaponType, weaponClass: WeaponConstructor): void {\n    this.weapons.set(type, weaponClass);\n  }\n\n  create(type: WeaponType): Weapon | null {\n    const WeaponClass = this.weapons.get(type);\n    if (!WeaponClass) return null;\n    return new WeaponClass();\n  }\n\n  getAvailableTypes(): WeaponType[] {\n    return Array.from(this.weapons.keys());\n  }\n}\n\nexport const WeaponRegistry = new WeaponRegistryImpl();\n","import { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds } from '../types';\nimport type { Player } from '../entities/Player';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport abstract class Weapon {\n  abstract readonly type: WeaponType;\n\n  protected dots: Dot[] = [];\n  protected startTime: number = 0;\n  protected isStarted: boolean = false;\n  protected killedDots: number = 0;\n\n  abstract activate(player: Player, dots: Dot[]): void;\n  abstract update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void;\n  abstract render(renderer: Renderer): void;\n\n  // Handle collision with player (for bounceable weapons like Electric/Nuclear bomb)\n  // Returns true if collision was handled/bounced\n  handlePlayerCollision(_player: Player, _playerVelocity: { x: number; y: number }): boolean {\n    return false;\n  }\n\n  // Check if weapon is currently active (for collision detection)\n  isActive(): boolean {\n    return false;\n  }\n\n  // Get weapon position (for collision detection)\n  getPosition(): { x: number; y: number } {\n    return { x: 0, y: 0 };\n  }\n\n  // Get weapon radius (for collision detection)\n  getRadius(): number {\n    return 0;\n  }\n\n  getDots(): Dot[] {\n    return this.dots.filter(d => !d.isDead());\n  }\n\n  isComplete(): boolean {\n    return false;\n  }\n\n  start(): void {\n    this.startTime = Date.now();\n    this.isStarted = true;\n  }\n\n  getElapsedTime(): number {\n    return Date.now() - this.startTime;\n  }\n\n  clear(): void {\n    for (const dot of this.dots) {\n      dot.kill();\n    }\n    this.dots = [];\n  }\n\n  getKilledDots(): number {\n    return this.killedDots;\n  }\n\n  addKilledDot(): void {\n    this.killedDots++;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { toastManager } from '../game/ToastManager';\nimport { WEAPON_ORB_RADIUS } from '../utils/constants';\n\nexport class NuclearBomb extends Weapon {\n  readonly type = WeaponType.NUCLEAR_BOMB;\n\n  private state: 'DRIFTING' | 'EXPLODING' | 'COMPLETE' = 'DRIFTING';\n  private orbPosition: Vector2 = { x: 0, y: 0 };\n  private orbVelocity: Vector2 = { x: 0, y: 0 };\n  private readonly fuseTime: number = 4000;\n  private collisionCount: number = 0;\n  private explosionRadius: number = 0;\n  private explosionStartTime: number = 0;\n  private killedDotsInExplosion: Set<Dot> = new Set();\n  private _hasKilledPlayer: boolean = false;\n  private bounds: Bounds | null = null;\n\n  private readonly flashInterval: number = 100;\n  private readonly flashGap: number = 400;\n  private lastCollisionTime: number = 0;\n  private readonly collisionCooldown: number = 100;\n  private readonly orbRadius: number = WEAPON_ORB_RADIUS;\n\n  activate(player: Player, _dots: Dot[]): void {\n    this.dots = _dots;\n    this.start();\n    this.orbPosition = { x: player.position.x, y: player.position.y };\n    this.orbVelocity = { x: 0, y: 0 };\n  }\n\n  handlePlayerCollision(player: Player, playerVelocity: Vector2): boolean {\n    const now = Date.now();\n    if (now - this.lastCollisionTime < this.collisionCooldown) {\n      return false;\n    }\n    this.lastCollisionTime = now;\n\n    const dx = this.orbPosition.x - player.position.x;\n    const dy = this.orbPosition.y - player.position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    const minSpeed = 50;\n    const playerSpeed = Math.sqrt(playerVelocity.x ** 2 + playerVelocity.y ** 2);\n\n    if (playerSpeed < minSpeed) {\n      return false;\n    }\n\n    if (distance === 0) {\n      this.orbVelocity.x = playerVelocity.x;\n      this.orbVelocity.y = playerVelocity.y;\n      return true;\n    }\n\n    const nx = dx / distance;\n    const ny = dy / distance;\n    const tx = -ny;\n    const ty = nx;\n\n    const vDotN = playerVelocity.x * nx + playerVelocity.y * ny;\n    const vDotT = playerVelocity.x * tx + playerVelocity.y * ty;\n\n    const directness = vDotN / playerSpeed;\n\n    if (directness < 0.1) {\n      return false;\n    }\n\n    const velocityMultiplier = 1.5;\n\n    if (directness > 0.7) {\n      this.orbVelocity.x = playerVelocity.x * velocityMultiplier;\n      this.orbVelocity.y = playerVelocity.y * velocityMultiplier;\n    } else {\n      const forwardFactor = directness;\n      const sidewaysFactor = 1 - directness;\n\n      this.orbVelocity.x = (nx * vDotN * forwardFactor + tx * vDotT * sidewaysFactor) * velocityMultiplier;\n      this.orbVelocity.y = (ny * vDotN * forwardFactor + ty * vDotT * sidewaysFactor) * velocityMultiplier;\n    }\n\n    return true;\n  }\n\n  getPosition(): Vector2 {\n    return this.orbPosition;\n  }\n\n  getRadius(): number {\n    return this.orbRadius;\n  }\n\n  isActive(): boolean {\n    return this.state !== 'COMPLETE';\n  }\n\n  update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    this.bounds = bounds;\n\n    switch (this.state) {\n      case 'DRIFTING': {\n        const elapsedTime = this.getElapsedTime();\n\n        this.orbPosition.x += this.orbVelocity.x * dt;\n        this.orbPosition.y += this.orbVelocity.y * dt;\n\n        const minX = this.orbRadius;\n        const maxX = bounds.width - this.orbRadius;\n        const minY = this.orbRadius;\n        const maxY = bounds.height - this.orbRadius;\n\n        if (this.orbPosition.x <= minX) {\n          this.orbVelocity.x = Math.abs(this.orbVelocity.x);\n          this.orbPosition.x = minX;\n          this.collisionCount++;\n        } else if (this.orbPosition.x >= maxX) {\n          this.orbVelocity.x = -Math.abs(this.orbVelocity.x);\n          this.orbPosition.x = maxX;\n          this.collisionCount++;\n        }\n\n        if (this.orbPosition.y <= minY) {\n          this.orbVelocity.y = Math.abs(this.orbVelocity.y);\n          this.orbPosition.y = minY;\n          this.collisionCount++;\n        } else if (this.orbPosition.y >= maxY) {\n          this.orbVelocity.y = -Math.abs(this.orbVelocity.y);\n          this.orbPosition.y = maxY;\n          this.collisionCount++;\n        }\n\n        if (elapsedTime >= this.fuseTime || this.collisionCount >= 3) {\n          this.state = 'EXPLODING';\n          this.explosionStartTime = Date.now();\n          this.explosionRadius = 0.35 * bounds.width;\n          toastManager.show('Nuclear Bomb detonated!', 'warning');\n          this.killDotsInExplosion(dots);\n          this.checkAndKillPlayer(player);\n        }\n        break;\n      }\n      case 'EXPLODING': {\n        const explosionElapsed = Date.now() - this.explosionStartTime;\n        if (explosionElapsed > 500) {\n          this.state = 'COMPLETE';\n        }\n        break;\n      }\n      case 'COMPLETE': {\n        break;\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (!this.bounds) return;\n\n    switch (this.state) {\n      case 'DRIFTING': {\n        const elapsedTime = this.getElapsedTime();\n        const progress = Math.min(elapsedTime / this.fuseTime, 1);\n        const color = this.interpolateColor('#FF6600', '#FF0000', progress);\n\n        const warningExplosionRadius = 0.35 * this.bounds.width;\n\n        const ctx = renderer.getContext();\n\n        const warningStartTime = this.fuseTime - 1500;\n        if (elapsedTime >= warningStartTime) {\n          const warningElapsed = elapsedTime - warningStartTime;\n          const flash1Start = 0;\n          const flash2Start = this.flashInterval + this.flashGap;\n\n          let shouldShowFlash = false;\n\n          if (warningElapsed >= flash1Start && warningElapsed < flash1Start + this.flashInterval) {\n            shouldShowFlash = true;\n          } else if (warningElapsed >= flash2Start && warningElapsed < flash2Start + this.flashInterval) {\n            shouldShowFlash = true;\n          }\n\n          if (shouldShowFlash) {\n            ctx.fillStyle = 'rgba(255, 165, 0, 0.6)';\n            ctx.beginPath();\n            ctx.arc(this.orbPosition.x, this.orbPosition.y, warningExplosionRadius, 0, Math.PI * 2);\n            ctx.fill();\n          }\n        }\n\n        renderer.drawCircleImmediate(\n          this.orbPosition.x,\n          this.orbPosition.y,\n          this.orbRadius,\n          color\n        );\n\n        ctx.strokeStyle = '#9B30FF';\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.arc(this.orbPosition.x, this.orbPosition.y, this.orbRadius + 2, 0, Math.PI * 2);\n        ctx.stroke();\n\n        this.drawNuclearIcon(ctx, this.orbPosition.x, this.orbPosition.y, this.orbRadius * 0.5);\n        break;\n      }\n      case 'EXPLODING': {\n        const explosionElapsed = Date.now() - this.explosionStartTime;\n        if (explosionElapsed <= 500) {\n          const alpha = 0.8 - (explosionElapsed / 500) * 0.8;\n          renderer.drawCircle(\n            this.orbPosition.x,\n            this.orbPosition.y,\n            this.explosionRadius,\n            `rgba(255, 0, 0, ${alpha})`\n          );\n        }\n        break;\n      }\n      case 'COMPLETE': {\n        break;\n      }\n    }\n  }\n\n  private interpolateColor(color1: string, color2: string, factor: number): string {\n    const r1 = parseInt(color1.slice(1, 3), 16);\n    const g1 = parseInt(color1.slice(3, 5), 16);\n    const b1 = parseInt(color1.slice(5, 7), 16);\n\n    const r2 = parseInt(color2.slice(1, 3), 16);\n    const g2 = parseInt(color2.slice(3, 5), 16);\n    const b2 = parseInt(color2.slice(5, 7), 16);\n\n    const r = Math.round(r1 + (r2 - r1) * factor);\n    const g = Math.round(g1 + (g2 - g1) * factor);\n    const b = Math.round(b1 + (b2 - b1) * factor);\n\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n  }\n\n  private drawNuclearIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.fillStyle = '#FFFFFF';\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n\n    const skullScale = scale * 0.7;\n\n    ctx.beginPath();\n    ctx.arc(x, y - skullScale * 0.1, skullScale * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.arc(x - skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(x + skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.moveTo(x, y + skullScale * 0.05);\n    ctx.lineTo(x - skullScale * 0.08, y + skullScale * 0.2);\n    ctx.lineTo(x + skullScale * 0.08, y + skullScale * 0.2);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.fillStyle = '#FFFFFF';\n    ctx.beginPath();\n    ctx.rect(x - skullScale * 0.25, y + skullScale * 0.25, skullScale * 0.5, skullScale * 0.2);\n    ctx.fill();\n\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 1.5;\n    for (let i = 1; i <= 2; i++) {\n      const teethX = x - skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX, y + skullScale * 0.25);\n      ctx.lineTo(teethX, y + skullScale * 0.45);\n      ctx.stroke();\n\n      const teethX2 = x + skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX2, y + skullScale * 0.25);\n      ctx.lineTo(teethX2, y + skullScale * 0.45);\n      ctx.stroke();\n    }\n\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 3;\n    ctx.lineCap = 'round';\n\n    ctx.beginPath();\n    ctx.moveTo(x - skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x + skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(x + skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x - skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    ctx.fillStyle = '#FFFFFF';\n    const boneEndRadius = skullScale * 0.1;\n    const boneEnds = [\n      { x: x - skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y + skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x - skullScale * 0.7, y: y + skullScale * 0.5 }\n    ];\n\n    for (const end of boneEnds) {\n      ctx.beginPath();\n      ctx.arc(end.x, end.y, boneEndRadius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  hasKilledPlayer(): boolean {\n    return this._hasKilledPlayer;\n  }\n\n  private killDotsInExplosion(dots: Dot[]): void {\n    for (const dot of dots) {\n      if (dot.isDead() || this.killedDotsInExplosion.has(dot)) continue;\n\n      const pos = dot.getPosition();\n      const dx = pos.x - this.orbPosition.x;\n      const dy = pos.y - this.orbPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.explosionRadius) {\n        dot.kill();\n        this.addKilledDot();\n        this.killedDotsInExplosion.add(dot);\n      }\n    }\n  }\n\n  private checkAndKillPlayer(player: Player): void {\n    if (this._hasKilledPlayer) return;\n\n    const dx = player.position.x - this.orbPosition.x;\n    const dy = player.position.y - this.orbPosition.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance <= this.explosionRadius) {\n      this._hasKilledPlayer = true;\n    }\n  }\n}\n","import { HighscoreEntry } from '../types';\n\nconst STORAGE_KEY = 'tilt-to-live-highscores';\nconst MAX_HIGHSCORES = 10;\n\n/**\n * Get all highscores from localStorage\n * Returns empty array if none exist\n */\nexport function getHighscores(): HighscoreEntry[] {\n  try {\n    const data = localStorage.getItem(STORAGE_KEY);\n    if (!data) return [];\n\n    const scores = JSON.parse(data) as HighscoreEntry[];\n    // Ensure sorted descending by score\n    return scores.sort((a, b) => b.score - a.score);\n  } catch (error) {\n    console.error('Failed to load highscores:', error);\n    return [];\n  }\n}\n\n/**\n * Add a new highscore\n * Maintains top 10, sorted descending\n * Returns the rank (1-based) or -1 if not in top 10\n */\nexport function addHighscore(score: number): number {\n  const highscores = getHighscores();\n\n  const newEntry: HighscoreEntry = {\n    score,\n    timestamp: Date.now()\n  };\n\n  // Add new score\n  highscores.push(newEntry);\n\n  // Sort descending by score\n  highscores.sort((a, b) => b.score - a.score);\n\n  // Keep only top 10\n  const trimmed = highscores.slice(0, MAX_HIGHSCORES);\n\n  // Find rank of new score\n  const rank = trimmed.findIndex(e => e.timestamp === newEntry.timestamp && e.score === score) + 1;\n\n  // Save to localStorage\n  try {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmed));\n  } catch (error) {\n    console.error('Failed to save highscores:', error);\n  }\n\n  return rank > 0 ? rank : -1;\n}\n\n/**\n * Check if a score would make the top 10\n */\nexport function isHighscore(score: number): boolean {\n  const highscores = getHighscores();\n\n  // If we have less than 10, any score qualifies\n  if (highscores.length < MAX_HIGHSCORES) return true;\n\n  // Check if score beats the lowest\n  return score > highscores[highscores.length - 1].score;\n}\n\n/**\n * Clear all highscores\n * Use for testing/reset\n */\nexport function clearHighscores(): void {\n  try {\n    localStorage.removeItem(STORAGE_KEY);\n  } catch (error) {\n    console.error('Failed to clear highscores:', error);\n  }\n}\n\n/**\n * Format highscore list for display\n * Returns array of formatted strings\n */\nexport function formatHighscores(entries: HighscoreEntry[]): string[] {\n  return entries.map((entry) => {\n    const date = new Date(entry.timestamp);\n    const dateStr = date.toLocaleDateString();\n    return `${entry.score} pts - ${dateStr}`;\n  });\n}\n\n/**\n * Get the highest score (for display purposes)\n */\nexport function getTopScore(): number {\n  const scores = getHighscores();\n  return scores.length > 0 ? scores[0].score : 0;\n}\n","import { GameState, Bounds, type DeathEvent } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { InputManager } from './InputManager';\nimport { Player } from '../entities/Player';\nimport { ScoringSystem } from './ScoringSystem';\nimport { CollisionSystem } from './CollisionSystem';\nimport { DifficultyManager } from './DifficultyManager';\nimport { PatternManager } from './PatternManager';\nimport { WeaponOrbSpawner } from './WeaponOrbSpawner';\nimport { WeaponRegistry } from '../weapons/WeaponRegistry';\nimport type { Weapon } from '../weapons/Weapon';\nimport { NuclearBomb } from '../weapons/NuclearBomb';\nimport { COLOR_BACKGROUND, FRAME_TIME } from '../utils/constants';\nimport { getHighscores } from '../utils/storage';\nimport { toastManager } from './ToastManager';\n\nexport class Game {\n  private renderer: Renderer;\n  private input: InputManager;\n  private state: GameState = GameState.MENU;\n  private lastFrameTime: number = 0;\n  private isPaused: boolean = false;\n  private accumulator: number = 0;\n\n  private player: Player | null = null;\n\n  private bounds: Bounds;\n  private timeAlive: number = 0;\n\n  private scoringSystem: ScoringSystem = new ScoringSystem();\n  private collisionSystem: CollisionSystem;\n  private difficultyManager: DifficultyManager = new DifficultyManager();\n  private patternManager: PatternManager = new PatternManager();\n  private orbSpawner: WeaponOrbSpawner = new WeaponOrbSpawner();\n  private activeWeapons: Weapon[] = [];\n  private lastDeathEvent: DeathEvent | null = null;\n  \n  private menuElement: HTMLElement;\n  private gameOverElement: HTMLElement;\n  private permissionElement: HTMLElement;\n  private newGameBtn: HTMLElement;\n  private playAgainBtn: HTMLElement;\n  private enableMotionBtn: HTMLElement;\n  private finalScoreElement: HTMLElement;\n  \n  constructor() {\n    this.renderer = new Renderer('game');\n    this.input = new InputManager();\n    this.bounds = this.renderer.getBounds();\n    this.collisionSystem = new CollisionSystem(this.bounds);\n    \n    this.menuElement = document.getElementById('menu')!;\n    this.gameOverElement = document.getElementById('game-over')!;\n    this.permissionElement = document.getElementById('permission-prompt')!;\n    this.newGameBtn = document.getElementById('new-game-btn')!;\n    this.playAgainBtn = document.getElementById('play-again-btn')!;\n    this.enableMotionBtn = document.getElementById('enable-motion-btn')!;\n    this.finalScoreElement = document.getElementById('final-score')!;\n    \n    this.setupEventListeners();\n    this.checkPlatform();\n    this.gameLoop(0);\n  }\n  \n  private checkPlatform(): void {\n    const isDesktop = !('ontouchstart' in window) && \n                      !('DeviceOrientationEvent' in window);\n    if (isDesktop) {\n      this.showElement('desktop-warning', true);\n      return;\n    }\n    this.checkOrientation();\n    window.addEventListener('orientationchange', () => this.checkOrientation());\n    window.addEventListener('resize', () => this.checkOrientation());\n  }\n  \n  private checkOrientation(): void {\n    const isLandscape = window.innerWidth > window.innerHeight;\n    this.showElement('landscape-warning', isLandscape && this.state === GameState.PLAYING);\n  }\n  \n  private showElement(id: string, show: boolean): void {\n    const el = document.getElementById(id);\n    if (el) el.style.display = show ? 'flex' : 'none';\n  }\n  \n  private setupEventListeners(): void {\n    this.newGameBtn.addEventListener('click', () => this.handleNewGameClick());\n    this.playAgainBtn.addEventListener('click', () => this.handleNewGameClick());\n    this.enableMotionBtn.addEventListener('click', () => this.requestMotionPermission());\n    \n    window.addEventListener('resize', () => {\n      this.bounds = this.renderer.getBounds();\n    });\n    \n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden && this.state === GameState.PLAYING) {\n        this.pause();\n      } else if (!document.hidden && this.state === GameState.PAUSED) {\n        this.resume();\n      }\n    });\n  }\n  \n  private async handleNewGameClick(): Promise<void> {\n    if (this.input.needsPermissionRequest()) {\n      this.menuElement.classList.add('hidden');\n      this.permissionElement.style.display = 'flex';\n      return;\n    }\n    \n    this.startGame();\n  }\n  \n  private async requestMotionPermission(): Promise<void> {\n    const granted = await this.input.requestPermission();\n    \n    if (granted) {\n      this.permissionElement.style.display = 'none';\n      this.startGame();\n    } else {\n      alert('Motion permission denied. The game requires device motion to play.');\n    }\n  }\n  \n  startGame(): void {\n    this.state = GameState.PLAYING;\n    this.timeAlive = 0;\n    this.lastDeathEvent = null;\n\n    this.scoringSystem.start();\n\n    this.collisionSystem.updateBounds(this.bounds);\n\n    const centerX = this.bounds.width / 2;\n    const centerY = this.bounds.height / 2;\n    this.player = new Player(centerX, centerY);\n\n    this.patternManager.clear();\n    this.orbSpawner.initialize(this.bounds, this.player.getPosition());\n    this.activeWeapons = [];\n\n    this.input.calibrateTiltBasis();\n\n    this.menuElement.classList.add('hidden');\n    this.gameOverElement.classList.add('hidden');\n    \n    toastManager.clear();\n  }\n  \n  private handleGameOver(): void {\n    const finalScore = this.scoringSystem.getScore();\n    this.state = GameState.GAME_OVER;\n\n    this.finalScoreElement.textContent = `Score: ${finalScore}`;\n\n    const highscoreList = document.getElementById('gameover-highscores');\n    if (highscoreList) {\n      const highscores = getHighscores();\n      highscoreList.innerHTML = highscores\n        .slice(0, 10)\n        .map((h, i) => `<li>${i + 1}. ${h.score}</li>`)\n        .join('');\n    }\n\n    const deathReasonElement = document.getElementById('death-reason');\n    if (deathReasonElement) {\n      deathReasonElement.textContent = this.lastDeathEvent?.message ?? 'Unknown';\n    }\n\n    const recentToastsList = document.getElementById('recent-toasts');\n    if (recentToastsList) {\n      const allMessages = toastManager.getAllMessages();\n      recentToastsList.innerHTML = allMessages.length > 0\n        ? allMessages.map(msg => `<li class=\"toast-${msg.type}\">${msg.text}</li>`).join('')\n        : '<li class=\"toast-info\">No recent events</li>';\n    }\n\n    this.gameOverElement.classList.remove('hidden');\n  }\n\n  pause(): void {\n    this.isPaused = true;\n  }\n\n  resume(): void {\n    this.isPaused = false;\n    this.lastFrameTime = performance.now();\n  }\n\n  private gameLoop = (currentTime: number): void => {\n    if (this.state !== GameState.PLAYING || this.isPaused) {\n      requestAnimationFrame(this.gameLoop);\n      return;\n    }\n    const deltaTime = currentTime - this.lastFrameTime;\n    this.lastFrameTime = currentTime;\n\n    this.accumulator += deltaTime;\n\n    while (this.accumulator >= FRAME_TIME) {\n      this.update(FRAME_TIME / 1000);\n      this.accumulator -= FRAME_TIME;\n    }\n\n    this.render();\n    requestAnimationFrame(this.gameLoop);\n  };\n  \n  private update(dt: number): void {\n    if (!this.player) return;\n\n    this.timeAlive += dt;\n\n    const velocity = this.input.getVelocity();\n    this.player.update(dt, velocity, this.bounds);\n\n    const score = this.scoringSystem.getScore();\n    this.difficultyManager.update(score);\n    this.patternManager.setScore(score);\n\n    this.patternManager.update(dt, this.player.getPosition(), this.bounds);\n\n    this.orbSpawner.update(this.bounds, this.player.getPosition());\n\n    const allDots = this.patternManager.getAllDots();\n    this.collisionSystem.rebuildGrid(allDots);\n\n    const orbs = this.orbSpawner.getOrbs();\n\n    // Update bounced weapon orb positions\n    for (const orb of orbs) {\n      orb.updatePosition(dt, this.bounds);\n    }\n\n    const collidingOrb = this.collisionSystem.checkPlayerOrbCollision(this.player, orbs);\n    if (collidingOrb) {\n      // Try to bounce bounced weapons first\n      const playerVelocity = this.input.getVelocity();\n      const bounced = collidingOrb.bounce(playerVelocity, this.player.getPosition());\n\n      if (!bounced) {\n        // Not a bounced weapon or bounce failed - pick it up\n        const weaponType = collidingOrb.getWeaponType();\n        const weapon = WeaponRegistry.create(weaponType);\n        if (weapon) {\n          weapon.activate(this.player, allDots);\n          this.activeWeapons.push(weapon);\n          collidingOrb.pickup();\n          this.orbSpawner.removeOrb(collidingOrb);\n          toastManager.show(`Picked up ${this.formatWeaponName(weaponType)}`, 'success');\n        }\n      }\n    }\n\n    for (let i = this.activeWeapons.length - 1; i >= 0; i--) {\n      const weapon = this.activeWeapons[i];\n      weapon.update(dt, this.player, allDots, this.bounds);\n      \n      // Check for player collision with active weapon (for bounceable weapons like Electric/Nuclear bomb)\n      if (weapon.isActive()) {\n        const playerPos = this.player.getPosition();\n        const weaponPos = weapon.getPosition();\n        const weaponRadius = weapon.getRadius();\n        const playerRadius = this.player.hitboxRadius;\n        \n        const dx = weaponPos.x - playerPos.x;\n        const dy = weaponPos.y - playerPos.y;\n        const distSq = dx * dx + dy * dy;\n        const radiiSum = weaponRadius + playerRadius;\n        \n        if (distSq < radiiSum * radiiSum) {\n          const playerVelocity = this.input.getVelocity();\n          weapon.handlePlayerCollision(this.player, playerVelocity);\n        }\n      }\n      \n      if (weapon instanceof NuclearBomb && weapon.hasKilledPlayer()) {\n        this.lastDeathEvent = {\n          message: 'Killed by Nuclear Bomb explosion',\n          type: 'nuclear_bomb',\n          timestamp: Date.now()\n        };\n        this.handleGameOver();\n        return;\n      }\n      \n      if (weapon.isComplete()) {\n        this.scoringSystem.addKills(weapon.getKilledDots());\n        this.activeWeapons.splice(i, 1);\n      }\n    }\n\n    const collidingDot = this.collisionSystem.checkPlayerDotCollision(this.player);\n    if (collidingDot) {\n      if (collidingDot.isLethal()) {\n        this.lastDeathEvent = {\n          message: 'Hit by a red dot',\n          type: 'dot',\n          timestamp: Date.now()\n        };\n        this.handleGameOver();\n      } else if (collidingDot.isFrozen()) {\n        collidingDot.kill();\n        this.scoringSystem.addKills(1);\n      }\n    }\n  }\n  \n  private render(): void {\n    this.renderer.clear(COLOR_BACKGROUND);\n\n    const orbs = this.orbSpawner.getOrbs();\n    for (let i = 0; i < orbs.length; i++) {\n      orbs[i].render(this.renderer);\n    }\n\n    const allDots = this.patternManager.getAllDots();\n    for (let i = 0; i < allDots.length; i++) {\n      allDots[i].render(this.renderer);\n    }\n\n    for (let i = 0; i < this.activeWeapons.length; i++) {\n      this.activeWeapons[i].render(this.renderer);\n    }\n\n    if (this.player) {\n      this.player.render(this.renderer);\n    }\n\n    this.renderer.flushBatches();\n    this.renderer.endFrame();\n  }\n  \n  getState(): GameState {\n    return this.state;\n  }\n  \n  getScore(): number {\n    return this.scoringSystem.getScore();\n  }\n\n  private formatWeaponName(type: string): string {\n    return type\n      .toLowerCase()\n      .split('_')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n}\n","import { Vector2, Bounds, DotState } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { Vec2, wrapInPlace } from '../utils/math';\nimport { DOT_RADIUS, DOT_SPAWN_ANIMATION_DURATION, DOT_SPAWN_SCALE_MAX, COLOR_DOT, COLOR_DOT_SPAWNING, COLOR_DOT_FROZEN } from '../utils/constants';\n\nconst FROZEN_BORDER_MAX_THICKNESS = 8;\nconst FROZEN_BORDER_COLOR = '#00CCFF';\n\nconst SPAWN_INV_DURATION = 1 / DOT_SPAWN_ANIMATION_DURATION;\nconst SCALE_RANGE = DOT_SPAWN_SCALE_MAX - 1;\n\nexport class Dot {\n  position: Vec2;\n  velocity: Vector2;\n  state: DotState;\n  patternId: string | null = null;\n  \n  private spawnElapsed: number = 0;\n  private currentScale: number = DOT_SPAWN_SCALE_MAX;\n  readonly radius: number = DOT_RADIUS;\n  \n  // Frozen/thaw properties\n  private frozenTime: number = 0;\n  private readonly thawDuration: number = 3000; // 3 seconds\n  private readonly preThawWarningTime: number = 500; // Start vibrating 500ms before thaw\n  private isZombie: boolean = false;\n  private readonly zombieSpeed: number = 50;\n  private vibrationOffset: Vector2 = { x: 0, y: 0 };\n  private frozenBorderThickness: number = FROZEN_BORDER_MAX_THICKNESS;\n\n  constructor(x: number, y: number, patternId: string | null = null) {\n    this.position = new Vec2(x, y);\n    this.velocity = { x: 0, y: 0 };\n    this.state = DotState.SPAWNING;\n    this.patternId = patternId;\n  }\n\n  update(dt: number, bounds: Bounds, playerPosition?: Vector2): void {\n    if (this.state === DotState.SPAWNING) {\n      this.spawnElapsed += dt * 1000;\n      const progress = this.spawnElapsed * SPAWN_INV_DURATION;\n      \n      if (progress >= 1) {\n        this.state = DotState.ACTIVE;\n        this.currentScale = 1;\n      } else {\n        this.currentScale = DOT_SPAWN_SCALE_MAX - SCALE_RANGE * progress;\n      }\n      return;\n    }\n    \n    if (this.state === DotState.FROZEN) {\n      this.frozenTime += dt * 1000;\n\n      const frozenProgress = Math.min(this.frozenTime / this.thawDuration, 1);\n      this.frozenBorderThickness = FROZEN_BORDER_MAX_THICKNESS * (1 - frozenProgress);\n\n      const timeUntilThaw = this.thawDuration - this.frozenTime;\n      if (timeUntilThaw <= this.preThawWarningTime && timeUntilThaw > 0) {\n        const shakeIntensity = 2 * (1 - timeUntilThaw / this.preThawWarningTime);\n        this.vibrationOffset.x = (Math.random() - 0.5) * shakeIntensity;\n        this.vibrationOffset.y = (Math.random() - 0.5) * shakeIntensity;\n      } else {\n        this.vibrationOffset.x = 0;\n        this.vibrationOffset.y = 0;\n      }\n\n      if (this.frozenTime >= this.thawDuration) {\n        this.thaw(playerPosition);\n      }\n      return;\n    }\n    \n    if (this.state !== DotState.ACTIVE) {\n      return;\n    }\n    \n    // If this is a zombie dot (thawed from frozen), chase the player\n    if (this.isZombie && playerPosition) {\n      const dx = playerPosition.x - this.position.x;\n      const dy = playerPosition.y - this.position.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      \n      if (dist > 0) {\n        this.velocity.x = (dx / dist) * this.zombieSpeed;\n        this.velocity.y = (dy / dist) * this.zombieSpeed;\n      }\n    }\n    \n    this.position.x += this.velocity.x * dt;\n    this.position.y += this.velocity.y * dt;\n    \n    wrapInPlace(this.position, bounds);\n  }\n\n  render(renderer: Renderer): void {\n    const currentRadius = this.radius * this.currentScale;\n\n    let color: string;\n    switch (this.state) {\n      case DotState.SPAWNING:\n        color = COLOR_DOT_SPAWNING;\n        break;\n      case DotState.FROZEN:\n        color = COLOR_DOT_FROZEN;\n        break;\n      default:\n        color = COLOR_DOT;\n    }\n\n    const renderX = this.position.x + this.vibrationOffset.x;\n    const renderY = this.position.y + this.vibrationOffset.y;\n\n    renderer.drawCircle(\n      renderX,\n      renderY,\n      currentRadius,\n      color\n    );\n    \n    if (this.state === DotState.SPAWNING) {\n      const alpha = 1 - this.currentScale / DOT_SPAWN_SCALE_MAX;\n      renderer.drawCircleOutline(\n        renderX,\n        renderY,\n        currentRadius * 1.5,\n        `rgba(255,102,102,${alpha.toFixed(2)})`\n      );\n    }\n\n    if (this.state === DotState.FROZEN) {\n      // Draw light blue border as an outline that shrinks as they thaw\n      renderer.drawCircleOutline(\n        renderX,\n        renderY,\n        currentRadius + this.frozenBorderThickness,\n        FROZEN_BORDER_COLOR\n      );\n      renderer.drawCircle(\n        renderX,\n        renderY,\n        currentRadius,\n        color\n      );\n    }\n  }\n\n  isLethal(): boolean {\n    return this.state === DotState.ACTIVE;\n  }\n\n  isFrozen(): boolean {\n    return this.state === DotState.FROZEN;\n  }\n\n  freeze(): void {\n    if (this.state === DotState.ACTIVE) {\n      this.state = DotState.FROZEN;\n      this.velocity.x = 0;\n      this.velocity.y = 0;\n      this.frozenTime = 0;\n      this.frozenBorderThickness = FROZEN_BORDER_MAX_THICKNESS;\n    }\n  }\n\n  thaw(playerPosition?: Vector2): void {\n    if (this.state === DotState.FROZEN) {\n      this.state = DotState.ACTIVE;\n      this.isZombie = true;\n      this.vibrationOffset.x = 0;\n      this.vibrationOffset.y = 0;\n      if (playerPosition) {\n        const dx = playerPosition.x - this.position.x;\n        const dy = playerPosition.y - this.position.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist > 0) {\n          this.velocity.x = (dx / dist) * this.zombieSpeed;\n          this.velocity.y = (dy / dist) * this.zombieSpeed;\n        }\n      }\n    }\n  }\n\n  kill(): void {\n    this.state = DotState.DEAD;\n  }\n\n  isDead(): boolean {\n    return this.state === DotState.DEAD;\n  }\n\n  getPosition(): Vector2 {\n    return this.position;\n  }\n\n  getRadius(): number {\n    return this.radius;\n  }\n\n  getEffectiveRadius(): number {\n    if (this.state === DotState.FROZEN) {\n      return this.radius + this.frozenBorderThickness;\n    }\n    return this.radius;\n  }\n}\n","import { Dot } from '../entities/Dot';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { Renderer } from '../renderer/Renderer';\n\nexport abstract class Pattern {\n  abstract readonly type: PatternType;\n  abstract readonly difficulty: Difficulty;\n\n  protected dots: Dot[] = [];\n  protected elapsedMs: number = 0;\n  protected isStarted: boolean = false;\n\n  abstract spawn(center: Vector2, bounds: Bounds): void;\n  abstract update(dt: number, playerPosition: Vector2, bounds: Bounds): void;\n\n  /**\n   * Centralized dot spawning method.\n   * Creates a dot with a spawn animation and optional initial velocity.\n   * The dot will be non-lethal during the spawn animation (500ms),\n   * then become active with the provided velocity.\n   *\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param velocity - Initial velocity (applied once spawn completes)\n   * @returns The created Dot instance\n   */\n  protected spawnDot(x: number, y: number, velocity: Vector2 = { x: 0, y: 0 }): Dot {\n    const dot = new Dot(x, y, this.type);\n    dot.velocity.x = velocity.x;\n    dot.velocity.y = velocity.y;\n    this.dots.push(dot);\n    return dot;\n  }\n\n  getDots(): Dot[] {\n    return this.dots.filter(d => !d.isDead());\n  }\n\n  isComplete(): boolean {\n    return false;\n  }\n\n  start(): void {\n    this.elapsedMs = 0;\n    this.isStarted = true;\n  }\n\n  getElapsedTime(): number {\n    return this.elapsedMs;\n  }\n\n  tick(dt: number): void {\n    this.elapsedMs += dt * 1000;\n  }\n\n  render(_renderer: Renderer): void {\n    // Override in subclasses to render pattern-specific visuals (e.g., warning indicators)\n  }\n\n  clear(): void {\n    for (let i = 0; i < this.dots.length; i++) {\n      this.dots[i].kill();\n    }\n    this.dots = [];\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { randomPosition } from '../utils/math';\nimport { DOT_RADIUS } from '../utils/constants';\n\nexport class ZombieSnow extends Pattern {\n  readonly type = PatternType.ZOMBIE_SNOW;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private spawnInterval: number;\n  private elapsedSinceSpawn: number = 0;\n  private readonly duration: number = 15000;\n  private readonly dotSpeed: number = 50;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.spawnInterval = 150;\n        break;\n      case Difficulty.MEDIUM:\n        this.spawnInterval = 300;\n        break;\n      default:\n        this.spawnInterval = 500;\n    }\n  }\n\n  spawn(_center: Vector2, _bounds: Bounds): void {\n    this.start();\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.elapsedMs <= this.duration) {\n      this.elapsedSinceSpawn += dt * 1000;\n      if (this.elapsedSinceSpawn >= this.spawnInterval) {\n        this.elapsedSinceSpawn = 0;\n        this.spawnDotAtRandomPosition(bounds);\n      }\n    }\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const dx = playerPosition.x - pos.x;\n      const dy = playerPosition.y - pos.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 0) {\n        dot.velocity.x = (dx / dist) * this.dotSpeed;\n        dot.velocity.y = (dy / dist) * this.dotSpeed;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnDotAtRandomPosition(bounds: Bounds): void {\n    const margin = DOT_RADIUS * 2;\n    const pos = randomPosition(bounds, margin);\n    this.spawnDot(pos.x, pos.y);\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\nexport class SweeperLine extends Pattern {\n  readonly type = PatternType.SWEEPER_LINE;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private readonly duration: number = 20000;\n  private readonly dotSpacing: number = 20;\n  private readonly holeSize: number = 40; // Size of each hole in pixels\n\n  private isHorizontal: boolean = true;\n  private lineVelocity: number = 0;\n  private sweepSpeed: number = 150;\n  // For horizontal line: this is the Y position (sweeps up/down), offset is X\n  // For vertical line: this is the X position (sweeps left/right), offset is Y\n  private linePos: number = 0;\n  private lineOffset: number = 0;\n  private dotOffsets: number[] = []; // Fixed offsets for each dot along the line\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.sweepSpeed = 220;\n        break;\n      case Difficulty.MEDIUM:\n        this.sweepSpeed = 180;\n        break;\n      default:\n        this.sweepSpeed = 140;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n\n    // Randomly choose horizontal or vertical orientation\n    this.isHorizontal = Math.random() > 0.5;\n\n    // Random offset position for the line (where it sits on the perpendicular axis)\n    if (this.isHorizontal) {\n      // Horizontal line at random X position, sweeps up/down\n      this.lineOffset = Math.random() * (bounds.width - 200) + 100;\n    } else {\n      // Vertical line at random Y position, sweeps left/right\n      this.lineOffset = Math.random() * (bounds.height - 200) + 100;\n    }\n\n    // Start at one edge and sweep toward the other\n    if (this.isHorizontal) {\n      // Start at top or bottom\n      this.lineVelocity = Math.random() > 0.5 ? this.sweepSpeed : -this.sweepSpeed;\n      this.linePos = this.lineVelocity > 0 ? -50 : bounds.height + 50;\n    } else {\n      // Start at left or right\n      this.lineVelocity = Math.random() > 0.5 ? this.sweepSpeed : -this.sweepSpeed;\n      this.linePos = this.lineVelocity > 0 ? -50 : bounds.width + 50;\n    }\n\n    // Generate the line with holes\n    this.generateLineWithHoles(bounds);\n  }\n\n  private generateLineWithHoles(bounds: Bounds): void {\n    const numHoles = Math.floor(Math.random() * 2) + 2; // 2-3 holes\n    const lineLength = this.isHorizontal ? bounds.height : bounds.width;\n    const numDots = Math.floor((lineLength - 100) / this.dotSpacing);\n\n    // Generate hole positions (indices where dots should NOT spawn)\n    const holeSet = new Set<number>();\n    const holeWidthDots = Math.ceil(this.holeSize / this.dotSpacing);\n\n    for (let h = 0; h < numHoles; h++) {\n      // Random position along the line, avoiding edges\n      const holeCenter = Math.floor(Math.random() * (numDots - 10)) + 5;\n      for (let i = -Math.floor(holeWidthDots / 2); i <= Math.floor(holeWidthDots / 2); i++) {\n        holeSet.add(holeCenter + i);\n      }\n    }\n\n    // Spawn dots at fixed offsets along the line\n    const startOffset = (lineLength - (numDots * this.dotSpacing)) / 2;\n\n    for (let i = 0; i < numDots; i++) {\n      if (!holeSet.has(i)) {\n        const offset = startOffset + (i * this.dotSpacing);\n        this.dotOffsets.push(offset);\n\n        // Spawn dot - it will be positioned correctly in the first update\n        if (this.isHorizontal) {\n          // Horizontal line: dots vary in X (offset), same Y (sweeps)\n          this.spawnDot(this.lineOffset + offset - (lineLength / 2), this.linePos, { x: 0, y: 0 });\n        } else {\n          // Vertical line: dots vary in Y (offset), same X (sweeps)\n          this.spawnDot(this.linePos, this.lineOffset + offset - (lineLength / 2), { x: 0, y: 0 });\n        }\n      }\n    }\n  }\n\n  update(dt: number, _playerPosition: Vector2, bounds: Bounds): void {\n    // Move the line\n    this.linePos += this.lineVelocity * dt;\n\n    // Reverse direction when we go off-screen (sweep back and forth forever)\n    if (this.isHorizontal) {\n      if (this.lineVelocity > 0 && this.linePos > bounds.height + 50) {\n        this.lineVelocity = -this.sweepSpeed;\n      } else if (this.lineVelocity < 0 && this.linePos < -50) {\n        this.lineVelocity = this.sweepSpeed;\n      }\n    } else {\n      if (this.lineVelocity > 0 && this.linePos > bounds.width + 50) {\n        this.lineVelocity = -this.sweepSpeed;\n      } else if (this.lineVelocity < 0 && this.linePos < -50) {\n        this.lineVelocity = this.sweepSpeed;\n      }\n    }\n\n    // Update all dot positions to maintain formation\n    const lineLength = this.isHorizontal ? bounds.height : bounds.width;\n    for (let i = 0; i < this.dots.length; i++) {\n      const dot = this.dots[i];\n      \n      // Skip frozen dots - they should not move\n      if (dot.isFrozen()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n      \n      const offset = this.dotOffsets[i];\n\n      // Keep dots in formation - position them along the moving line\n      if (this.isHorizontal) {\n        // Horizontal line: X varies by offset, Y is the sweeping position\n        dot.position.x = this.lineOffset + offset - (lineLength / 2);\n        dot.position.y = this.linePos;\n      } else {\n        // Vertical line: Y varies by offset, X is the sweeping position\n        dot.position.x = this.linePos;\n        dot.position.y = this.lineOffset + offset - (lineLength / 2);\n      }\n\n      // Call update for state management (spawn animations, etc)\n      dot.update(dt, bounds, _playerPosition);\n    }\n\n    // Clean up dead dots\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      if (this.dots[i].isDead()) {\n        this.dots.splice(i, 1);\n        this.dotOffsets.splice(i, 1);\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.dots.length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\nexport class SparseGrid extends Pattern {\n  readonly type = PatternType.SPARSE_GRID;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private readonly dotSpeed: number = 20;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.dotSpeed = 40;\n        break;\n      case Difficulty.MEDIUM:\n        this.dotSpeed = 30;\n        break;\n      default:\n        this.dotSpeed = 20;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnGrid(bounds);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const dx = playerPosition.x - pos.x;\n      const dy = playerPosition.y - pos.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance > 0) {\n        const speed = distance > 50 ? this.dotSpeed : this.dotSpeed * (distance / 50);\n        dot.velocity.x = (dx / distance) * speed;\n        dot.velocity.y = (dy / distance) * speed;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnGrid(bounds: Bounds): void {\n    const margin = 100;\n    const spacing = 85;\n    const cols = Math.floor((bounds.width - margin * 2) / spacing);\n    const rows = Math.floor((bounds.height - margin * 2) / spacing);\n\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        const x = margin + col * spacing + spacing / 2;\n        const y = margin + row * spacing + spacing / 2;\n        this.spawnDot(x, y, { x: 0, y: 0 });\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { DOT_RADIUS } from '../utils/constants';\n\ninterface DotOffset {\n  x: number;\n  y: number;\n}\n\nexport class BouncingBall extends Pattern {\n  readonly type = PatternType.BOUNCING_BALL;\n  difficulty: Difficulty = Difficulty.MEDIUM;\n\n  private readonly duration: number = 30000;\n  private readonly ballRadius: number = 120;\n  private readonly dotCount: number = 200;\n  private centerPosition: Vector2 = { x: 0, y: 0 };\n  private centerVelocity: Vector2 = { x: 0, y: 0 };\n  private dotOffsets: DotOffset[] = [];\n  private speed: number = 120;\n\n  constructor(difficulty: Difficulty = Difficulty.MEDIUM) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.speed = 180;\n        break;\n      case Difficulty.MEDIUM:\n        this.speed = 120;\n        break;\n      default:\n        this.speed = 80;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.centerPosition = {\n      x: bounds.width / 2,\n      y: bounds.height / 2\n    };\n\n    const angle = Math.random() * Math.PI * 2;\n    this.centerVelocity = {\n      x: Math.cos(angle) * this.speed,\n      y: Math.sin(angle) * this.speed\n    };\n\n    this.spawnDots();\n  }\n\n  private spawnDots(): void {\n    this.dotOffsets = [];\n\n    const dotsPerRing = 20;\n    const ringCount = Math.ceil(this.dotCount / dotsPerRing);\n\n    for (let ring = 0; ring < ringCount; ring++) {\n      const ringRadius = (this.ballRadius * (ring + 1)) / ringCount;\n      const dotsInThisRing = Math.min(dotsPerRing, this.dotCount - this.dotOffsets.length);\n\n      for (let i = 0; i < dotsInThisRing; i++) {\n        const angle = (i / dotsInThisRing) * Math.PI * 2;\n        this.dotOffsets.push({\n          x: Math.cos(angle) * ringRadius,\n          y: Math.sin(angle) * ringRadius\n        });\n      }\n\n      if (this.dotOffsets.length >= this.dotCount) break;\n    }\n\n    for (let i = 0; i < this.dotOffsets.length; i++) {\n      const offset = this.dotOffsets[i];\n      this.spawnDot(\n        this.centerPosition.x + offset.x,\n        this.centerPosition.y + offset.y,\n        { x: this.centerVelocity.x, y: this.centerVelocity.y }\n      );\n    }\n  }\n\n  update(dt: number, _playerPosition: Vector2, bounds: Bounds): void {\n    this.centerPosition.x += this.centerVelocity.x * dt;\n    this.centerPosition.y += this.centerVelocity.y * dt;\n\n    const minX = this.ballRadius + DOT_RADIUS;\n    const maxX = bounds.width - this.ballRadius - DOT_RADIUS;\n    const minY = this.ballRadius + DOT_RADIUS;\n    const maxY = bounds.height - this.ballRadius - DOT_RADIUS;\n\n    if (this.centerPosition.x <= minX) {\n      this.centerPosition.x = minX;\n      this.centerVelocity.x = Math.abs(this.centerVelocity.x);\n    } else if (this.centerPosition.x >= maxX) {\n      this.centerPosition.x = maxX;\n      this.centerVelocity.x = -Math.abs(this.centerVelocity.x);\n    }\n\n    if (this.centerPosition.y <= minY) {\n      this.centerPosition.y = minY;\n      this.centerVelocity.y = Math.abs(this.centerVelocity.y);\n    } else if (this.centerPosition.y >= maxY) {\n      this.centerPosition.y = maxY;\n      this.centerVelocity.y = -Math.abs(this.centerVelocity.y);\n    }\n\n    for (let i = 0; i < this.dots.length; i++) {\n      const dot = this.dots[i];\n      \n      // Skip frozen dots - they should not move\n      if (dot.isFrozen()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n      \n      const offset = this.dotOffsets[i];\n\n      if (offset && !dot.isDead()) {\n        dot.position.x = this.centerPosition.x + offset.x;\n        dot.position.y = this.centerPosition.y + offset.y;\n        dot.velocity.x = this.centerVelocity.x;\n        dot.velocity.y = this.centerVelocity.y;\n      }\n\n      dot.update(dt, bounds, _playerPosition);\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { randomPosition } from '../utils/math';\nimport { DOT_RADIUS } from '../utils/constants';\n\nexport class GatlingPoint extends Pattern {\n  readonly type = PatternType.GATLING_POINT;\n  difficulty: Difficulty = Difficulty.MEDIUM;\n\n  private shootDuration: number;\n  private readonly dotSpeed: number = 400;\n  private shootInterval: number = 100;\n  private elapsedSinceSpawn: number = 0;\n  private spawnPoint: Vector2 = { x: 0, y: 0 };\n\n  constructor(difficulty: Difficulty = Difficulty.MEDIUM) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.shootDuration = 6000;\n        this.shootInterval = 50;\n        break;\n      case Difficulty.MEDIUM:\n        this.shootDuration = 4500;\n        this.shootInterval = 80;\n        break;\n      default:\n        this.shootDuration = 3000;\n        this.shootInterval = 100;\n    }\n  }\n\n  spawn(_center: Vector2, _bounds: Bounds): void {\n    this.start();\n    const margin = 50;\n    this.spawnPoint = randomPosition(_bounds, margin);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.elapsedMs <= this.shootDuration) {\n      this.elapsedSinceSpawn += dt * 1000;\n      if (this.elapsedSinceSpawn >= this.shootInterval) {\n        this.elapsedSinceSpawn = 0;\n        this.spawnDotAtPoint(playerPosition);\n      }\n    }\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n      const vel = dot.velocity;\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      if (pos.x < DOT_RADIUS || pos.x > bounds.width - DOT_RADIUS) {\n        vel.x = -vel.x;\n      }\n      if (pos.y < DOT_RADIUS || pos.y > bounds.height - DOT_RADIUS) {\n        vel.y = -vel.y;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnDotAtPoint(playerPosition: Vector2): void {\n    const dx = playerPosition.x - this.spawnPoint.x;\n    const dy = playerPosition.y - this.spawnPoint.y;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    if (dist > 0) {\n      this.spawnDot(this.spawnPoint.x, this.spawnPoint.y, {\n        x: (dx / dist) * this.dotSpeed,\n        y: (dy / dist) * this.dotSpeed\n      });\n    } else {\n      this.spawnDot(this.spawnPoint.x, this.spawnPoint.y);\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.shootDuration && this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { Dot } from '../entities/Dot';\nimport { PatternType, Difficulty, Bounds, Vector2, DotState } from '../types';\nimport { DOT_RADIUS, DOT_SPAWN_ANIMATION_DURATION } from '../utils/constants';\nimport { Renderer } from '../renderer/Renderer';\n\nexport class BulletHell extends Pattern {\n  readonly type = PatternType.BULLET_HELL;\n  difficulty: Difficulty = Difficulty.HARD;\n\n  private duration: number = 10000;\n  private readonly dotSpeed: number = 300;\n  private readonly warningDuration: number = DOT_SPAWN_ANIMATION_DURATION;\n\n  private originX: number = 0;\n  private originY: number = 0;\n  private isFromTop: boolean = false;\n  private hasStartedSpawning: boolean = false;\n  private hasSpawnedBullets: boolean = false;\n  private spawnTimeoutId: number | null = null;\n\n  constructor(difficulty: Difficulty = Difficulty.HARD) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.duration = 15000;\n        break;\n      case Difficulty.MEDIUM:\n        this.duration = 12000;\n        break;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.hasStartedSpawning = false;\n    this.hasSpawnedBullets = false;\n\n    this.isFromTop = Math.random() > 0.5;\n    this.originX = bounds.width / 2;\n    this.originY = this.isFromTop ? -50 : bounds.height + 50;\n\n    this.spawnTimeoutId = window.setTimeout(() => {\n      this.hasStartedSpawning = true;\n    }, this.warningDuration);\n  }\n\n  update(dt: number, _playerPosition: Vector2, bounds: Bounds): void {\n    if (this.hasStartedSpawning && this.elapsedMs <= this.duration + this.warningDuration) {\n      this.spawnBullets();\n    }\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      \n      // Skip frozen dots - they should not move\n      if (dot.isFrozen()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n      \n      const pos = dot.getPosition();\n\n      if (pos.x < -DOT_RADIUS || pos.x > bounds.width + DOT_RADIUS ||\n          pos.y < -DOT_RADIUS || pos.y > bounds.height + DOT_RADIUS) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      dot.position.x += dot.velocity.x * dt;\n      dot.position.y += dot.velocity.y * dt;\n    }\n  }\n\n  render(renderer: Renderer): void {\n    super.render?.(renderer);\n\n    if (!this.hasStartedSpawning && this.isStarted) {\n      const progress = Math.min(this.elapsedMs / this.warningDuration, 1);\n      const scale = 1.5 - 0.5 * progress;\n      const alpha = 1 - progress;\n\n      renderer.drawCircle(\n        this.originX,\n        this.originY,\n        DOT_RADIUS * scale * 2,\n        `rgba(255, 102, 102, ${alpha.toFixed(2)})`\n      );\n\n      renderer.drawCircleOutline(\n        this.originX,\n        this.originY,\n        DOT_RADIUS * scale * 3,\n        `rgba(255, 0, 0, ${alpha.toFixed(2)})`\n      );\n    }\n  }\n\n  private spawnBullets(): void {\n    if (this.hasSpawnedBullets) return;\n\n    this.hasSpawnedBullets = true;\n    const numStreams = 6;\n    const streamSpacing = (Math.PI * 2) / numStreams;\n\n    for (let stream = 0; stream < numStreams; stream++) {\n      const angleOffset = stream * streamSpacing;\n\n      for (let i = 0; i < 4; i++) {\n        const timeOffset = i * 200;\n        const angle = angleOffset + Math.sin(this.elapsedMs * 0.001 + timeOffset * 0.001) * 0.3;\n\n        const startX = this.originX + Math.cos(angle) * 50;\n\n        const dot = new Dot(startX, this.originY, this.type);\n        dot.velocity.x = Math.cos(angle) * this.dotSpeed;\n        dot.velocity.y = Math.sin(angle) * this.dotSpeed;\n        dot.state = DotState.ACTIVE;\n        this.dots.push(dot);\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration + this.warningDuration && this.getDots().length === 0;\n  }\n\n  clear(): void {\n    if (this.spawnTimeoutId !== null) {\n      window.clearTimeout(this.spawnTimeoutId);\n      this.spawnTimeoutId = null;\n    }\n    this.hasStartedSpawning = false;\n    this.hasSpawnedBullets = false;\n    super.clear();\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\nexport class ContainmentRing extends Pattern {\n  readonly type = PatternType.CONTAINMENT_RING;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private readonly ringRadius: number = 100;\n  private readonly dotSpeed: number = 30;\n  private readonly dotCount: number = 40;\n  private readonly innerRadius: number = 20;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n  }\n\n  spawn(center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnRing(center, bounds);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const dx = playerPosition.x - pos.x;\n      const dy = playerPosition.y - pos.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > this.innerRadius) {\n        dot.velocity.x = (dx / dist) * this.dotSpeed;\n        dot.velocity.y = (dy / dist) * this.dotSpeed;\n      } else {\n        dot.velocity.x = 0;\n        dot.velocity.y = 0;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnRing(center: Vector2, _bounds: Bounds): void {\n    const gapCount = Math.floor(Math.random() * 5);\n    const gapSize = gapCount > 0 ? 2 : 0;\n    const gaps: Array<[number, number]> = [];\n\n    for (let g = 0; g < gapCount; g++) {\n      const gapCenter = (this.dotCount * g) / gapCount + Math.floor(this.dotCount / (gapCount * 2));\n      const gapStart = gapCenter - gapSize;\n      const gapEnd = gapCenter + gapSize;\n      gaps.push([gapStart, gapEnd]);\n    }\n\n    for (let i = 0; i < this.dotCount; i++) {\n      const inGap = gaps.some(([start, end]) => i >= start && i <= end);\n      if (inGap) continue;\n\n      const angle = (2 * Math.PI * i) / this.dotCount;\n      const x = center.x + this.ringRadius * Math.cos(angle);\n      const y = center.y + this.ringRadius * Math.sin(angle);\n      this.spawnDot(x, y);\n    }\n  }\n\n  isComplete(): boolean {\n    return this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\n\nexport class Cyclone extends Pattern {\n  readonly type = PatternType.CYCLONE;\n  difficulty: Difficulty = Difficulty.HARD;\n\n  private readonly duration: number = 25000;\n  private circleRadius: number = 50;\n  private dotSpeed: number = 150;\n\n  constructor(difficulty: Difficulty = Difficulty.HARD) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.dotSpeed = 300;\n        this.circleRadius = 80;\n        break;\n      case Difficulty.MEDIUM:\n        this.dotSpeed = 200;\n        this.circleRadius = 60;\n        break;\n      default:\n        this.dotSpeed = 150;\n        this.circleRadius = 50;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnDots(bounds);\n  }\n\n  update(dt: number, _playerPosition: Vector2, bounds: Bounds): void {\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      // Remove dots that have flown off-screen\n      if (pos.x < -50 || pos.x > bounds.width + 50 ||\n          pos.y < -50 || pos.y > bounds.height + 50) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      dot.update(dt, bounds, _playerPosition);\n    }\n  }\n\n  private spawnDots(bounds: Bounds): void {\n    const centerX = bounds.width / 2;\n    const centerY = bounds.height / 2;\n    const dotCount = 150;\n\n    for (let i = 0; i < dotCount; i++) {\n      const angle = (i / dotCount) * Math.PI * 2;\n      const offsetAngle = angle + (Math.random() - 0.5) * 0.2;\n      const radius = this.circleRadius * (0.8 + Math.random() * 0.4);\n      const x = centerX + Math.cos(offsetAngle) * radius;\n      const y = centerY + Math.sin(offsetAngle) * radius;\n\n      const velAngle = offsetAngle + Math.PI / 2 + (Math.random() - 0.5) * 0.5;\n      const speed = this.dotSpeed * (0.5 + Math.random() * 1);\n      this.spawnDot(x, y, {\n        x: Math.cos(velAngle) * speed,\n        y: Math.sin(velAngle) * speed\n      });\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.getDots().length === 0;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport class Blaster extends Weapon {\n  readonly type = WeaponType.BLASTER;\n\n  private state: 'AIMING' | 'FIRING' | 'COMPLETE' = 'AIMING';\n  private aimTime: number = 1000;\n  private aimStartTime: number = 0;\n  private beamPosition: number = 0;\n  private prevBeamPosition: number = 0;\n  private beamAngle: number = 0;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n  private playerAngle: number = 0;\n  private beamOriginPosition: Vector2 = { x: 0, y: 0 };\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.dots = dots;\n    this.aimStartTime = Date.now();\n\n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n    this.beamAngle = this.playerAngle;\n\n    this.state = 'AIMING';\n  }\n\n  update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    if (this.state === 'COMPLETE') return;\n\n    const elapsed = Date.now() - this.aimStartTime;\n\n    if (this.state === 'AIMING') {\n      this.playerPosition = player.getPosition();\n      this.playerAngle = player.directionAngle;\n\n      if (elapsed >= this.aimTime) {\n        this.state = 'FIRING';\n        this.beamAngle = this.playerAngle;\n        this.beamOriginPosition = { ...this.playerPosition };\n      }\n    } else if (this.state === 'FIRING') {\n      this.prevBeamPosition = this.beamPosition;\n      this.beamPosition += 500 * dt;\n      this.checkBeamCollision(dots);\n      \n      if (this.beamPosition > Math.max(bounds.width, bounds.height)) {\n        this.state = 'COMPLETE';\n      }\n    }\n  }\n\n  checkBeamCollision(dots: Dot[]): void {\n    if (!dots || dots.length === 0) return;\n\n    const cos = Math.cos(this.beamAngle);\n    const sin = Math.sin(this.beamAngle);\n\n    for (const dot of dots) {\n      if (!dot.isDead()) {\n        const dotPos = dot.getPosition();\n        const dotRadius = dot.getRadius();\n\n        const dx = dotPos.x - this.beamOriginPosition.x;\n        const dy = dotPos.y - this.beamOriginPosition.y;\n\n        const localX = dx * cos + dy * sin;\n        const localY = dx * sin - dy * cos;\n\n        const halfWidth = 50 + dotRadius;\n        const halfLength = 100 + dotRadius;\n\n        const inWidth = Math.abs(localY) <= halfWidth;\n\n        if (!inWidth) continue;\n\n        const sweepStart = this.prevBeamPosition - halfLength;\n        const sweepEnd = this.beamPosition + halfLength;\n\n        const inSweepRange = localX >= sweepStart && localX <= sweepEnd;\n\n        if (inSweepRange) {\n          dot.kill();\n          this.addKilledDot();\n        }\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'COMPLETE') return;\n\n    const ctx = renderer.getContext();\n\n    if (this.state === 'AIMING') {\n      const x = this.playerPosition.x;\n      const y = this.playerPosition.y;\n\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(this.playerAngle);\n\n      ctx.fillStyle = 'rgb(128, 0, 128)';\n      ctx.fillRect(0, -6, 20, 12);\n\n      ctx.restore();\n    } else if (this.state === 'FIRING') {\n      const x = this.beamOriginPosition.x + this.beamPosition * Math.cos(this.beamAngle);\n      const y = this.beamOriginPosition.y + this.beamPosition * Math.sin(this.beamAngle);\n\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(this.beamAngle);\n\n      ctx.fillStyle = 'rgba(128, 0, 255, 0.78)';\n      ctx.fillRect(-5, -75, 10, 150);\n\n      ctx.restore();\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { WEAPON_COLORS } from '../utils/constants';\n\nexport class Chainsaw extends Weapon {\n  readonly type = WeaponType.CHAINSAW;\n\n  private readonly duration: number = 2500;\n  private readonly chainsawRadius: number = 50;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n\n  private readonly warningStartTime: number = 2100;\n  private readonly flashDuration: number = 100;\n  private readonly flashGap: number = 300;\n\n  activate(player: Player, _dots: Dot[]): void {\n    this.start();\n    this.playerPosition = player.getPosition();\n  }\n\n  update(_dt: number, player: Player, dots: Dot[], _bounds: Bounds): void {\n    if (this.getElapsedTime() >= this.duration) return;\n    if (!dots || dots.length === 0) return;\n    this.playerPosition = player.getPosition();\n\n    for (const dot of dots) {\n      if (!dot.isLethal()) continue;\n      const pos = dot.getPosition();\n      const dx = pos.x - this.playerPosition.x;\n      const dy = pos.y - this.playerPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.chainsawRadius) {\n        dot.kill();\n        this.addKilledDot();\n      }\n    }\n  }\n\n  private shouldShowVisual(): boolean {\n    const elapsed = this.getElapsedTime();\n\n    if (elapsed < this.warningStartTime) {\n      return true;\n    }\n\n    const warningElapsed = elapsed - this.warningStartTime;\n    const isFirstFlashOff = warningElapsed < this.flashDuration;\n    const isSecondFlashOff = warningElapsed >= this.flashGap &&\n                              warningElapsed < this.flashGap + this.flashDuration;\n\n    return !isFirstFlashOff && !isSecondFlashOff;\n  }\n\n  render(renderer: Renderer): void {\n    if (!this.shouldShowVisual()) return;\n    renderer.drawCircle(this.playerPosition.x, this.playerPosition.y, this.chainsawRadius, WEAPON_COLORS.CHAINSAW + '99');\n  }\n\n  isComplete(): boolean {\n    return this.getElapsedTime() >= this.duration;\n  }\n\n  getChainsawRadius(): number {\n    return this.chainsawRadius;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport class DotRepellent extends Weapon {\n  readonly type = WeaponType.DOT_REPELLENT;\n\n  private readonly duration: number = 8000;\n  private readonly fieldRadius: number = 100;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n\n  activate(player: Player, _dots: Dot[]): void {\n    this.start();\n    this.dots = [];\n    this.playerPosition = player.getPosition();\n  }\n\n  update(_dt: number, player: Player, dots: Dot[], _bounds: Bounds): void {\n    const elapsed = this.getElapsedTime();\n    if (elapsed >= this.duration) return;\n    if (!dots || dots.length === 0) return;\n\n    this.playerPosition = player.getPosition();\n\n    for (const dot of dots) {\n      if (!dot.isLethal()) continue;\n\n      const dotPos = dot.getPosition();\n      const dx = dotPos.x - this.playerPosition.x;\n      const dy = dotPos.y - this.playerPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < this.fieldRadius && distance > 0) {\n        const push = 5 * (1 - distance / this.fieldRadius);\n        dot.position.x += (dx / distance) * push;\n        dot.position.y += (dy / distance) * push;\n      }\n    }\n  }\n\n  render(_renderer: Renderer): void {\n    const ctx = _renderer.getContext();\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.arc(\n      this.playerPosition.x,\n      this.playerPosition.y,\n      this.fieldRadius,\n      0,\n      Math.PI * 2\n    );\n    ctx.strokeStyle = 'rgba(128, 128, 128, 0.3)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  isComplete(): boolean {\n    return this.getElapsedTime() >= this.duration;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { toastManager } from '../game/ToastManager';\n\ninterface ChainNode {\n  x: number;\n  y: number;\n  radius: number;\n  activatedAt: number;\n  chainDepth: number;\n  parentX?: number;\n  parentY?: number;\n}\n\ninterface LightningArc {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  createdAt: number;\n  chainDepth: number;\n}\n\nexport class ElectricBomb extends Weapon {\n  readonly type = WeaponType.ELECTRIC_BOMB;\n\n  private state: 'ROLLING' | 'CHAINING' | 'COMPLETE' = 'ROLLING';\n  private orbPosition: Vector2 = { x: 0, y: 0 };\n  private orbVelocity: Vector2 = { x: 0, y: 0 };\n  private chainNodes: ChainNode[] = [];\n  private lightningArcs: LightningArc[] = [];\n  private dotsToProcess: Dot[] = [];\n  private readonly initialRadiusFactor: number = 0.15;\n  private readonly chainRadiusFactor: number = 0.10;\n  private readonly maxChainDepth: number = 50;\n  private orbSpeed: number = 300;\n  private orbRadius: number = 12;\n  private rollingDuration: number = 2000;\n  private chainDelayMs: number = 80;\n  private lastChainTime: number = 0;\n  private bounds: Bounds | null = null;\n  private lastCollisionTime: number = 0;\n  private readonly collisionCooldown: number = 100;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.dots = dots;\n    this.start();\n\n    this.orbPosition = { ...player.getPosition() };\n\n    const angle = Math.random() * Math.PI * 2;\n    this.orbVelocity = {\n      x: Math.cos(angle) * this.orbSpeed,\n      y: Math.sin(angle) * this.orbSpeed\n    };\n\n    this.state = 'ROLLING';\n  }\n\n  update(_dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    if (this.bounds === null) {\n      this.bounds = bounds;\n    }\n\n    switch (this.state) {\n      case 'ROLLING':\n        this.updateRolling(_dt, bounds);\n        break;\n\n      case 'CHAINING':\n        this.updateChaining(dots, player, bounds);\n        break;\n\n      case 'COMPLETE':\n        break;\n    }\n  }\n\n  getPosition(): Vector2 {\n    return this.orbPosition;\n  }\n\n  getRadius(): number {\n    return this.orbRadius;\n  }\n\n  handlePlayerCollision(_player: Player, playerVelocity: Vector2): boolean {\n    const now = Date.now();\n    if (now - this.lastCollisionTime < this.collisionCooldown) {\n      return false;\n    }\n    this.lastCollisionTime = now;\n\n    const dx = this.orbPosition.x - _player.position.x;\n    const dy = this.orbPosition.y - _player.position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    const minSpeed = 50;\n    const playerSpeed = Math.sqrt(playerVelocity.x ** 2 + playerVelocity.y ** 2);\n\n    if (playerSpeed < minSpeed) {\n      return false;\n    }\n\n    if (distance === 0) {\n      this.orbVelocity.x = playerVelocity.x;\n      this.orbVelocity.y = playerVelocity.y;\n      return true;\n    }\n\n    const nx = dx / distance;\n    const ny = dy / distance;\n    const tx = -ny;\n    const ty = nx;\n\n    const vDotN = playerVelocity.x * nx + playerVelocity.y * ny;\n    const vDotT = playerVelocity.x * tx + playerVelocity.y * ty;\n\n    const directness = vDotN / playerSpeed;\n\n    if (directness < 0.1) {\n      return false;\n    }\n\n    const velocityMultiplier = 1.5;\n\n    if (directness > 0.7) {\n      this.orbVelocity.x = playerVelocity.x * velocityMultiplier;\n      this.orbVelocity.y = playerVelocity.y * velocityMultiplier;\n    } else {\n      const forwardFactor = directness;\n      const sidewaysFactor = 1 - directness;\n\n      this.orbVelocity.x = (nx * vDotN * forwardFactor + tx * vDotT * sidewaysFactor) * velocityMultiplier;\n      this.orbVelocity.y = (ny * vDotN * forwardFactor + ty * vDotT * sidewaysFactor) * velocityMultiplier;\n    }\n\n    return true;\n  }\n\n  private updateRolling(dt: number, bounds: Bounds): void {\n    this.orbPosition.x += this.orbVelocity.x * dt;\n    this.orbPosition.y += this.orbVelocity.y * dt;\n\n    if (this.orbPosition.x - this.orbRadius < 0) {\n      this.orbPosition.x = this.orbRadius;\n      this.orbVelocity.x = Math.abs(this.orbVelocity.x);\n    } else if (this.orbPosition.x + this.orbRadius > bounds.width) {\n      this.orbPosition.x = bounds.width - this.orbRadius;\n      this.orbVelocity.x = -Math.abs(this.orbVelocity.x);\n    }\n\n    if (this.orbPosition.y - this.orbRadius < 0) {\n      this.orbPosition.y = this.orbRadius;\n      this.orbVelocity.y = Math.abs(this.orbVelocity.y);\n    } else if (this.orbPosition.y + this.orbRadius > bounds.height) {\n      this.orbPosition.y = bounds.height - this.orbRadius;\n      this.orbVelocity.y = -Math.abs(this.orbVelocity.y);\n    }\n\n    if (this.getElapsedTime() >= this.rollingDuration) {\n      this.triggerInitialExplosion();\n    }\n  }\n\n  private triggerInitialExplosion(): void {\n    this.state = 'CHAINING';\n    this.lastChainTime = Date.now();\n    toastManager.show('Electric Bomb discharged!', 'warning');\n\n    const radius = (this.bounds?.width ?? 800) * this.initialRadiusFactor;\n    \n    this.chainNodes.push({\n      x: this.orbPosition.x,\n      y: this.orbPosition.y,\n      radius,\n      activatedAt: Date.now(),\n      chainDepth: 0\n    });\n\n    this.findAndElectrifyDots(this.chainNodes[0]);\n  }\n\n  private findAndElectrifyDots(node: ChainNode): void {\n    for (const dot of this.dots) {\n      if (dot.isDead()) continue;\n      \n      const pos = dot.getPosition();\n      const dx = pos.x - node.x;\n      const dy = pos.y - node.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      if (distance <= node.radius) {\n        dot.kill();\n        this.addKilledDot();\n        \n        this.lightningArcs.push({\n          x1: node.x,\n          y1: node.y,\n          x2: pos.x,\n          y2: pos.y,\n          createdAt: Date.now(),\n          chainDepth: node.chainDepth\n        });\n        \n        const newNode: ChainNode = {\n          x: pos.x,\n          y: pos.y,\n          radius: (this.bounds?.width ?? 800) * this.chainRadiusFactor,\n          activatedAt: Date.now(),\n          chainDepth: node.chainDepth + 1,\n          parentX: node.x,\n          parentY: node.y\n        };\n        \n        this.chainNodes.push(newNode);\n        this.dotsToProcess.push(dot);\n      }\n    }\n  }\n\n  private updateChaining(dots: Dot[], player: Player, _bounds: Bounds): void {\n    if (!dots || dots.length === 0) {\n      this.state = 'COMPLETE';\n      return;\n    }\n\n    const now = Date.now();\n\n    if (now - this.lastChainTime < this.chainDelayMs) {\n      return;\n    }\n\n    this.lastChainTime = now;\n\n    const pendingNodes = this.chainNodes.filter(n =>\n      n.chainDepth > 0 &&\n      now - n.activatedAt < 100 &&\n      n.chainDepth < this.maxChainDepth\n    );\n\n    if (pendingNodes.length === 0) {\n      this.checkPlayerHit(player);\n\n      const activeNodes = this.chainNodes.filter(n =>\n        now - n.activatedAt < 600\n      );\n\n      // Complete if no active nodes OR if only the initial node (depth 0) exists\n      // (meaning the chain never started because no dots were in range)\n      const hasChainNodes = this.chainNodes.some(n => n.chainDepth > 0);\n\n      if (activeNodes.length === 0 || !hasChainNodes) {\n        this.state = 'COMPLETE';\n      }\n      return;\n    }\n\n    for (const node of pendingNodes) {\n      this.findAndElectrifyDots(node);\n    }\n\n    this.checkPlayerHit(player);\n  }\n\n  private checkPlayerHit(_player: Player): void {\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'ROLLING') {\n      renderer.drawCircle(\n        this.orbPosition.x,\n        this.orbPosition.y,\n        this.orbRadius,\n        '#00FFFF'\n      );\n\n      renderer.drawCircleOutline(\n        this.orbPosition.x,\n        this.orbPosition.y,\n        this.orbRadius + 4,\n        'rgba(0, 255, 255, 0.5)',\n        2\n      );\n    } else if (this.state === 'CHAINING' || this.state === 'COMPLETE') {\n      this.renderChainNodes(renderer);\n      this.renderLightning(renderer);\n    }\n  }\n\n  private renderChainNodes(renderer: Renderer): void {\n    const now = Date.now();\n    const fadeTime = 500;\n\n    this.chainNodes = this.chainNodes.filter(node => now - node.activatedAt < fadeTime + 100);\n\n    for (const node of this.chainNodes) {\n      const age = now - node.activatedAt;\n      const opacity = Math.max(0, 1 - age / fadeTime);\n\n      if (opacity > 0) {\n        renderer.drawCircle(\n          node.x,\n          node.y,\n          node.radius,\n          `rgba(0, 255, 255, ${opacity * 0.3})`\n        );\n\n        renderer.drawCircleOutline(\n          node.x,\n          node.y,\n          node.radius,\n          `rgba(0, 255, 255, ${opacity})`,\n          3\n        );\n      }\n    }\n  }\n\n  private renderLightning(renderer: Renderer): void {\n    const now = Date.now();\n    const lightningFadeTime = 500;\n\n    this.lightningArcs = this.lightningArcs.filter(arc => now - arc.createdAt < lightningFadeTime);\n\n    for (const arc of this.lightningArcs) {\n      const age = now - arc.createdAt;\n      const opacity = Math.max(0, 1 - age / lightningFadeTime);\n\n      if (opacity > 0) {\n        this.drawJaggedLightning(\n          renderer,\n          arc.x1,\n          arc.y1,\n          arc.x2,\n          arc.y2,\n          opacity,\n          arc.chainDepth\n        );\n      }\n    }\n  }\n\n  private drawJaggedLightning(\n    renderer: Renderer,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    opacity: number,\n    chainDepth: number\n  ): void {\n    const segments = 3 + Math.min(chainDepth, 3);\n    const jitter = 6 + chainDepth * 2;\n    const color = `rgba(0, 200, 255, ${opacity})`;\n    const glowColor = `rgba(100, 230, 255, ${opacity * 0.5})`;\n\n    const points: { x: number; y: number }[] = [];\n    points.push({ x: x1, y: y1 });\n\n    for (let i = 1; i < segments; i++) {\n      const t = i / segments;\n      const baseX = x1 + (x2 - x1) * t;\n      const baseY = y1 + (y2 - y1) * t;\n\n      const offsetX = (Math.random() - 0.5) * jitter * 2;\n      const offsetY = (Math.random() - 0.5) * jitter * 2;\n\n      points.push({ x: baseX + offsetX, y: baseY + offsetY });\n    }\n\n    points.push({ x: x2, y: y2 });\n\n    for (let i = 0; i < points.length - 1; i++) {\n      renderer.drawLine(\n        points[i].x,\n        points[i].y,\n        points[i + 1].x,\n        points[i + 1].y,\n        glowColor,\n        4\n      );\n    }\n\n    for (let i = 0; i < points.length - 1; i++) {\n      renderer.drawLine(\n        points[i].x,\n        points[i].y,\n        points[i + 1].x,\n        points[i + 1].y,\n        color,\n        2\n      );\n    }\n  }\n\n  isActive(): boolean {\n    return this.state === 'ROLLING';\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  hasKilledPlayer(): boolean {\n    return false;\n  }\n\n  getExplosionCount(): number {\n    return this.chainNodes.length;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\ninterface FlameParticle {\n  x: number;\n  y: number;\n  age: number;\n  maxAge: number;\n}\n\ninterface FireTrail {\n  x: number;\n  y: number;\n  startTime: number;\n  duration: number;\n}\n\nexport class FlameBurst extends Weapon {\n  readonly type = WeaponType.FLAME_BURST;\n  \n  private readonly FLAME_DURATION_MS = 3000;\n  private readonly CONE_ANGLE_RAD = Math.PI / 3;\n  private readonly FLAME_REACH_PX = 200;\n  private readonly TRAIL_DURATION_MS = 1000;\n  private readonly PARTICLE_MAX_AGE_MS = 200;\n  private readonly PARTICLE_AGE_VARIANCE_MS = 100;\n  private readonly PARTICLES_PER_FRAME = 5;\n  private readonly FRAME_TIME_MS = 16;\n  \n  private playerPosition: Vector2 = { x: 0, y: 0 };\n  private playerAngle: number = 0;\n  private flames: FlameParticle[] = [];\n  private trails: FireTrail[] = [];\n  private flameActive: boolean = false;\n  private complete: boolean = false;\n  \n  activate(player: Player, _dots: Dot[]): void {\n    this.start();\n    this.dots = _dots;\n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n    this.flames = [];\n    this.trails = [];\n    this.flameActive = true;\n    this.complete = false;\n  }\n  \n  update(_dt: number, player: Player, dots: Dot[], _bounds: Bounds): void {\n    if (this.complete) return;\n    \n    const elapsed = this.getElapsedTime();\n    \n    if (elapsed >= this.FLAME_DURATION_MS) {\n      this.flameActive = false;\n      const now = Date.now();\n      this.trails = this.trails.filter(trail => now - trail.startTime < trail.duration);\n      if (this.trails.length === 0) {\n        this.complete = true;\n      }\n      return;\n    }\n    \n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n    \n    this.spawnFlameParticles();\n    \n    this.flames = this.flames.filter(flame => {\n      flame.age += this.FRAME_TIME_MS;\n      return flame.age < flame.maxAge;\n    });\n    \n    if (Math.random() < 0.3) {\n      this.spawnFireTrail();\n    }\n    \n    const now = Date.now();\n    this.trails = this.trails.filter(trail => now - trail.startTime < trail.duration);\n    \n    this.killDotsInFlameCone(dots);\n  }\n  \n  private spawnFlameParticles(): void {\n    for (let i = 0; i < this.PARTICLES_PER_FRAME; i++) {\n      const angleOffset = (Math.random() - 0.5) * this.CONE_ANGLE_RAD;\n      const angle = this.playerAngle + angleOffset;\n      const distance = Math.random() * this.FLAME_REACH_PX;\n      const jitterX = (Math.random() - 0.5) * 20;\n      const jitterY = (Math.random() - 0.5) * 20;\n      \n      this.flames.push({\n        x: this.playerPosition.x + Math.cos(angle) * distance + jitterX,\n        y: this.playerPosition.y + Math.sin(angle) * distance + jitterY,\n        age: 0,\n        maxAge: this.PARTICLE_MAX_AGE_MS + Math.random() * this.PARTICLE_AGE_VARIANCE_MS\n      });\n    }\n  }\n  \n  private spawnFireTrail(): void {\n    const angleOffset = (Math.random() - 0.5) * this.CONE_ANGLE_RAD;\n    const angle = this.playerAngle + angleOffset;\n    const distance = 20 + Math.random() * 60;\n    \n    this.trails.push({\n      x: this.playerPosition.x + Math.cos(angle) * distance,\n      y: this.playerPosition.y + Math.sin(angle) * distance,\n      startTime: Date.now(),\n      duration: this.TRAIL_DURATION_MS\n    });\n  }\n  \n  private killDotsInFlameCone(dots: Dot[]): void {\n    if (!dots || dots.length === 0) return;\n    \n    const halfConeAngle = this.CONE_ANGLE_RAD / 2;\n\n    for (const dot of dots) {\n      if (dot.isDead()) continue;\n      \n      const dotPos = dot.getPosition();\n      const dx = dotPos.x - this.playerPosition.x;\n      const dy = dotPos.y - this.playerPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      if (distance > this.FLAME_REACH_PX) continue;\n      \n      const dotAngle = Math.atan2(dy, dx);\n      let angleDiff = dotAngle - this.playerAngle;\n      \n      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;\n      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;\n      \n      if (Math.abs(angleDiff) <= halfConeAngle) {\n        dot.kill();\n        this.addKilledDot();\n      }\n    }\n  }\n  \n  render(renderer: Renderer): void {\n    if (this.complete) return;\n    \n    const ctx = renderer.getContext();\n    const now = Date.now();\n    \n    this.renderTrails(ctx, now);\n    \n    if (!this.flameActive) return;\n    \n    this.renderFlameCone(ctx);\n    this.renderFlameParticles(ctx);\n  }\n  \n  private renderTrails(ctx: CanvasRenderingContext2D, now: number): void {\n    for (const trail of this.trails) {\n      const age = now - trail.startTime;\n      const progress = age / trail.duration;\n      const alpha = Math.max(0, 1 - progress);\n      const radius = 8 + progress * 5;\n      \n      ctx.beginPath();\n      ctx.arc(trail.x, trail.y, radius, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.6})`;\n      ctx.fill();\n      \n      ctx.beginPath();\n      ctx.arc(trail.x, trail.y, radius * 0.5, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, 200, 50, ${alpha * 0.8})`;\n      ctx.fill();\n    }\n  }\n  \n  private renderFlameCone(ctx: CanvasRenderingContext2D): void {\n    ctx.save();\n    ctx.translate(this.playerPosition.x, this.playerPosition.y);\n    ctx.rotate(this.playerAngle);\n    \n    const coneGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.FLAME_REACH_PX);\n    coneGradient.addColorStop(0, 'rgba(255, 150, 0, 0.3)');\n    coneGradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');\n    coneGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');\n    \n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.arc(0, 0, this.FLAME_REACH_PX, -this.CONE_ANGLE_RAD / 2, this.CONE_ANGLE_RAD / 2);\n    ctx.closePath();\n    ctx.fillStyle = coneGradient;\n    ctx.fill();\n    \n    ctx.restore();\n  }\n  \n  private renderFlameParticles(ctx: CanvasRenderingContext2D): void {\n    for (const flame of this.flames) {\n      const progress = flame.age / flame.maxAge;\n      const alpha = Math.max(0, 1 - progress);\n      const size = 6 + progress * 8;\n      \n      ctx.beginPath();\n      ctx.arc(flame.x, flame.y, size, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, ${Math.floor(100 + progress * 50)}, 0, ${alpha * 0.5})`;\n      ctx.fill();\n      \n      ctx.beginPath();\n      ctx.arc(flame.x, flame.y, size * 0.4, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, ${Math.floor(200 + progress * 55)}, ${Math.floor(50 + progress * 100)}, ${alpha * 0.8})`;\n      ctx.fill();\n    }\n  }\n  \n  isComplete(): boolean {\n    return this.complete;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { distance } from '../utils/math';\n\ninterface Missile {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  angle: number;\n  target: Dot | null;\n  active: boolean;\n}\n\ninterface Explosion {\n  x: number;\n  y: number;\n  startTime: number;\n  duration: number;\n  mainRadius: number;\n  subExplosions: { x: number; y: number; radius: number }[];\n  hasAppliedDamage: boolean;\n  active: boolean;\n}\n\nconst MISSILE_RADIUS = 6;\nconst MISSILE_COLOR = '#FF6B00';\nconst MISSILE_TRAIL_COLOR = 'rgba(255, 107, 0, 0.3)';\nconst MAX_TURN_RATE = 5 * Math.PI / 180;\n\nconst EXPLOSION_MAIN_RADIUS = 45;\nconst EXPLOSION_SUB_RADIUS = 15;\nconst EXPLOSION_DURATION_MS = 500;\nconst EXPLOSION_SUB_DELAY_MS = 250;\nconst EXPLOSION_COLOR = '#FFD700';\n\nexport class HomingMissile extends Weapon {\n  readonly type = WeaponType.HOMING_MISSILE;\n\n  private missiles: Missile[] = [];\n  private explosions: Explosion[] = [];\n  private readonly missileSpeed: number = 800;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.dots = dots;\n    this.missiles = [];\n    this.explosions = [];\n\n    const playerPos = player.getPosition();\n    const baseAngle = player.directionAngle;\n    const playerVel = player.velocity;\n\n    const playerSpeedInfluence = Math.sqrt(playerVel.x ** 2 + playerVel.y ** 2) * 0.5;\n    const effectiveSpeed = this.missileSpeed + playerSpeedInfluence;\n\n    const angles = [baseAngle - Math.PI / 6, baseAngle, baseAngle + Math.PI / 6];\n\n    for (const launchAngle of angles) {\n      const missile: Missile = {\n        x: playerPos.x,\n        y: playerPos.y,\n        vx: Math.cos(launchAngle) * effectiveSpeed,\n        vy: Math.sin(launchAngle) * effectiveSpeed,\n        angle: launchAngle,\n        target: null,\n        active: true\n      };\n      this.missiles.push(missile);\n    }\n  }\n\n  private findBestTarget(missile: Missile, dots: Dot[]): Dot | null {\n    if (!dots || dots.length === 0) return null;\n    \n    let bestTarget: Dot | null = null;\n    let bestScore = Infinity;\n\n    for (const dot of dots) {\n      if (dot.isDead() || !dot.isLethal()) continue;\n\n      const dotPos = dot.getPosition();\n      const dist = distance(missile, dotPos);\n\n      const angleToDot = Math.atan2(dotPos.y - missile.y, dotPos.x - missile.x);\n      const angleDiff = Math.abs(this.normalizeAngle(angleToDot - missile.angle));\n\n      const score = dist * (1 + angleDiff);\n\n      if (score < bestScore) {\n        bestScore = score;\n        bestTarget = dot;\n      }\n    }\n\n    return bestTarget;\n  }\n\n  private normalizeAngle(angle: number): number {\n    while (angle > Math.PI) angle -= 2 * Math.PI;\n    while (angle < -Math.PI) angle += 2 * Math.PI;\n    return angle;\n  }\n\n  private createExplosion(x: number, y: number): void {\n    const subExplosions = [];\n    for (let i = 0; i < 4; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const dist = Math.random() * EXPLOSION_MAIN_RADIUS * 0.6;\n      subExplosions.push({\n        x: Math.cos(angle) * dist,\n        y: Math.sin(angle) * dist,\n        radius: EXPLOSION_SUB_RADIUS * (0.8 + Math.random() * 0.4)\n      });\n    }\n\n    const explosion: Explosion = {\n      x,\n      y,\n      startTime: Date.now(),\n      duration: EXPLOSION_DURATION_MS,\n      mainRadius: EXPLOSION_MAIN_RADIUS,\n      subExplosions,\n      hasAppliedDamage: false,\n      active: true\n    };\n    this.explosions.push(explosion);\n  }\n\n  private applyExplosionDamage(explosion: Explosion, dots: Dot[]): void {\n    if (explosion.hasAppliedDamage) return;\n\n    for (const dot of dots) {\n      if (dot.isDead() || !dot.isLethal()) continue;\n\n      const dotPos = dot.getPosition();\n      const dist = distance({ x: explosion.x, y: explosion.y }, dotPos);\n\n      if (dist < explosion.mainRadius + dot.getRadius()) {\n        dot.kill();\n        this.addKilledDot();\n      }\n    }\n\n    explosion.hasAppliedDamage = true;\n  }\n\n  update(_dt: number, _player: Player, dots: Dot[], bounds: Bounds): void {\n    const now = Date.now();\n\n    this.missiles = this.missiles.filter(m => m.active);\n    this.explosions = this.explosions.filter(e => e.active);\n\n    for (const explosion of this.explosions) {\n      const elapsed = now - explosion.startTime;\n      if (elapsed >= explosion.duration) {\n        explosion.active = false;\n      }\n      if (!explosion.hasAppliedDamage) {\n        this.applyExplosionDamage(explosion, dots);\n      }\n    }\n\n    for (const missile of this.missiles) {\n      if (!missile.active) continue;\n\n      if (!missile.target || missile.target.isDead() || !missile.target.isLethal()) {\n        missile.target = this.findBestTarget(missile, dots);\n      }\n\n      if (missile.target) {\n        const targetPos = missile.target.getPosition();\n        const angleToTarget = Math.atan2(\n          targetPos.y - missile.y,\n          targetPos.x - missile.x\n        );\n\n        const angleDiff = this.normalizeAngle(angleToTarget - missile.angle);\n\n        const turnAmount = Math.max(-MAX_TURN_RATE, Math.min(MAX_TURN_RATE, angleDiff));\n        missile.angle += turnAmount;\n\n        const currentSpeed = Math.sqrt(missile.vx ** 2 + missile.vy ** 2);\n        missile.vx = Math.cos(missile.angle) * currentSpeed;\n        missile.vy = Math.sin(missile.angle) * currentSpeed;\n      }\n\n      missile.x += missile.vx * _dt;\n      missile.y += missile.vy * _dt;\n\n      if (\n        missile.x < -MISSILE_RADIUS ||\n        missile.x > bounds.width + MISSILE_RADIUS ||\n        missile.y < -MISSILE_RADIUS ||\n        missile.y > bounds.height + MISSILE_RADIUS\n      ) {\n        missile.active = false;\n        continue;\n      }\n\n      for (const dot of dots) {\n        if (dot.isDead() || !dot.isLethal()) continue;\n\n        const dotPos = dot.getPosition();\n        const dist = distance(missile, dotPos);\n\n        if (dist < MISSILE_RADIUS + dot.getRadius()) {\n          this.createExplosion(missile.x, missile.y);\n          missile.active = false;\n          break;\n        }\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    const ctx = renderer.getContext();\n    const now = Date.now();\n\n    for (const missile of this.missiles) {\n      if (!missile.active) continue;\n\n      ctx.save();\n      ctx.translate(missile.x, missile.y);\n      ctx.rotate(missile.angle);\n\n      ctx.beginPath();\n      ctx.moveTo(-15, 0);\n      ctx.lineTo(-MISSILE_RADIUS, 0);\n      ctx.strokeStyle = MISSILE_TRAIL_COLOR;\n      ctx.lineWidth = 4;\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.moveTo(MISSILE_RADIUS * 1.5, 0);\n      ctx.lineTo(-MISSILE_RADIUS, -MISSILE_RADIUS * 0.6);\n      ctx.lineTo(-MISSILE_RADIUS, MISSILE_RADIUS * 0.6);\n      ctx.closePath();\n      ctx.fillStyle = MISSILE_COLOR;\n      ctx.fill();\n\n      ctx.restore();\n    }\n\n    for (const explosion of this.explosions) {\n      if (!explosion.active) continue;\n\n      const elapsed = now - explosion.startTime;\n      const progress = elapsed / explosion.duration;\n      const opacity = 1 - progress;\n\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      ctx.fillStyle = EXPLOSION_COLOR;\n\n      ctx.beginPath();\n      ctx.arc(explosion.x, explosion.y, explosion.mainRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      if (elapsed >= EXPLOSION_SUB_DELAY_MS) {\n        for (const sub of explosion.subExplosions) {\n          ctx.beginPath();\n          ctx.arc(\n            explosion.x + sub.x,\n            explosion.y + sub.y,\n            sub.radius,\n            0,\n            Math.PI * 2\n          );\n          ctx.fill();\n        }\n      }\n\n      ctx.restore();\n    }\n  }\n\n  isComplete(): boolean {\n    return this.missiles.every(m => !m.active) && this.explosions.every(e => !e.active);\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { DotState } from '../types';\nimport { WeaponType, Bounds } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport interface FrozenDot {\n  dot: Dot;\n  frozenTime: number;\n}\n\nexport class IceBomb extends Weapon {\n  readonly type = WeaponType.ICE_BOMB;\n\n  private state: 'EXPLODING' | 'FADING' | 'COMPLETE' = 'EXPLODING';\n  private bounds: Bounds | null = null;\n  private explosionRadius: number = 0;\n  private explosionCenter: { x: number; y: number } = { x: 0, y: 0 };\n  private explosionStartTime: number = 0;\n  private frozenDotsCount: number = 0;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.explosionStartTime = Date.now();\n    this.explosionCenter = { x: player.position.x, y: player.position.y };\n    this.dots = dots;\n    \n    // Calculate explosion radius based on bounds\n    this.explosionRadius = 0.3 * (dots.length > 0 ? 800 : 800); // Default to reasonable size\n    \n    // Freeze dots in explosion radius\n    this.freezeDotsInRadius(dots);\n    \n    this.state = 'EXPLODING';\n  }\n\n  update(_dt: number, _player: Player, _dots: Dot[], bounds: Bounds): void {\n    if (!this.bounds) {\n      this.bounds = bounds;\n      this.explosionRadius = 0.3 * bounds.width;\n      \n      // Re-freeze dots now that we have proper bounds\n      if (this.frozenDotsCount === 0) {\n        this.freezeDotsInRadius(this.dots);\n      }\n    }\n\n    if (this.state === 'EXPLODING') {\n      const elapsed = Date.now() - this.explosionStartTime;\n      if (elapsed >= 500) {\n        this.state = 'FADING';\n      }\n    } else if (this.state === 'FADING') {\n      const elapsed = Date.now() - this.explosionStartTime;\n      // Effect lasts 3000ms to match dot freeze duration\n      if (elapsed >= 3000) {\n        this.state = 'COMPLETE';\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'EXPLODING' || this.state === 'FADING') {\n      const elapsed = Date.now() - this.explosionStartTime;\n      let alpha = 0.6;\n      \n      if (this.state === 'FADING') {\n        // Fade out over 2500ms (from 500ms to 3000ms)\n        alpha = 0.6 * (1 - (elapsed - 500) / 2500);\n      }\n      \n      if (alpha > 0) {\n        renderer.drawCircle(\n          this.explosionCenter.x,\n          this.explosionCenter.y,\n          this.explosionRadius,\n          `rgba(0, 204, 255, ${alpha})` // Blue explosion\n        );\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  private freezeDotsInRadius(dots: Dot[]): void {\n    if (!dots || dots.length === 0) return;\n\n    for (const dot of dots) {\n      if (dot.state === DotState.SPAWNING || dot.isDead() || dot.isFrozen()) {\n        continue;\n      }\n\n      const pos = dot.getPosition();\n      const dx = pos.x - this.explosionCenter.x;\n      const dy = pos.y - this.explosionCenter.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < this.explosionRadius) {\n        dot.freeze();\n        this.frozenDotsCount++;\n      }\n    }\n  }\n\n  getFrozenDotsCount(): number {\n    return this.frozenDotsCount;\n  }\n\n  getExplosionRadius(): number {\n    return this.explosionRadius;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport class KineticBomb extends Weapon {\n  readonly type = WeaponType.KINETIC_BOMB;\n\n  private state: 'COLLAPSING' | 'EXPLODING' | 'COMPLETE' = 'COLLAPSING';\n  private explosionCenter: Vector2 = { x: 0, y: 0 };\n  private explosionRadius: number = 0;\n  private bounds: Bounds | null = null;\n  private killedDotsInExplosion: Set<Dot> = new Set();\n\n  activate(player: Player, dots: Dot[]): void {\n    this.dots = dots;\n    this.explosionCenter = { x: player.position.x, y: player.position.y };\n    this.start();\n  }\n\n  update(_dt: number, _player: Player, dots: Dot[], bounds: Bounds): void {\n    if (!this.bounds) this.bounds = bounds;\n    const elapsedTime = this.getElapsedTime();\n\n    switch (this.state) {\n      case 'COLLAPSING':\n        if (elapsedTime >= 100) {\n          this.state = 'EXPLODING';\n          this.explosionRadius = 0.25 * bounds.width;\n        }\n        break;\n\n      case 'EXPLODING':\n        // Continuously kill dots that enter the explosion\n        this.killDotsInExplosion(dots);\n        \n        // Complete after 1 second total (100ms collapse + 900ms explosion)\n        if (elapsedTime >= 1000) {\n          this.state = 'COMPLETE';\n        }\n        break;\n\n      case 'COMPLETE':\n        break;\n    }\n  }\n\n  render(renderer: Renderer): void {\n    const elapsedTime = this.getElapsedTime();\n\n    if (this.state === 'COLLAPSING') {\n      const collapseRadius = 50 * (1 - elapsedTime / 100);\n      if (collapseRadius > 0) {\n        renderer.drawCircle(\n          this.explosionCenter.x,\n          this.explosionCenter.y,\n          Math.max(0, collapseRadius),\n          '#FF4500'\n        );\n      }\n    } else if (this.state === 'EXPLODING') {\n      // Translucent explosion that fades over time\n      const explosionElapsed = elapsedTime - 100;\n      const explosionDuration = 900;\n      const fadeOpacity = 1 - (explosionElapsed / explosionDuration);\n      \n      if (fadeOpacity > 0) {\n        renderer.drawCircle(\n          this.explosionCenter.x,\n          this.explosionCenter.y,\n          this.explosionRadius,\n          `rgba(255, 69, 0, ${fadeOpacity * 0.7})`\n        );\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  private killDotsInExplosion(dots: Dot[]): void {\n    for (const dot of dots) {\n      if (dot.isDead() || this.killedDotsInExplosion.has(dot)) continue;\n\n      const pos = dot.getPosition();\n      const dx = pos.x - this.explosionCenter.x;\n      const dy = pos.y - this.explosionCenter.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.explosionRadius) {\n        dot.kill();\n        this.addKilledDot();\n        this.killedDotsInExplosion.add(dot);\n      }\n    }\n  }\n}\n","import { Game } from './game/Game';\nimport { PatternRegistry } from './patterns/PatternRegistry';\nimport { WeaponRegistry } from './weapons/WeaponRegistry';\nimport { PatternType } from './types';\nimport { WeaponType } from './types';\nimport { toastManager } from './game/ToastManager';\n\nimport { ZombieSnow } from './patterns/ZombieSnow';\nimport { SweeperLine } from './patterns/SweeperLine';\nimport { SparseGrid } from './patterns/SparseGrid';\nimport { BouncingBall } from './patterns/BouncingBall';\nimport { GatlingPoint } from './patterns/GatlingPoint';\nimport { BulletHell } from './patterns/BulletHell';\nimport { ContainmentRing } from './patterns/ContainmentRing';\nimport { Cyclone } from './patterns/Cyclone';\n\nimport { Blaster } from './weapons/Blaster';\nimport { Chainsaw } from './weapons/Chainsaw';\nimport { DotRepellent } from './weapons/DotRepellent';\nimport { ElectricBomb } from './weapons/ElectricBomb';\nimport { FlameBurst } from './weapons/FlameBurst';\nimport { HomingMissile } from './weapons/HomingMissile';\nimport { IceBomb } from './weapons/IceBomb';\nimport { KineticBomb } from './weapons/KineticBomb';\nimport { NuclearBomb } from './weapons/NuclearBomb';\n\nPatternRegistry.register(PatternType.ZOMBIE_SNOW, ZombieSnow);\nPatternRegistry.register(PatternType.SWEEPER_LINE, SweeperLine);\nPatternRegistry.register(PatternType.SPARSE_GRID, SparseGrid);\nPatternRegistry.register(PatternType.BOUNCING_BALL, BouncingBall);\nPatternRegistry.register(PatternType.GATLING_POINT, GatlingPoint);\nPatternRegistry.register(PatternType.BULLET_HELL, BulletHell);\nPatternRegistry.register(PatternType.CONTAINMENT_RING, ContainmentRing);\nPatternRegistry.register(PatternType.CYCLONE, Cyclone);\n\nWeaponRegistry.register(WeaponType.BLASTER, Blaster);\nWeaponRegistry.register(WeaponType.CHAINSAW, Chainsaw);\nWeaponRegistry.register(WeaponType.DOT_REPELLENT, DotRepellent);\nWeaponRegistry.register(WeaponType.ELECTRIC_BOMB, ElectricBomb);\nWeaponRegistry.register(WeaponType.FLAME_BURST, FlameBurst);\nWeaponRegistry.register(WeaponType.HOMING_MISSILE, HomingMissile);\nWeaponRegistry.register(WeaponType.ICE_BOMB, IceBomb);\nWeaponRegistry.register(WeaponType.KINETIC_BOMB, KineticBomb);\nWeaponRegistry.register(WeaponType.NUCLEAR_BOMB, NuclearBomb);\n\ntoastManager.setupGlobalErrorHandler();\n\nnew Game();"],"names":["GameState","DotState","PatternType","WeaponType","Difficulty","Renderer","canvasId","canvas","ctx","color","x","y","radius","batch","lineWidth","i","c","byWidth","o","group","x1","y1","x2","y2","width","angle","length","cos","sin","endX","endY","headLength","headAngle","height","text","fontSize","points","PLAYER_VISUAL_RADIUS","PLAYER_HITBOX_RADIUS","PLAYER_MAX_SPEED","PLAYER_ARROW_LENGTH","DOT_RADIUS","DOT_SPAWN_ANIMATION_DURATION","DOT_SPAWN_SCALE_MAX","WEAPON_ORB_RADIUS","COLOR_PLAYER","COLOR_PLAYER_ARROW","COLOR_DOT","COLOR_DOT_SPAWNING","COLOR_DOT_FROZEN","COLOR_BACKGROUND","WEAPON_COLORS","TARGET_FPS","FRAME_TIME","InputManager","basis","error","gamma","beta","orientation","tiltX","tiltY","event","reference","gammaDelta","betaDelta","gameCoords","normalizedX","normalizedY","value","min","max","Vec2","v","other","scalar","mag","distance","a","b","dx","dy","wrapInPlace","position","bounds","circleCollision","radiusA","radiusB","distanceSq","radiiSum","randomPosition","margin","Player","dt","inputVelocity","shouldWrap","renderer","arrowStartX","arrowStartY","ScoringSystem","count","difficulty","bonuses","timeBonus","CELL_SIZE","NEARBY_OFFSETS","CollisionSystem","_bounds","cellX","cellY","dots","dot","pos","key","cell","player","playerPos","playerRadius","nearbyKeys","j","dotPos","dotRadius","orbs","orb","orbPos","orbRadius","DifficultyManager","score","PatternRegistryImpl","type","patternClass","PatternClass","PatternRegistry","ToastManager","duration","toast","removed","element","colors","id","index","t","stack","message","title","filename","lineno","colno","content","header","messageDiv","locationDiv","stackHeader","stackTrace","buttonContainer","reloadButton","copyButton","fullError","toastManager","PATTERN_DIFFICULTY_MAP","SCORE_THRESHOLDS","PatternManager","playerPosition","nextType","pattern","availableTypes","allTypes","candidateTypes","randomIndex","completedPattern","word","WeaponOrb","weaponType","borderColor","iconScale","scale","branchX","branchY","arrowSize","spacing","arrowX","arrowY","size","skullScale","teethX","teethX2","boneEndRadius","boneEnds","end","numTeeth","innerR","outerR","distSq","playerVelocity","now","nx","ny","tx","ty","vDotN","vDotT","restitution","friction","minX","maxX","minY","maxY","WeaponOrbSpawner","attempts","types","WeaponRegistryImpl","weaponClass","WeaponClass","WeaponRegistry","Weapon","_player","_playerVelocity","d","NuclearBomb","_dots","minSpeed","playerSpeed","directness","velocityMultiplier","forwardFactor","sidewaysFactor","elapsedTime","progress","warningExplosionRadius","warningStartTime","warningElapsed","flash1Start","flash2Start","shouldShowFlash","explosionElapsed","alpha","color1","color2","factor","r1","g1","b1","r2","g2","b2","r","g","STORAGE_KEY","getHighscores","data","Game","isLandscape","show","el","centerX","centerY","finalScore","highscoreList","highscores","h","deathReasonElement","recentToastsList","allMessages","msg","currentTime","deltaTime","velocity","allDots","collidingOrb","weapon","weaponPos","weaponRadius","collidingDot","FROZEN_BORDER_MAX_THICKNESS","FROZEN_BORDER_COLOR","SPAWN_INV_DURATION","SCALE_RANGE","Dot","patternId","frozenProgress","timeUntilThaw","shakeIntensity","dist","currentRadius","renderX","renderY","Pattern","_renderer","ZombieSnow","_center","SweeperLine","numHoles","lineLength","numDots","holeSet","holeWidthDots","holeCenter","startOffset","offset","_playerPosition","SparseGrid","speed","cols","rows","row","col","BouncingBall","dotsPerRing","ringCount","ring","ringRadius","dotsInThisRing","GatlingPoint","vel","BulletHell","numStreams","streamSpacing","stream","angleOffset","timeOffset","startX","ContainmentRing","center","gapCount","gapSize","gaps","gapCenter","gapStart","gapEnd","start","Cyclone","dotCount","offsetAngle","velAngle","Blaster","elapsed","localX","localY","halfWidth","halfLength","sweepStart","sweepEnd","Chainsaw","_dt","isFirstFlashOff","isSecondFlashOff","DotRepellent","push","ElectricBomb","node","newNode","pendingNodes","activeNodes","n","hasChainNodes","fadeTime","age","opacity","lightningFadeTime","arc","chainDepth","segments","jitter","glowColor","baseX","baseY","offsetX","offsetY","FlameBurst","trail","flame","jitterX","jitterY","halfConeAngle","angleDiff","coneGradient","MISSILE_RADIUS","MISSILE_COLOR","MISSILE_TRAIL_COLOR","MAX_TURN_RATE","EXPLOSION_MAIN_RADIUS","EXPLOSION_SUB_RADIUS","EXPLOSION_DURATION_MS","EXPLOSION_SUB_DELAY_MS","EXPLOSION_COLOR","HomingMissile","baseAngle","playerVel","playerSpeedInfluence","effectiveSpeed","angles","launchAngle","missile","bestTarget","bestScore","angleToDot","subExplosions","explosion","m","e","targetPos","angleToTarget","turnAmount","currentSpeed","sub","IceBomb","KineticBomb","collapseRadius","fadeOpacity"],"mappings":"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"}