{"version":3,"file":"index-BmcqfF1u.js","sources":["../../src/types/index.ts","../../src/renderer/Renderer.ts","../../src/utils/constants.ts","../../src/game/InputManager.ts","../../src/utils/math.ts","../../src/entities/Player.ts","../../src/game/ScoringSystem.ts","../../src/game/CollisionSystem.ts","../../src/patterns/PatternRegistry.ts","../../src/game/PatternManager.ts","../../src/entities/WeaponOrb.ts","../../src/game/WeaponOrbSpawner.ts","../../src/weapons/WeaponRegistry.ts","../../src/weapons/Weapon.ts","../../src/weapons/NuclearBomb.ts","../../src/utils/storage.ts","../../src/game/GameEventLogger.ts","../../src/game/Game.ts","../../src/entities/Dot.ts","../../src/patterns/Pattern.ts","../../src/patterns/ZombieSnow.ts","../../src/patterns/SweeperLine.ts","../../src/patterns/SparseGrid.ts","../../src/patterns/UltraSparseGrid.ts","../../src/patterns/BouncingBall.ts","../../src/patterns/GatlingPoint.ts","../../src/patterns/BulletHellBase.ts","../../src/patterns/SpiralPattern.ts","../../src/patterns/CircleBurstPattern.ts","../../src/patterns/AimedStreamsPattern.ts","../../src/patterns/WavePattern.ts","../../src/patterns/ContainmentRing.ts","../../src/patterns/Cyclone.ts","../../src/patterns/ClockSweep.ts","../../src/weapons/Blaster.ts","../../src/weapons/Chainsaw.ts","../../src/weapons/DotRepellent.ts","../../src/weapons/ElectricBomb.ts","../../src/weapons/FlameBurst.ts","../../src/weapons/HomingMissile.ts","../../src/weapons/IceBomb.ts","../../src/weapons/KineticBomb.ts","../../src/weapons/TripleCannon.ts","../../src/weapons/FireballOrb.ts","../../src/weapons/TeslaCannon.ts","../../src/main.ts"],"sourcesContent":["export interface Vector2 {\n  x: number;\n  y: number;\n}\n\nexport enum GameState {\n  MENU = 'MENU',\n  PLAYING = 'PLAYING',\n  GAME_OVER = 'GAME_OVER',\n  PAUSED = 'PAUSED'\n}\n\nexport enum DotState {\n  SPAWNING = 'SPAWNING',\n  ACTIVE = 'ACTIVE',\n  FROZEN = 'FROZEN',\n  DEAD = 'DEAD'\n}\n\nexport enum PatternType {\n  ZOMBIE_SNOW = 'ZOMBIE_SNOW',\n  SWEEPER_LINE = 'SWEEPER_LINE',\n  SPARSE_GRID = 'SPARSE_GRID',\n  ULTRA_SPARSE_GRID = 'ULTRA_SPARSE_GRID',\n  BOUNCING_BALL = 'BOUNCING_BALL',\n  GATLING_POINT = 'GATLING_POINT',\n\n  SPIRAL = 'SPIRAL',\n  CIRCLE_BURST = 'CIRCLE_BURST',\n  AIMED_STREAMS = 'AIMED_STREAMS',\n  WAVE = 'WAVE',\n  CONTAINMENT_RING = 'CONTAINMENT_RING',\n  CYCLONE = 'CYCLONE',\n  CLOCK_SWEEP = 'CLOCK_SWEEP'\n}\n\nexport enum WeaponType {\n  KINETIC_BOMB = 'KINETIC_BOMB',\n  BLASTER = 'BLASTER',\n  ICE_BOMB = 'ICE_BOMB',\n  HOMING_MISSILE = 'HOMING_MISSILE',\n  NUCLEAR_BOMB = 'NUCLEAR_BOMB',\n  ELECTRIC_BOMB = 'ELECTRIC_BOMB',\n  DOT_REPELLENT = 'DOT_REPELLENT',\n  CHAINSAW = 'CHAINSAW',\n  FLAME_BURST = 'FLAME_BURST',\n  TRIPLE_CANNON = 'TRIPLE_CANNON',\n  FIREBALL_ORB = 'FIREBALL_ORB',\n  TESLA_CANNON = 'TESLA_CANNON'\n}\n\nexport enum Difficulty {\n  EASY = 'EASY',\n  MEDIUM = 'MEDIUM',\n  HARD = 'HARD'\n}\n\nexport interface Entity {\n  position: Vector2;\n  velocity: Vector2;\n  radius: number;\n}\n\nexport interface HighscoreEntry {\n  score: number;\n  timestamp: number;\n}\n\nexport interface PlayerConfig {\n  hitboxRadius: number;\n  maxSpeed: number;\n}\n\nexport interface DotConfig {\n  radius: number;\n  spawnAnimationDuration: number;\n}\n\nexport interface WeaponOrbConfig {\n  radius: number;\n  alwaysOnArena: number;\n}\n\nexport interface Bounds {\n  width: number;\n  height: number;\n}\n\nexport interface DeathEvent {\n  message: string;\n  type: 'dot' | 'nuclear_bomb' | 'electric_bomb';\n  timestamp: number;\n}\n\nexport enum GameEventType {\n  PATTERN_SPAWN_START = 'PATTERN_SPAWN_START',\n  PATTERN_SPAWN_COMPLETE = 'PATTERN_SPAWN_COMPLETE',\n  WEAPON_PICKUP = 'WEAPON_PICKUP',\n  WEAPON_ACTIVATE = 'WEAPON_ACTIVATE',\n  BOUNCED_ORB_DETONATE = 'BOUNCED_ORB_DETONATE',\n  PLAYER_DEATH = 'PLAYER_DEATH'\n}\n\nexport interface GameEvent {\n  type: GameEventType;\n  timestamp: number;\n  message: string;\n  details?: Record<string, unknown>;\n}\n","interface CircleBatch {\n  x: number;\n  y: number;\n  radius: number;\n}\n\ninterface CircleOutlineBatch {\n  x: number;\n  y: number;\n  radius: number;\n  lineWidth: number;\n}\n\nexport class Renderer {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private width: number = 0;\n  private height: number = 0;\n  private dpr: number = 1;\n\n  private circleBatches: Map<string, CircleBatch[]> = new Map();\n  private outlineBatches: Map<string, CircleOutlineBatch[]> = new Map();\n\n  private static readonly TWO_PI = Math.PI * 2;\n  private scale: number = 1.3;\n  private onScaleChange?: () => void;\n\n  constructor(canvasId: string = 'game') {\n    const canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    if (!canvas) {\n      throw new Error(`Canvas element with id \"${canvasId}\" not found`);\n    }\n    this.canvas = canvas;\n    \n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to get 2D context');\n    }\n    this.ctx = ctx;\n    \n    this.resize();\n    window.addEventListener('resize', () => this.resize());\n  }\n\n  resize(): void {\n    this.dpr = window.devicePixelRatio || 1;\n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n    \n    // Set canvas backing store to physical pixel size for crisp rendering\n    this.canvas.width = Math.floor(this.width * this.dpr);\n    this.canvas.height = Math.floor(this.height * this.dpr);\n    \n    // Keep CSS size at logical pixels\n    this.canvas.style.width = `${this.width}px`;\n    this.canvas.style.height = `${this.height}px`;\n  }\n\n  getBounds(): { width: number; height: number } {\n    return { width: this.width / this.scale, height: this.height / this.scale };\n  }\n\n  setScale(scale: number): void {\n    this.scale = scale;\n    if (this.onScaleChange) {\n      this.onScaleChange();\n    }\n  }\n\n  getScale(): number {\n    return this.scale;\n  }\n\n  onScaleChangeCallback(callback: () => void): void {\n    this.onScaleChange = callback;\n  }\n\n  clear(color: string = '#000000'): void {\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.save();\n    this.ctx.scale(this.dpr * this.scale, this.dpr * this.scale);\n  }\n\n  endFrame(): void {\n    this.ctx.restore();\n  }\n\n  // Queue a circle - renders when flushBatches() is called\n  drawCircle(x: number, y: number, radius: number, color: string): void {\n    let batch = this.circleBatches.get(color);\n    if (!batch) {\n      batch = [];\n      this.circleBatches.set(color, batch);\n    }\n    batch.push({ x, y, radius });\n  }\n\n  drawCircleOutline(x: number, y: number, radius: number, color: string, lineWidth: number = 2): void {\n    let batch = this.outlineBatches.get(color);\n    if (!batch) {\n      batch = [];\n      this.outlineBatches.set(color, batch);\n    }\n    batch.push({ x, y, radius, lineWidth });\n  }\n\n  // Must be called once per frame after all entities rendered\n  flushBatches(): void {\n    const ctx = this.ctx;\n    \n    ctx.fillStyle = '';\n    this.circleBatches.forEach((batch, color) => {\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      for (let i = 0; i < batch.length; i++) {\n        const c = batch[i];\n        ctx.moveTo(c.x + c.radius, c.y);\n        ctx.arc(c.x, c.y, c.radius, 0, Renderer.TWO_PI);\n      }\n      ctx.fill();\n    });\n    this.circleBatches.clear();\n    \n    ctx.strokeStyle = '';\n    this.outlineBatches.forEach((batch, color) => {\n      const byWidth = new Map<number, CircleOutlineBatch[]>();\n      for (let i = 0; i < batch.length; i++) {\n        const o = batch[i];\n        let group = byWidth.get(o.lineWidth);\n        if (!group) {\n          group = [];\n          byWidth.set(o.lineWidth, group);\n        }\n        group.push(o);\n      }\n      \n      byWidth.forEach((group, lineWidth) => {\n        ctx.strokeStyle = color;\n        ctx.lineWidth = lineWidth;\n        ctx.beginPath();\n        for (let i = 0; i < group.length; i++) {\n          const o = group[i];\n          ctx.moveTo(o.x + o.radius, o.y);\n          ctx.arc(o.x, o.y, o.radius, 0, Renderer.TWO_PI);\n        }\n        ctx.stroke();\n      });\n    });\n    this.outlineBatches.clear();\n  }\n\n  drawCircleImmediate(x: number, y: number, radius: number, color: string): void {\n    this.ctx.fillStyle = color;\n    this.ctx.beginPath();\n    this.ctx.arc(x, y, radius, 0, Renderer.TWO_PI);\n    this.ctx.fill();\n  }\n\n  drawLine(x1: number, y1: number, x2: number, y2: number, color: string, width: number = 2): void {\n    this.ctx.beginPath();\n    this.ctx.moveTo(x1, y1);\n    this.ctx.lineTo(x2, y2);\n    this.ctx.strokeStyle = color;\n    this.ctx.lineWidth = width;\n    this.ctx.stroke();\n  }\n\n  drawArrow(x: number, y: number, angle: number, length: number, color: string = '#00CC00'): void {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const endX = x + cos * length;\n    const endY = y + sin * length;\n    \n    const ctx = this.ctx;\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 3;\n    \n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n    \n    const headLength = 8;\n    const headAngle = Math.PI / 6;\n    \n    ctx.beginPath();\n    ctx.moveTo(endX, endY);\n    ctx.lineTo(\n      endX - headLength * Math.cos(angle - headAngle),\n      endY - headLength * Math.sin(angle - headAngle)\n    );\n    ctx.moveTo(endX, endY);\n    ctx.lineTo(\n      endX - headLength * Math.cos(angle + headAngle),\n      endY - headLength * Math.sin(angle + headAngle)\n    );\n    ctx.stroke();\n  }\n\n  drawRect(x: number, y: number, width: number, height: number, color: string): void {\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(x, y, width, height);\n  }\n\n  drawText(text: string, x: number, y: number, color: string = '#FFFFFF', fontSize: number = 16): void {\n    this.ctx.font = `${fontSize}px Arial`;\n    this.ctx.fillStyle = color;\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(text, x, y);\n  }\n\n  drawTextLeft(text: string, x: number, y: number, color: string = '#FFFFFF', fontSize: number = 16): void {\n    this.ctx.font = `${fontSize}px Arial`;\n    this.ctx.fillStyle = color;\n    this.ctx.textAlign = 'left';\n    this.ctx.textBaseline = 'top';\n    this.ctx.fillText(text, x, y);\n  }\n\n  drawPolygon(points: { x: number; y: number }[], color: string): void {\n    if (points.length < 3) return;\n    \n    const ctx = this.ctx;\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      ctx.lineTo(points[i].x, points[i].y);\n    }\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  getContext(): CanvasRenderingContext2D {\n    return this.ctx;\n  }\n}\n","export const PLAYER_VISUAL_RADIUS = 10;\nexport const PLAYER_HITBOX_RADIUS = PLAYER_VISUAL_RADIUS * 0.5;\nexport const PLAYER_MAX_SPEED = 1200;\nexport const PLAYER_ARROW_LENGTH = 15;\n\nexport const DOT_RADIUS = 8;\nexport const DOT_SPAWN_ANIMATION_DURATION = 1000;\nexport const DOT_SPAWN_SCALE_MAX = 1.5;\n\nexport const WEAPON_ORB_RADIUS = 20;\nexport const WEAPON_ORB_COUNT = 3;\nexport const WEAPON_ORB_MIN_SPACING = 100;\n\nexport const WRAP_ENABLED = true;\n\nexport const SCORE_KILL = 10;\nexport const SCORE_PATTERN_BONUS_MIN = 50;\nexport const SCORE_PATTERN_BONUS_MAX = 200;\nexport const SCORE_TIME_DIVISOR = 10;\n\nexport const DIFFICULTY_EASY_MAX_SCORE = 500;\nexport const DIFFICULTY_MEDIUM_MAX_SCORE = 1500;\n\nexport const PATTERN_SELECTION_INTERVAL = 8000;\n\nexport const COLOR_PLAYER = '#00FF00';\nexport const COLOR_PLAYER_ARROW = '#00CC00';\nexport const COLOR_DOT = '#FF0000';\nexport const COLOR_DOT_SPAWNING = '#FF6666';\nexport const COLOR_DOT_FROZEN = '#00FFFF';\nexport const COLOR_BACKGROUND = '#000000';\n\nexport const WEAPON_COLORS: Record<string, string> = {\n  KINETIC_BOMB: '#FF6600',\n  BLASTER: '#9900FF',\n  ICE_BOMB: '#00CCFF',\n  HOMING_MISSILE: '#FFFF00',\n  NUCLEAR_BOMB: '#FF0000',\n  ELECTRIC_BOMB: '#00FFFF',\n  DOT_REPELLENT: '#808080',\n  CHAINSAW: '#0066FF',\n  FLAME_BURST: '#FF9900',\n  TRIPLE_CANNON: '#FF00FF',\n  FIREBALL_ORB: '#FF4500',\n  TESLA_CANNON: '#00CCFF'\n};\n\nexport const TARGET_FPS = 60;\nexport const FRAME_TIME = 1000 / TARGET_FPS;\n","import { Vector2 } from '../types';\nimport { PLAYER_MAX_SPEED } from '../utils/constants';\n\nexport type PermissionState = 'unknown' | 'pending' | 'granted' | 'denied';\n\ninterface TiltBasis {\n  gamma: number;\n  beta: number;\n}\n\nexport class InputManager {\n  private velocity: Vector2 = { x: 0, y: 0 };\n  private permissionState: PermissionState = 'unknown';\n  private tiltBasis: TiltBasis | null = null;\n\n  constructor() {\n    this.checkPermissionAvailability();\n    this.trackScreenOrientation();\n  }\n\n  private trackScreenOrientation(): void {\n    window.addEventListener('orientationchange', () => {});\n  }\n\n  setTiltBasis(basis: TiltBasis): void {\n    this.tiltBasis = basis;\n  }\n\n  getCurrentTiltBasis(): TiltBasis | null {\n    return this.tiltBasis;\n  }\n\n  private checkPermissionAvailability(): void {\n    if (typeof (DeviceOrientationEvent as any).requestPermission === 'function') {\n      this.permissionState = 'pending';\n    } else if (window.DeviceOrientationEvent) {\n      this.permissionState = 'granted';\n      this.enableDeviceOrientation();\n    } else {\n      this.permissionState = 'denied';\n    }\n  }\n\n  async requestPermission(): Promise<boolean> {\n    if (this.permissionState === 'granted') {\n      return true;\n    }\n\n    if (typeof (DeviceOrientationEvent as any).requestPermission === 'function') {\n      try {\n        const permissionPromise = (DeviceOrientationEvent as any).requestPermission() as Promise<'granted' | 'denied' | 'prompt'>;\n        const permission = await permissionPromise;\n\n        if (permission === 'granted') {\n          this.permissionState = 'granted';\n          this.enableDeviceOrientation();\n          return true;\n        } else {\n          this.permissionState = 'denied';\n          return false;\n        }\n      } catch (error) {\n        console.error('Device orientation permission error:', error);\n        this.permissionState = 'denied';\n        return false;\n      }\n    }\n\n    return (this.permissionState as PermissionState) === 'granted';\n  }\n\n  private enableDeviceOrientation(): void {\n    window.addEventListener('deviceorientation', this.handleOrientation.bind(this));\n  }\n\n  private lastTilt: TiltBasis = { gamma: 0, beta: 45 };\n\n  calibrateTiltBasis(): void {\n    this.tiltBasis = { ...this.lastTilt };\n  }\n\n  private getScreenOrientation(): number {\n    if (screen.orientation) {\n      return screen.orientation.angle;\n    }\n    return 0;\n  }\n\n  private transformTiltToGameCoords(gamma: number, beta: number, orientation: number): { x: number; y: number } {\n    const tiltX = gamma;\n    const tiltY = beta - 45;\n    \n    switch (orientation) {\n      case 0:\n        return { x: tiltX, y: tiltY };\n      case 90:\n      case -270:\n        return { x: -tiltY, y: tiltX };\n      case 180:\n      case -180:\n        return { x: -tiltX, y: -tiltY };\n      case -90:\n      case 270:\n        return { x: tiltY, y: -tiltX };\n      default:\n        return { x: tiltX, y: tiltY };\n    }\n  }\n\n  private handleOrientation(event: DeviceOrientationEvent): void {\n    if (event.gamma === null || event.beta === null) {\n      return;\n    }\n    \n    const gamma = event.gamma;\n    const beta = event.beta;\n    this.lastTilt = { gamma, beta };\n    \n    const orientation = this.getScreenOrientation();\n    const reference = this.tiltBasis;\n    \n    let gammaDelta = gamma;\n    let betaDelta = beta - 45;\n    \n    if (reference !== null) {\n      gammaDelta = gamma - reference.gamma;\n      betaDelta = (beta - 45) - (reference.beta - 45);\n    }\n    \n    const gameCoords = this.transformTiltToGameCoords(gammaDelta, betaDelta + 45, orientation);\n    \n    const normalizedX = this.clamp(gameCoords.x / 35, -1, 1);\n    const normalizedY = this.clamp(gameCoords.y / 35, -1, 1);\n    \n    this.velocity.x = normalizedX * PLAYER_MAX_SPEED;\n    this.velocity.y = normalizedY * PLAYER_MAX_SPEED;\n  }\n\n  private clamp(value: number, min: number, max: number): number {\n    return Math.max(min, Math.min(max, value));\n  }\n\n  getVelocity(): Vector2 {\n    return { x: this.velocity.x, y: this.velocity.y };\n  }\n\n  getPermissionState(): PermissionState {\n    return this.permissionState;\n  }\n\n  needsPermissionRequest(): boolean {\n    return this.permissionState === 'pending';\n  }\n\n  destroy(): void {\n    window.removeEventListener('deviceorientation', this.handleOrientation.bind(this));\n  }\n}\n","import { Vector2, Bounds } from '../types';\n\nexport class Vec2 implements Vector2 {\n  constructor(public x: number = 0, public y: number = 0) {}\n\n  static from(v: Vector2): Vec2 {\n    return new Vec2(v.x, v.y);\n  }\n\n  add(other: Vector2): Vec2 {\n    return new Vec2(this.x + other.x, this.y + other.y);\n  }\n\n  subtract(other: Vector2): Vec2 {\n    return new Vec2(this.x - other.x, this.y - other.y);\n  }\n\n  multiply(scalar: number): Vec2 {\n    return new Vec2(this.x * scalar, this.y * scalar);\n  }\n\n  divide(scalar: number): Vec2 {\n    if (scalar === 0) throw new Error('Division by zero');\n    return new Vec2(this.x / scalar, this.y / scalar);\n  }\n\n  magnitude(): number {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  normalize(): Vec2 {\n    const mag = this.magnitude();\n    if (mag === 0) return new Vec2(0, 0);\n    return this.divide(mag);\n  }\n\n  dot(other: Vector2): number {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  angleTo(other: Vector2): number {\n    return Math.atan2(other.y - this.y, other.x - this.x);\n  }\n\n  clone(): Vec2 {\n    return new Vec2(this.x, this.y);\n  }\n\n  set(x: number, y: number): void {\n    this.x = x;\n    this.y = y;\n  }\n\n  addInPlace(other: Vector2): void {\n    this.x += other.x;\n    this.y += other.y;\n  }\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value));\n}\n\nexport function distance(a: Vector2, b: Vector2): number {\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function wrap(position: Vector2, bounds: Bounds): Vector2 {\n  let x = position.x;\n  let y = position.y;\n  if (bounds.width > 0 && bounds.height > 0) {\n    while (x < 0) x += bounds.width;\n    while (y < 0) y += bounds.height;\n    x = x % bounds.width;\n    y = y % bounds.height;\n  }\n  return { x, y };\n}\n\nexport function wrapInPlace(position: Vector2, bounds: Bounds): void {\n  if (bounds.width > 0 && bounds.height > 0) {\n    while (position.x < 0) position.x += bounds.width;\n    while (position.y < 0) position.y += bounds.height;\n    position.x = position.x % bounds.width;\n    position.y = position.y % bounds.height;\n  }\n}\n\nexport function circleCollision(\n  a: Vector2,\n  radiusA: number,\n  b: Vector2,\n  radiusB: number\n): boolean {\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  const distanceSq = dx * dx + dy * dy;\n  const radiiSum = radiusA + radiusB;\n  return distanceSq < radiiSum * radiiSum;\n}\n\nexport function lerp(a: number, b: number, t: number): number {\n  return a + (b - a) * t;\n}\n\nexport function randomRange(min: number, max: number): number {\n  return min + Math.random() * (max - min);\n}\n\nexport function randomPosition(bounds: Bounds, margin: number = 0): Vector2 {\n  return {\n    x: margin + Math.random() * (bounds.width - margin * 2),\n    y: margin + Math.random() * (bounds.height - margin * 2)\n  };\n}\n","import { Vector2, Bounds } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { Vec2, wrapInPlace } from '../utils/math';\nimport { PLAYER_HITBOX_RADIUS, PLAYER_VISUAL_RADIUS, PLAYER_ARROW_LENGTH, COLOR_PLAYER, COLOR_PLAYER_ARROW } from '../utils/constants';\n\nexport class Player {\n  position: Vec2;\n  velocity: Vector2 = { x: 0, y: 0 };\n  directionAngle: number = 0;\n  readonly hitboxRadius: number = PLAYER_HITBOX_RADIUS;\n\n  constructor(x: number, y: number) {\n    this.position = new Vec2(x, y);\n  }\n\n  update(dt: number, inputVelocity: Vector2, bounds: Bounds, shouldWrap: boolean = true): void {\n    this.velocity.x = inputVelocity.x;\n    this.velocity.y = inputVelocity.y;\n    \n    if (this.velocity.x !== 0 || this.velocity.y !== 0) {\n      this.directionAngle = Math.atan2(this.velocity.y, this.velocity.x);\n    }\n    \n    this.position.x += this.velocity.x * dt;\n    this.position.y += this.velocity.y * dt;\n    \n    if (shouldWrap) {\n      wrapInPlace(this.position, bounds);\n    } else {\n      this.position.x = Math.max(0, Math.min(bounds.width, this.position.x));\n      this.position.y = Math.max(0, Math.min(bounds.height, this.position.y));\n    }\n  }\n\n  setPosition(x: number, y: number): void {\n    this.position.x = x;\n    this.position.y = y;\n  }\n\n  render(renderer: Renderer): void {\n    renderer.drawCircleImmediate(\n      this.position.x,\n      this.position.y,\n      PLAYER_VISUAL_RADIUS,\n      COLOR_PLAYER\n    );\n    \n    const arrowStartX = this.position.x + Math.cos(this.directionAngle) * (PLAYER_VISUAL_RADIUS + 2);\n    const arrowStartY = this.position.y + Math.sin(this.directionAngle) * (PLAYER_VISUAL_RADIUS + 2);\n    \n    renderer.drawArrow(\n      arrowStartX,\n      arrowStartY,\n      this.directionAngle,\n      PLAYER_ARROW_LENGTH,\n      COLOR_PLAYER_ARROW\n    );\n  }\n\n  getPosition(): Vector2 {\n    return this.position;\n  }\n}\n","export class ScoringSystem {\n  private score: number = 0;\n  private kills: number = 0;\n  private startTime: number = 0;\n\n  start(): void {\n    this.score = 0;\n    this.kills = 0;\n    this.startTime = Date.now();\n  }\n\n  addKill(): void {\n    this.kills++;\n  }\n\n  addKills(count: number): void {\n    this.kills += count;\n  }\n\n  addPatternBonus(difficulty: string): void {\n    const bonuses = { EASY: 50, MEDIUM: 100, HARD: 200 };\n    this.score += bonuses[difficulty as keyof typeof bonuses] || 50;\n  }\n\n  getScore(): number {\n    const timeBonus = Math.floor((Date.now() - this.startTime) / 10000);\n    return this.score + this.kills * 10 + timeBonus;\n  }\n\n  getKills(): number {\n    return this.kills;\n  }\n\n  getTimeAlive(): number {\n    return Date.now() - this.startTime;\n  }\n}\n","import { Bounds } from '../types';\nimport { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponOrb } from '../entities/WeaponOrb';\nimport { circleCollision } from '../utils/math';\n\nconst CELL_SIZE = 100;\n\n// Pre-allocated array for nearby cell offsets - avoids allocation during collision checks\nconst NEARBY_OFFSETS = [\n  [-1, -1], [0, -1], [1, -1],\n  [-1, 0], [0, 0], [1, 0],\n  [-1, 1], [0, 1], [1, 1]\n];\n\nexport class CollisionSystem {\n  // Use numeric key instead of string to avoid allocations\n  private grid: Map<number, Dot[]> = new Map();\n  \n  // Pre-allocated array for nearby keys - reused each frame\n  private nearbyKeys: number[] = new Array(9);\n\n  constructor(_bounds: Bounds) {\n  }\n  \n  // Use numeric key: cellX * 10000 + cellY (assumes grid < 10000 cells wide)\n  private getCellKey(x: number, y: number): number {\n    const cellX = Math.floor(x / CELL_SIZE);\n    const cellY = Math.floor(y / CELL_SIZE);\n    return cellX * 10000 + cellY;\n  }\n  \n  private getNearbyKeys(x: number, y: number): number[] {\n    const cellX = Math.floor(x / CELL_SIZE);\n    const cellY = Math.floor(y / CELL_SIZE);\n    \n    for (let i = 0; i < 9; i++) {\n      const [dx, dy] = NEARBY_OFFSETS[i];\n      this.nearbyKeys[i] = (cellX + dx) * 10000 + (cellY + dy);\n    }\n    return this.nearbyKeys;\n  }\n  \n  rebuildGrid(dots: Dot[]): void {\n    // Clear and reuse map instead of creating new one\n    this.grid.clear();\n\n    for (let i = 0; i < dots.length; i++) {\n      const dot = dots[i];\n      if (!dot.isLethal() && !dot.isFrozen()) continue;\n\n      const pos = dot.getPosition();\n      const key = this.getCellKey(pos.x, pos.y);\n\n      let cell = this.grid.get(key);\n      if (!cell) {\n        cell = [];\n        this.grid.set(key, cell);\n      }\n\n      cell.push(dot);\n    }\n  }\n  \n  checkPlayerDotCollision(player: Player): Dot | null {\n    const playerPos = player.getPosition();\n    const playerRadius = player.hitboxRadius;\n    \n    const nearbyKeys = this.getNearbyKeys(playerPos.x, playerPos.y);\n    \n    for (let i = 0; i < 9; i++) {\n      const cell = this.grid.get(nearbyKeys[i]);\n      if (!cell) continue;\n      \n      for (let j = 0; j < cell.length; j++) {\n        const dot = cell[j];\n        const dotPos = dot.getPosition();\n        const dotRadius = dot.getEffectiveRadius();\n\n        if (circleCollision(playerPos, playerRadius, dotPos, dotRadius)) {\n          return dot;\n        }\n      }\n    }\n    \n    return null;\n  }\n  \n  checkPlayerOrbCollision(player: Player, orbs: WeaponOrb[]): WeaponOrb | null {\n    const playerPos = player.getPosition();\n    const playerRadius = player.hitboxRadius;\n    \n    for (let i = 0; i < orbs.length; i++) {\n      const orb = orbs[i];\n      if (!orb.isActive()) continue;\n      \n      const orbPos = orb.getPosition();\n      const orbRadius = orb.radius;\n      \n      if (circleCollision(playerPos, playerRadius, orbPos, orbRadius)) {\n        return orb;\n      }\n    }\n    \n    return null;\n  }\n\n  updateBounds(_bounds: Bounds): void {\n  }\n}\n","import { PatternType } from '../types';\nimport type { Pattern } from './Pattern';\n\ntype PatternConstructor = new () => Pattern;\n\nclass PatternRegistryImpl {\n  private patterns: Map<PatternType, PatternConstructor> = new Map();\n\n  register(type: PatternType, patternClass: PatternConstructor): void {\n    this.patterns.set(type, patternClass);\n  }\n\n  create(type: PatternType): Pattern | null {\n    const PatternClass = this.patterns.get(type);\n    if (!PatternClass) return null;\n    return new PatternClass();\n  }\n\n  getAvailableTypes(): PatternType[] {\n    return Array.from(this.patterns.keys());\n  }\n}\n\nexport const PatternRegistry = new PatternRegistryImpl();\n","import { Pattern } from '../patterns/Pattern';\nimport { PatternType, Bounds, Vector2 } from '../types';\nimport { PatternRegistry } from '../patterns/PatternRegistry';\nimport { Dot } from '../entities/Dot';\nimport type { GameEventLogger } from './GameEventLogger';\n// Score-based interval scaling\n// Base interval (ms) at score 0\nconst BASE_INTERVAL = 4000;\n// Minimum interval (ms) at high scores\nconst MIN_INTERVAL = 1500;\n// Score at which minimum interval is reached\nconst MAX_SCORE_SCALING = 5000;\n\nexport class PatternManager {\n  private activePatterns: Pattern[] = [];\n  private patternTimer: number = 0;\n  private nextPatternInterval: number = 3000;\n  private currentScore: number = 0;\n  private allDotsCache: Dot[] = [];\n  private eventLogger: GameEventLogger | null = null;\n  constructor() {\n    this.nextPatternInterval = this.getRandomInterval();\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    this.patternTimer += dt * 1000;\n    if (this.patternTimer >= this.nextPatternInterval) {\n      this.patternTimer = 0;\n      this.nextPatternInterval = this.getRandomInterval();\n      const nextType = this.selectNextPattern();\n      if (nextType) {\n        this.spawnPattern(nextType, playerPosition, bounds);\n      }\n    }\n\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      const pattern = this.activePatterns[i];\n      pattern.tick(dt);\n      pattern.update(dt, playerPosition, bounds);\n    }\n\n    this.removeCompletedPatterns();\n    this.rebuildDotsCache();\n  }\n\n  addPattern(pattern: Pattern): void {\n    if (this.isPatternTypeActive(pattern.type)) {\n      return;\n    }\n    this.activePatterns.push(pattern);\n  }\n\n  removePattern(pattern: Pattern): void {\n    const index = this.activePatterns.indexOf(pattern);\n    if (index !== -1) {\n      pattern.clear();\n      this.activePatterns.splice(index, 1);\n    }\n  }\n\n  getActivePatterns(): Pattern[] {\n    return this.activePatterns;\n  }\n\n  getAllDots(): Dot[] {\n    return this.allDotsCache;\n  }\n\n  setEventLogger(logger: GameEventLogger): void {\n    this.eventLogger = logger;\n  }\n  isAnyPatternActivelySpawning(): boolean {\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      if (this.activePatterns[i].isActivelySpawning()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private rebuildDotsCache(): void {\n    this.allDotsCache.length = 0;\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      const dots = this.activePatterns[i].getDots();\n      for (let j = 0; j < dots.length; j++) {\n        this.allDotsCache.push(dots[j]);\n      }\n    }\n  }\n\n  setScore(score: number): void {\n    this.currentScore = score;\n  }\n\n  selectNextPattern(): PatternType | null {\n    const allTypes = PatternRegistry.getAvailableTypes();\n    \n    const candidateTypes = allTypes.filter(\n      type => !this.isPatternTypeActive(type)\n    );\n\n    if (candidateTypes.length === 0) {\n      return null;\n    }\n\n    const randomIndex = Math.floor(Math.random() * candidateTypes.length);\n    return candidateTypes[randomIndex];\n  }\n\n  spawnPattern(type: PatternType, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.isPatternTypeActive(type)) {\n      return;\n    }\n\n    const pattern = PatternRegistry.create(type);\n    if (!pattern) {\n      console.warn(`Failed to create pattern of type: ${type}`);\n      return;\n    }\n\n    pattern.spawn(playerPosition, bounds);\n    pattern.start();\n    this.activePatterns.push(pattern);\n    if (this.eventLogger) {\n      this.eventLogger.logPatternSpawnStart(type);\n    }\n  }\n\n  private isPatternTypeActive(type: PatternType): boolean {\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      if (this.activePatterns[i].type === type) return true;\n    }\n    return false;\n  }\n\n  private removeCompletedPatterns(): void {\n    for (let i = this.activePatterns.length - 1; i >= 0; i--) {\n      if (this.activePatterns[i].isComplete()) {\n        const completedPattern = this.activePatterns[i];\n        if (this.eventLogger) {\n          this.eventLogger.logPatternSpawnComplete(completedPattern.type, completedPattern.getDots().length);\n        }\n        completedPattern.clear();\n        this.activePatterns.splice(i, 1);\n\n      }\n    }\n  }\n\n  clear(): void {\n    for (let i = 0; i < this.activePatterns.length; i++) {\n      this.activePatterns[i].clear();\n    }\n    this.activePatterns = [];\n    this.patternTimer = 0;\n    this.allDotsCache.length = 0;\n  }\n\n  getPatternTimer(): number {\n    return this.patternTimer;\n  }\n\n  getPatternInterval(): number {\n    return this.nextPatternInterval;\n  }\n\n  private getRandomInterval(): number {\n    // Scale interval based on score - higher score = shorter interval\n    const scoreRatio = Math.min(this.currentScore / MAX_SCORE_SCALING, 1);\n    const interval = BASE_INTERVAL - scoreRatio * (BASE_INTERVAL - MIN_INTERVAL);\n    // Add small random variance (+/- 500ms)\n    return interval + (Math.random() - 0.5) * 1000;\n  }\n\n}\n","import { Vector2 } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { WeaponType } from '../types';\nimport { WEAPON_ORB_RADIUS, WEAPON_COLORS } from '../utils/constants';\n\nexport class WeaponOrb {\n  position: Vector2;\n  weaponType: WeaponType;\n  pickedUp: boolean = false;\n  readonly radius: number = WEAPON_ORB_RADIUS;\n\n  // Weapons that bounce when collided with\n  private static readonly BOUNCED_WEAPONS: WeaponType[] = [\n    WeaponType.NUCLEAR_BOMB,\n    WeaponType.ELECTRIC_BOMB,\n    WeaponType.FIREBALL_ORB\n  ];\n\n  // Bounce physics state for bounced weapons\n  private velocity: Vector2 = { x: 0, y: 0 };\n  private lastBounceTime: number = 0;\n  private readonly bounceCooldown: number = 100;\n\n  constructor(x: number, y: number, weaponType: WeaponType) {\n    this.position = { x, y };\n    this.weaponType = weaponType;\n  }\n\n  render(renderer: Renderer): void {\n    if (this.pickedUp) return;\n\n    const color = WEAPON_COLORS[this.weaponType] || '#FFFFFF';\n\n    renderer.drawCircleImmediate(\n      this.position.x,\n      this.position.y,\n      this.radius,\n      color\n    );\n\n    const isBouncedWeapon = WeaponOrb.BOUNCED_WEAPONS.includes(this.weaponType);\n    const borderColor = isBouncedWeapon ? '#9B30FF' : '#FFFFFF';\n\n    const ctx = renderer.getContext();\n    ctx.strokeStyle = borderColor;\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.arc(this.position.x, this.position.y, this.radius + 2, 0, Math.PI * 2);\n    ctx.stroke();\n\n    this.drawIcon(ctx, this.position.x, this.position.y, this.radius);\n  }\n\n  private drawIcon(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number): void {\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n    ctx.fillStyle = '#FFFFFF';\n\n    const iconScale = radius * 0.5;\n\n    switch (this.weaponType) {\n      case WeaponType.KINETIC_BOMB:\n        this.drawKineticBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.BLASTER:\n        this.drawBlasterIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.ICE_BOMB:\n        this.drawIceBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.HOMING_MISSILE:\n        this.drawHomingMissileIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.NUCLEAR_BOMB:\n        this.drawNuclearBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.ELECTRIC_BOMB:\n        this.drawElectricBombIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.DOT_REPELLENT:\n        this.drawDotRepellentIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.CHAINSAW:\n        this.drawChainsawIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.FLAME_BURST:\n        this.drawFlameBurstIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.TRIPLE_CANNON:\n        this.drawTripleCannonIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.FIREBALL_ORB:\n        this.drawFireballOrbIcon(ctx, x, y, iconScale);\n        break;\n      case WeaponType.TESLA_CANNON:\n        this.drawTeslaCannonIcon(ctx, x, y, iconScale);\n        break;\n    }\n  }\n\n  private drawKineticBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.3, 0, Math.PI * 2);\n    ctx.fill();\n\n    for (let i = 0; i < 8; i++) {\n      const angle = (i / 8) * Math.PI * 2;\n      ctx.beginPath();\n      ctx.moveTo(x + Math.cos(angle) * scale * 0.4, y + Math.sin(angle) * scale * 0.4);\n      ctx.lineTo(x + Math.cos(angle) * scale * 0.8, y + Math.sin(angle) * scale * 0.8);\n      ctx.stroke();\n    }\n  }\n\n  private drawBlasterIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.fillRect(x - scale * 0.8, y - scale * 0.15, scale * 1.6, scale * 0.3);\n    ctx.fillRect(x - scale * 0.9, y - scale * 0.4, scale * 0.3, scale * 0.8);\n    ctx.fillRect(x + scale * 0.6, y - scale * 0.4, scale * 0.3, scale * 0.8);\n  }\n\n  private drawIceBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    for (let i = 0; i < 6; i++) {\n      const angle = (i / 6) * Math.PI * 2;\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(angle) * scale * 0.8, y + Math.sin(angle) * scale * 0.8);\n      ctx.stroke();\n      const branchX = x + Math.cos(angle) * scale * 0.5;\n      const branchY = y + Math.sin(angle) * scale * 0.5;\n      ctx.beginPath();\n      ctx.moveTo(branchX, branchY);\n      ctx.lineTo(branchX + Math.cos(angle + Math.PI / 4) * scale * 0.3, branchY + Math.sin(angle + Math.PI / 4) * scale * 0.3);\n      ctx.moveTo(branchX, branchY);\n      ctx.lineTo(branchX + Math.cos(angle - Math.PI / 4) * scale * 0.3, branchY + Math.sin(angle - Math.PI / 4) * scale * 0.3);\n      ctx.stroke();\n    }\n  }\n\n  private drawHomingMissileIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    const arrowSize = scale * 0.25;\n    const spacing = scale * 0.35;\n\n    for (let i = -1; i <= 1; i++) {\n      const arrowX = x + i * spacing;\n      const arrowY = y;\n      this.drawArrowUp(ctx, arrowX, arrowY, arrowSize);\n    }\n  }\n\n  private drawArrowUp(ctx: CanvasRenderingContext2D, x: number, y: number, size: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x, y - size);\n    ctx.lineTo(x - size * 0.5, y + size * 0.3);\n    ctx.lineTo(x + size * 0.5, y + size * 0.3);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private drawNuclearBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    const skullScale = scale * 0.7;\n\n    // Skull head (circle)\n    ctx.beginPath();\n    ctx.arc(x, y - skullScale * 0.1, skullScale * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Eye sockets (two black circles)\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.arc(x - skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(x + skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Nose (inverted triangle)\n    ctx.beginPath();\n    ctx.moveTo(x, y + skullScale * 0.05);\n    ctx.lineTo(x - skullScale * 0.08, y + skullScale * 0.2);\n    ctx.lineTo(x + skullScale * 0.08, y + skullScale * 0.2);\n    ctx.closePath();\n    ctx.fill();\n\n    // Jaw / teeth area\n    ctx.fillStyle = '#FFFFFF';\n    ctx.beginPath();\n    ctx.rect(x - skullScale * 0.25, y + skullScale * 0.25, skullScale * 0.5, skullScale * 0.2);\n    ctx.fill();\n\n    // Teeth lines\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 1.5;\n    for (let i = 1; i <= 2; i++) {\n      const teethX = x - skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX, y + skullScale * 0.25);\n      ctx.lineTo(teethX, y + skullScale * 0.45);\n      ctx.stroke();\n\n      const teethX2 = x + skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX2, y + skullScale * 0.25);\n      ctx.lineTo(teethX2, y + skullScale * 0.45);\n      ctx.stroke();\n    }\n\n    // Crossbones (X shape behind skull)\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 3;\n    ctx.lineCap = 'round';\n\n    // Bone 1 (backslash)\n    ctx.beginPath();\n    ctx.moveTo(x - skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x + skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    // Bone 2 (forward slash)\n    ctx.beginPath();\n    ctx.moveTo(x + skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x - skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    // Bone ends (small circles at ends of bones)\n    ctx.fillStyle = '#FFFFFF';\n    const boneEndRadius = skullScale * 0.1;\n    const boneEnds = [\n      { x: x - skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y + skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x - skullScale * 0.7, y: y + skullScale * 0.5 }\n    ];\n\n    for (const end of boneEnds) {\n      ctx.beginPath();\n      ctx.arc(end.x, end.y, boneEndRadius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  private drawElectricBombIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x + scale * 0.2, y - scale * 0.8);\n    ctx.lineTo(x - scale * 0.1, y - scale * 0.1);\n    ctx.lineTo(x + scale * 0.3, y - scale * 0.1);\n    ctx.lineTo(x - scale * 0.2, y + scale * 0.8);\n    ctx.lineTo(x, y + scale * 0.1);\n    ctx.lineTo(x - scale * 0.3, y + scale * 0.1);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private drawDotRepellentIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.3, 0, Math.PI * 2);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.6, 0, Math.PI * 2);\n    ctx.stroke();\n\n    for (let i = 0; i < 4; i++) {\n      const angle = (i / 4) * Math.PI * 2;\n      this.drawOutwardArrow(ctx, x, y, angle, scale);\n    }\n  }\n\n  private drawOutwardArrow(ctx: CanvasRenderingContext2D, x: number, y: number, angle: number, scale: number): void {\n    const arrowX = x + Math.cos(angle) * scale * 0.45;\n    const arrowY = y + Math.sin(angle) * scale * 0.45;\n    const size = scale * 0.2;\n\n    ctx.beginPath();\n    ctx.moveTo(arrowX + Math.cos(angle) * size, arrowY + Math.sin(angle) * size);\n    ctx.lineTo(arrowX + Math.cos(angle + 2.5) * size, arrowY + Math.sin(angle + 2.5) * size);\n    ctx.lineTo(arrowX + Math.cos(angle - 2.5) * size, arrowY + Math.sin(angle - 2.5) * size);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private drawChainsawIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.5, 0, Math.PI * 2);\n    ctx.stroke();\n\n    const numTeeth = 8;\n    for (let i = 0; i < numTeeth; i++) {\n      const angle = (i / numTeeth) * Math.PI * 2;\n      const innerR = scale * 0.5;\n      const outerR = scale * 0.7;\n      ctx.beginPath();\n      ctx.moveTo(x + Math.cos(angle - 0.15) * innerR, y + Math.sin(angle - 0.15) * innerR);\n      ctx.lineTo(x + Math.cos(angle) * outerR, y + Math.sin(angle) * outerR);\n      ctx.lineTo(x + Math.cos(angle + 0.15) * innerR, y + Math.sin(angle + 0.15) * innerR);\n      ctx.fill();\n    }\n\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  private drawFlameBurstIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x, y - scale * 0.8);\n    ctx.bezierCurveTo(\n      x - scale * 0.4, y - scale * 0.3,\n      x - scale * 0.6, y + scale * 0.2,\n      x - scale * 0.2, y + scale * 0.6\n    );\n    ctx.quadraticCurveTo(x, y + scale * 0.8, x + scale * 0.2, y + scale * 0.6);\n    ctx.bezierCurveTo(\n      x + scale * 0.6, y + scale * 0.2,\n      x + scale * 0.4, y - scale * 0.3,\n      x, y - scale * 0.8\n    );\n    ctx.fill();\n\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n    ctx.beginPath();\n    ctx.moveTo(x, y - scale * 0.4);\n    ctx.bezierCurveTo(\n      x - scale * 0.2, y,\n      x - scale * 0.3, y + scale * 0.3,\n      x, y + scale * 0.5\n    );\n    ctx.bezierCurveTo(\n      x + scale * 0.3, y + scale * 0.3,\n      x + scale * 0.2, y,\n      x, y - scale * 0.4\n    );\n    ctx.fill();\n  }\n  private drawTripleCannonIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    const bulletRadius = scale * 0.2;\n    const spacing = scale * 0.5;\n\n    for (let i = -1; i <= 1; i++) {\n      const bulletX = x + i * spacing;\n      ctx.beginPath();\n      ctx.arc(bulletX, y, bulletRadius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  private drawFireballOrbIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.beginPath();\n    ctx.arc(x, y, scale * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n\n    const flames = 5;\n    for (let i = 0; i < flames; i++) {\n      const angle = (i / flames) * Math.PI * 2 - Math.PI / 2;\n      const flameLen = scale * (0.5 + (i % 2) * 0.2);\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.quadraticCurveTo(\n        x + Math.cos(angle - 0.2) * flameLen * 0.5,\n        y + Math.sin(angle - 0.2) * flameLen * 0.5,\n        x + Math.cos(angle) * flameLen,\n        y + Math.sin(angle) * flameLen\n      );\n      ctx.quadraticCurveTo(\n        x + Math.cos(angle + 0.2) * flameLen * 0.5,\n        y + Math.sin(angle + 0.2) * flameLen * 0.5,\n        x, y\n      );\n      ctx.fill();\n    }\n  }\n\n  private drawTeslaCannonIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    const bulletRadius = scale * 0.15;\n    const spacing = scale * 0.4;\n\n    for (let i = -1; i <= 1; i++) {\n      const bulletX = x + i * spacing;\n      ctx.beginPath();\n      ctx.arc(bulletX, y, bulletRadius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(x, y + scale * 0.4);\n    ctx.lineTo(x, y + scale * 0.8);\n    ctx.stroke();\n  }\n\n  isCollidingWith(playerPosition: Vector2, playerRadius: number): boolean {\n    const dx = this.position.x - playerPosition.x;\n    const dy = this.position.y - playerPosition.y;\n    const distSq = dx * dx + dy * dy;\n    const radiiSum = this.radius + playerRadius;\n    return distSq < radiiSum * radiiSum;\n  }\n\n  getPosition(): Vector2 {\n    return this.position;\n  }\n\n  getWeaponType(): WeaponType {\n    return this.weaponType;\n  }\n\n  pickup(): void {\n    this.pickedUp = true;\n  }\n\n  isActive(): boolean {\n    return !this.pickedUp;\n  }\n\n\n  bounce(playerVelocity: Vector2, playerPosition: Vector2): boolean {\n    const now = Date.now();\n    if (now - this.lastBounceTime < this.bounceCooldown) {\n      return false;\n    }\n    this.lastBounceTime = now;\n\n    // Check if this is a bounced weapon\n    if (!WeaponOrb.BOUNCED_WEAPONS.includes(this.weaponType)) {\n      return false;\n    }\n\n    const dx = this.position.x - playerPosition.x;\n    const dy = this.position.y - playerPosition.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance === 0) {\n      this.velocity.x = playerVelocity.x;\n      this.velocity.y = playerVelocity.y;\n      return true;\n    }\n\n    // Collision normal (from player to orb center)\n    const nx = dx / distance;\n    const ny = dy / distance;\n\n    // Tangent vector (perpendicular to normal)\n    const tx = -ny;\n    const ty = nx;\n\n    // Decompose player velocity into normal and tangent components\n    const vDotN = playerVelocity.x * nx + playerVelocity.y * ny;\n    const vDotT = playerVelocity.x * tx + playerVelocity.y * ty;\n\n    // Transfer momentum: orb moves away based on collision angle\n    // - Normal component pushes orb away from player\n    // - Tangent component pushes orb sideways (creates the \"nudge\" effect)\n    const restitution = 0.8; // Energy transfer factor\n    const friction = 0.6;    // Tangential transfer factor\n\n    this.velocity.x = (nx * vDotN * restitution + tx * vDotT * friction);\n    this.velocity.y = (ny * vDotN * restitution + ty * vDotT * friction);\n\n    return true;\n  }\n\n  getVelocity(): Vector2 {\n    return this.velocity;\n  }\n\n  updatePosition(dt: number, bounds: { width: number; height: number }): void {\n    if (!WeaponOrb.BOUNCED_WEAPONS.includes(this.weaponType)) return;\n\n    this.position.x += this.velocity.x * dt;\n    this.position.y += this.velocity.y * dt;\n\n    const minX = this.radius;\n    const maxX = bounds.width - this.radius;\n    const minY = this.radius;\n    const maxY = bounds.height - this.radius;\n\n    if (this.position.x <= minX) {\n      this.velocity.x = Math.abs(this.velocity.x);\n      this.position.x = minX;\n    } else if (this.position.x >= maxX) {\n      this.velocity.x = -Math.abs(this.velocity.x);\n      this.position.x = maxX;\n    }\n\n    if (this.position.y <= minY) {\n      this.velocity.y = Math.abs(this.velocity.y);\n      this.position.y = minY;\n    } else if (this.position.y >= maxY) {\n      this.velocity.y = -Math.abs(this.velocity.y);\n      this.position.y = maxY;\n    }\n  }\n}\n","import { WeaponOrb } from '../entities/WeaponOrb';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport { WEAPON_ORB_RADIUS } from '../utils/constants';\n\nexport class WeaponOrbSpawner {\n  private orbs: WeaponOrb[] = [];\n  private readonly orbCount: number = 3;\n  private readonly minSpacing: number = 100;\n  private readonly playerAvoidRadius: number = 150;\n\n  initialize(bounds: Bounds, playerPosition: Vector2): void {\n    this.orbs = [];\n    for (let i = 0; i < this.orbCount; i++) {\n      this.spawnOrb(bounds, playerPosition);\n    }\n  }\n\n  update(bounds: Bounds, playerPosition: Vector2): void {\n    while (this.orbs.length < this.orbCount) {\n      this.spawnOrb(bounds, playerPosition);\n    }\n  }\n\n  getOrbs(): WeaponOrb[] {\n    return this.orbs;\n  }\n\n  removeOrb(orb: WeaponOrb): void {\n    const index = this.orbs.indexOf(orb);\n    if (index > -1) {\n      this.orbs.splice(index, 1);\n    }\n  }\n\n  spawnOrb(bounds: Bounds, playerPosition: Vector2): void {\n    const pos = this.getRandomPosition(bounds, playerPosition);\n    const type = this.getRandomWeaponType();\n    this.orbs.push(new WeaponOrb(pos.x, pos.y, type));\n  }\n\n  private getRandomPosition(bounds: Bounds, playerPosition: Vector2): Vector2 {\n    let attempts = 0;\n    while (attempts < 100) {\n      const x = WEAPON_ORB_RADIUS + Math.random() * (bounds.width - WEAPON_ORB_RADIUS * 2);\n      const y = WEAPON_ORB_RADIUS + Math.random() * (bounds.height - WEAPON_ORB_RADIUS * 2);\n\n      const dx = x - playerPosition.x;\n      const dy = y - playerPosition.y;\n      const playerDist = Math.sqrt(dx * dx + dy * dy);\n\n      if (playerDist >= this.playerAvoidRadius && this.isPositionValid({ x, y })) {\n        return { x, y };\n      }\n      attempts++;\n    }\n    return { x: bounds.width / 2, y: bounds.height / 2 };\n  }\n\n  private isPositionValid(pos: Vector2): boolean {\n    for (const orb of this.orbs) {\n      const dx = pos.x - orb.position.x;\n      const dy = pos.y - orb.position.y;\n      if (Math.sqrt(dx * dx + dy * dy) < this.minSpacing) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private getRandomWeaponType(): WeaponType {\n    const types = [\n      WeaponType.KINETIC_BOMB,\n      WeaponType.BLASTER,\n      WeaponType.ICE_BOMB,\n      WeaponType.HOMING_MISSILE,\n      WeaponType.NUCLEAR_BOMB,\n      WeaponType.ELECTRIC_BOMB,\n      WeaponType.DOT_REPELLENT,\n      WeaponType.CHAINSAW,\n      WeaponType.FLAME_BURST,\n      WeaponType.TRIPLE_CANNON,\n      WeaponType.FIREBALL_ORB,\n      WeaponType.TESLA_CANNON\n    ];\n    return types[Math.floor(Math.random() * types.length)];\n  }\n}\n","import { WeaponType } from '../types';\nimport type { Weapon } from './Weapon';\n\ntype WeaponConstructor = new () => Weapon;\n\nclass WeaponRegistryImpl {\n  private weapons: Map<WeaponType, WeaponConstructor> = new Map();\n\n  register(type: WeaponType, weaponClass: WeaponConstructor): void {\n    this.weapons.set(type, weaponClass);\n  }\n\n  create(type: WeaponType): Weapon | null {\n    const WeaponClass = this.weapons.get(type);\n    if (!WeaponClass) return null;\n    return new WeaponClass();\n  }\n\n  getAvailableTypes(): WeaponType[] {\n    return Array.from(this.weapons.keys());\n  }\n}\n\nexport const WeaponRegistry = new WeaponRegistryImpl();\n","import { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds } from '../types';\nimport type { Player } from '../entities/Player';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport abstract class Weapon {\n  abstract readonly type: WeaponType;\n\n  protected dots: Dot[] = [];\n  protected startTime: number = 0;\n  protected isStarted: boolean = false;\n  protected killedDots: number = 0;\n\n  abstract activate(player: Player, dots: Dot[], initialPosition?: { x: number; y: number }): void;\n  abstract update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void;\n  abstract render(renderer: Renderer): void;\n\n  // Handle collision with player (for bounceable weapons like Electric/Nuclear bomb)\n  // Returns true if collision was handled/bounced\n  handlePlayerCollision(_player: Player, _playerVelocity: { x: number; y: number }): boolean {\n    return false;\n  }\n\n  // Check if weapon is currently active (for collision detection)\n  isActive(): boolean {\n    return false;\n  }\n\n  // Get weapon position (for collision detection)\n  getPosition(): { x: number; y: number } {\n    return { x: 0, y: 0 };\n  }\n\n  // Get weapon radius (for collision detection)\n  getRadius(): number {\n    return 0;\n  }\n\n  getDots(): Dot[] {\n    return this.dots.filter(d => !d.isDead());\n  }\n\n  isComplete(): boolean {\n    return false;\n  }\n\n  start(): void {\n    this.startTime = Date.now();\n    this.isStarted = true;\n  }\n\n  getElapsedTime(): number {\n    return Date.now() - this.startTime;\n  }\n\n  clear(): void {\n    for (const dot of this.dots) {\n      dot.kill();\n    }\n    this.dots = [];\n  }\n\n  getKilledDots(): number {\n    return this.killedDots;\n  }\n\n  addKilledDot(): void {\n    this.killedDots++;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponOrb } from '../entities/WeaponOrb';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nimport { WEAPON_ORB_RADIUS } from '../utils/constants';\n\nexport class NuclearBomb extends Weapon {\n  readonly type = WeaponType.NUCLEAR_BOMB;\n\n  private state: 'DRIFTING' | 'EXPLODING' | 'COMPLETE' = 'DRIFTING';\n  private orbPosition: Vector2 = { x: 0, y: 0 };\n  private orbVelocity: Vector2 = { x: 0, y: 0 };\n  private readonly fuseTime: number = 1500;\n  private explosionRadius: number = 0;\n  private explosionStartTime: number = 0;\n  private killedDotsInExplosion: Set<Dot> = new Set();\n  private orbsToDestroy: Set<WeaponOrb> = new Set();\n  private orbs: WeaponOrb[] = [];\n  private _hasKilledPlayer: boolean = false;\n  private bounds: Bounds | null = null;\n\n  private readonly flashInterval: number = 100;\n  private readonly flashGap: number = 400;\n  private lastCollisionTime: number = 0;\n  private readonly collisionCooldown: number = 100;\n  private readonly orbRadius: number = WEAPON_ORB_RADIUS;\n\n  activate(player: Player, _dots: Dot[], initialPosition?: { x: number; y: number }): void {\n    this.dots = _dots;\n    this.start();\n    \n    // Use provided position (from WeaponOrb) or calculate from player\n    if (initialPosition) {\n      this.orbPosition = { x: initialPosition.x, y: initialPosition.y };\n    } else {\n      // Fallback: place outside player based on velocity direction\n      const playerSpeed = Math.sqrt(player.velocity.x ** 2 + player.velocity.y ** 2);\n      if (playerSpeed > 10) {\n        const dirX = player.velocity.x / playerSpeed;\n        const dirY = player.velocity.y / playerSpeed;\n        const offset = player.hitboxRadius + this.orbRadius + 5;\n        this.orbPosition = {\n          x: player.position.x + dirX * offset,\n          y: player.position.y + dirY * offset\n        };\n      } else {\n        this.orbPosition = { x: player.position.x, y: player.position.y - player.hitboxRadius - this.orbRadius - 5 };\n      }\n    }\n    this.orbVelocity = { x: 0, y: 0 };\n  }\n\n  handlePlayerCollision(player: Player, playerVelocity: Vector2): boolean {\n    const now = Date.now();\n    if (now - this.lastCollisionTime < this.collisionCooldown) {\n      return false;\n    }\n    this.lastCollisionTime = now;\n\n    const dx = this.orbPosition.x - player.position.x;\n    const dy = this.orbPosition.y - player.position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    const minSpeed = 50;\n    const playerSpeed = Math.sqrt(playerVelocity.x ** 2 + playerVelocity.y ** 2);\n\n    if (playerSpeed < minSpeed) {\n      return false;\n    }\n\n    if (distance === 0) {\n      this.orbVelocity.x = playerVelocity.x;\n      this.orbVelocity.y = playerVelocity.y;\n      return true;\n    }\n\n    const nx = dx / distance;\n    const ny = dy / distance;\n    const tx = -ny;\n    const ty = nx;\n\n    const vDotN = playerVelocity.x * nx + playerVelocity.y * ny;\n    const vDotT = playerVelocity.x * tx + playerVelocity.y * ty;\n\n    const directness = vDotN / playerSpeed;\n\n    if (directness < 0.1) {\n      return false;\n    }\n\n    const velocityMultiplier = 2.2;\n\n    if (directness > 0.7) {\n      this.orbVelocity.x = playerVelocity.x * velocityMultiplier;\n      this.orbVelocity.y = playerVelocity.y * velocityMultiplier;\n    } else {\n      const forwardFactor = directness;\n      const sidewaysFactor = 1 - directness;\n\n      this.orbVelocity.x = (nx * vDotN * forwardFactor + tx * vDotT * sidewaysFactor) * velocityMultiplier;\n      this.orbVelocity.y = (ny * vDotN * forwardFactor + ty * vDotT * sidewaysFactor) * velocityMultiplier;\n    }\n\n    return true;\n  }\n\n  getPosition(): Vector2 {\n    return this.orbPosition;\n  }\n\n  getRadius(): number {\n    return this.orbRadius;\n  }\n\n  isActive(): boolean {\n    return this.state !== 'COMPLETE';\n  }\n\n  update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    this.bounds = bounds;\n\n    switch (this.state) {\n      case 'DRIFTING': {\n        const elapsedTime = this.getElapsedTime();\n\n        this.orbPosition.x += this.orbVelocity.x * dt;\n        this.orbPosition.y += this.orbVelocity.y * dt;\n\n        const minX = this.orbRadius;\n        const maxX = bounds.width - this.orbRadius;\n        const minY = this.orbRadius;\n        const maxY = bounds.height - this.orbRadius;\n\n        // Bounce off walls (normal bounce, no speed boost)\n        if (this.orbPosition.x <= minX) {\n          this.orbVelocity.x = Math.abs(this.orbVelocity.x);\n          this.orbPosition.x = minX;\n        } else if (this.orbPosition.x >= maxX) {\n          this.orbVelocity.x = -Math.abs(this.orbVelocity.x);\n          this.orbPosition.x = maxX;\n        }\n\n        if (this.orbPosition.y <= minY) {\n          this.orbVelocity.y = Math.abs(this.orbVelocity.y);\n          this.orbPosition.y = minY;\n        } else if (this.orbPosition.y >= maxY) {\n          this.orbVelocity.y = -Math.abs(this.orbVelocity.y);\n          this.orbPosition.y = maxY;\n        }\n\n        if (elapsedTime >= this.fuseTime) {\n          this.state = 'EXPLODING';\n          this.explosionStartTime = Date.now();\n          this.explosionRadius = 0.55 * bounds.width;\n\n          this.killDotsInExplosion(dots);\n          this.checkAndKillPlayer(player);\n        }\n        break;\n      }\n      case 'EXPLODING': {\n        const explosionElapsed = Date.now() - this.explosionStartTime;\n        if (explosionElapsed > 500) {\n          this.state = 'COMPLETE';\n        }\n        break;\n      }\n      case 'COMPLETE': {\n        break;\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (!this.bounds) return;\n\n    switch (this.state) {\n      case 'DRIFTING': {\n        const elapsedTime = this.getElapsedTime();\n        const progress = Math.min(elapsedTime / this.fuseTime, 1);\n        const color = this.interpolateColor('#FF6600', '#FF0000', progress);\n\n        const warningExplosionRadius = 0.55 * this.bounds.width;\n\n        const ctx = renderer.getContext();\n\n        const warningStartTime = this.fuseTime * 0.5; // Warning at half fuse time\n        if (elapsedTime >= warningStartTime) {\n          const warningElapsed = elapsedTime - warningStartTime;\n          const flash1Start = 0;\n          const flash2Start = this.flashInterval + this.flashGap;\n\n          let shouldShowFlash = false;\n\n          if (warningElapsed >= flash1Start && warningElapsed < flash1Start + this.flashInterval) {\n            shouldShowFlash = true;\n          } else if (warningElapsed >= flash2Start && warningElapsed < flash2Start + this.flashInterval) {\n            shouldShowFlash = true;\n          }\n\n          if (shouldShowFlash) {\n            ctx.fillStyle = 'rgba(255, 165, 0, 0.6)';\n            ctx.beginPath();\n            ctx.arc(this.orbPosition.x, this.orbPosition.y, warningExplosionRadius, 0, Math.PI * 2);\n            ctx.fill();\n          }\n        }\n\n        renderer.drawCircleImmediate(\n          this.orbPosition.x,\n          this.orbPosition.y,\n          this.orbRadius,\n          color\n        );\n\n        ctx.strokeStyle = '#9B30FF';\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.arc(this.orbPosition.x, this.orbPosition.y, this.orbRadius + 2, 0, Math.PI * 2);\n        ctx.stroke();\n\n        this.drawNuclearIcon(ctx, this.orbPosition.x, this.orbPosition.y, this.orbRadius * 0.5);\n        break;\n      }\n      case 'EXPLODING': {\n        const explosionElapsed = Date.now() - this.explosionStartTime;\n        if (explosionElapsed <= 500) {\n          const alpha = 0.8 - (explosionElapsed / 500) * 0.8;\n          renderer.drawCircle(\n            this.orbPosition.x,\n            this.orbPosition.y,\n            this.explosionRadius,\n            `rgba(255, 0, 0, ${alpha})`\n          );\n        }\n        break;\n      }\n      case 'COMPLETE': {\n        break;\n      }\n    }\n  }\n\n  private interpolateColor(color1: string, color2: string, factor: number): string {\n    const r1 = parseInt(color1.slice(1, 3), 16);\n    const g1 = parseInt(color1.slice(3, 5), 16);\n    const b1 = parseInt(color1.slice(5, 7), 16);\n\n    const r2 = parseInt(color2.slice(1, 3), 16);\n    const g2 = parseInt(color2.slice(3, 5), 16);\n    const b2 = parseInt(color2.slice(5, 7), 16);\n\n    const r = Math.round(r1 + (r2 - r1) * factor);\n    const g = Math.round(g1 + (g2 - g1) * factor);\n    const b = Math.round(b1 + (b2 - b1) * factor);\n\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n  }\n\n  private drawNuclearIcon(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number): void {\n    ctx.fillStyle = '#FFFFFF';\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n\n    const skullScale = scale * 0.7;\n\n    ctx.beginPath();\n    ctx.arc(x, y - skullScale * 0.1, skullScale * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.arc(x - skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(x + skullScale * 0.2, y - skullScale * 0.15, skullScale * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.moveTo(x, y + skullScale * 0.05);\n    ctx.lineTo(x - skullScale * 0.08, y + skullScale * 0.2);\n    ctx.lineTo(x + skullScale * 0.08, y + skullScale * 0.2);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.fillStyle = '#FFFFFF';\n    ctx.beginPath();\n    ctx.rect(x - skullScale * 0.25, y + skullScale * 0.25, skullScale * 0.5, skullScale * 0.2);\n    ctx.fill();\n\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 1.5;\n    for (let i = 1; i <= 2; i++) {\n      const teethX = x - skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX, y + skullScale * 0.25);\n      ctx.lineTo(teethX, y + skullScale * 0.45);\n      ctx.stroke();\n\n      const teethX2 = x + skullScale * 0.08 * i;\n      ctx.beginPath();\n      ctx.moveTo(teethX2, y + skullScale * 0.25);\n      ctx.lineTo(teethX2, y + skullScale * 0.45);\n      ctx.stroke();\n    }\n\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 3;\n    ctx.lineCap = 'round';\n\n    ctx.beginPath();\n    ctx.moveTo(x - skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x + skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(x + skullScale * 0.7, y - skullScale * 0.5);\n    ctx.lineTo(x - skullScale * 0.7, y + skullScale * 0.5);\n    ctx.stroke();\n\n    ctx.fillStyle = '#FFFFFF';\n    const boneEndRadius = skullScale * 0.1;\n    const boneEnds = [\n      { x: x - skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y + skullScale * 0.5 },\n      { x: x + skullScale * 0.7, y: y - skullScale * 0.5 },\n      { x: x - skullScale * 0.7, y: y + skullScale * 0.5 }\n    ];\n\n    for (const end of boneEnds) {\n      ctx.beginPath();\n      ctx.arc(end.x, end.y, boneEndRadius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  setOrbs(orbs: WeaponOrb[]): void {\n    this.orbs = orbs;\n  }\n\n  getDestroyedOrbs(): WeaponOrb[] {\n    return Array.from(this.orbsToDestroy);\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  hasKilledPlayer(): boolean {\n    return this._hasKilledPlayer;\n  }\n\n  private killDotsInExplosion(dots: Dot[]): void {\n    for (const dot of dots) {\n      if (dot.isDead() || this.killedDotsInExplosion.has(dot)) continue;\n\n      const pos = dot.getPosition();\n      const dx = pos.x - this.orbPosition.x;\n      const dy = pos.y - this.orbPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.explosionRadius) {\n        dot.kill();\n        this.addKilledDot();\n        this.killedDotsInExplosion.add(dot);\n      }\n    }\n\n    // Destroy weapon orbs in explosion radius\n    for (const orb of this.orbs) {\n      if (this.orbsToDestroy.has(orb) || !orb.isActive()) continue;\n\n      const pos = orb.getPosition();\n      const dx = pos.x - this.orbPosition.x;\n      const dy = pos.y - this.orbPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.explosionRadius) {\n        this.orbsToDestroy.add(orb);\n      }\n    }\n  }\n\n  private checkAndKillPlayer(player: Player): void {\n    if (this._hasKilledPlayer) return;\n\n    const dx = player.position.x - this.orbPosition.x;\n    const dy = player.position.y - this.orbPosition.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance <= this.explosionRadius) {\n      this._hasKilledPlayer = true;\n    }\n  }\n}\n","import { HighscoreEntry } from '../types';\n\nconst STORAGE_KEY = 'tilt-to-live-highscores';\nconst MAX_HIGHSCORES = 10;\n\n/**\n * Get all highscores from localStorage\n * Returns empty array if none exist\n */\nexport function getHighscores(): HighscoreEntry[] {\n  try {\n    const data = localStorage.getItem(STORAGE_KEY);\n    if (!data) return [];\n\n    const scores = JSON.parse(data) as HighscoreEntry[];\n    // Ensure sorted descending by score\n    return scores.sort((a, b) => b.score - a.score);\n  } catch (error) {\n    console.error('Failed to load highscores:', error);\n    return [];\n  }\n}\n\n/**\n * Add a new highscore\n * Maintains top 10, sorted descending\n * Returns the rank (1-based) or -1 if not in top 10\n */\nexport function addHighscore(score: number): number {\n  const highscores = getHighscores();\n\n  const newEntry: HighscoreEntry = {\n    score,\n    timestamp: Date.now()\n  };\n\n  // Add new score\n  highscores.push(newEntry);\n\n  // Sort descending by score\n  highscores.sort((a, b) => b.score - a.score);\n\n  // Keep only top 10\n  const trimmed = highscores.slice(0, MAX_HIGHSCORES);\n\n  // Find rank of new score\n  const rank = trimmed.findIndex(e => e.timestamp === newEntry.timestamp && e.score === score) + 1;\n\n  // Save to localStorage\n  try {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmed));\n  } catch (error) {\n    console.error('Failed to save highscores:', error);\n  }\n\n  return rank > 0 ? rank : -1;\n}\n\n/**\n * Check if a score would make the top 10\n */\nexport function isHighscore(score: number): boolean {\n  const highscores = getHighscores();\n\n  // If we have less than 10, any score qualifies\n  if (highscores.length < MAX_HIGHSCORES) return true;\n\n  // Check if score beats the lowest\n  return score > highscores[highscores.length - 1].score;\n}\n\n/**\n * Clear all highscores\n * Use for testing/reset\n */\nexport function clearHighscores(): void {\n  try {\n    localStorage.removeItem(STORAGE_KEY);\n  } catch (error) {\n    console.error('Failed to clear highscores:', error);\n  }\n}\n\n/**\n * Format highscore list for display\n * Returns array of formatted strings\n */\nexport function formatHighscores(entries: HighscoreEntry[]): string[] {\n  return entries.map((entry) => {\n    const date = new Date(entry.timestamp);\n    const dateStr = date.toLocaleDateString();\n    return `${entry.score} pts - ${dateStr}`;\n  });\n}\n\n/**\n * Get the highest score (for display purposes)\n */\nexport function getTopScore(): number {\n  const scores = getHighscores();\n  return scores.length > 0 ? scores[0].score : 0;\n}\n","import { GameEvent, GameEventType } from '../types';\n\nexport class GameEventLogger {\n  private events: GameEvent[] = [];\n  private gameStartTime: number = 0;\n\n  startGame(): void {\n    this.events = [];\n    this.gameStartTime = Date.now();\n  }\n\n  log(event: Omit<GameEvent, 'timestamp'>): void {\n    this.events.push({\n      ...event,\n      timestamp: Date.now()\n    });\n  }\n\n  logPatternSpawnStart(patternType: string): void {\n    this.log({\n      type: GameEventType.PATTERN_SPAWN_START,\n      message: `Pattern started: ${this.formatPatternName(patternType)}`\n    });\n  }\n\n  logPatternSpawnComplete(patternType: string, dotsSpawned: number): void {\n    this.log({\n      type: GameEventType.PATTERN_SPAWN_COMPLETE,\n      message: `Pattern finished spawning: ${this.formatPatternName(patternType)} (${dotsSpawned} dots)`,\n      details: { patternType, dotsSpawned }\n    });\n  }\n\n  logWeaponPickup(weaponType: string): void {\n    this.log({\n      type: GameEventType.WEAPON_PICKUP,\n      message: `Picked up: ${this.formatWeaponName(weaponType)}`\n    });\n  }\n\n  logWeaponActivate(weaponType: string): void {\n    this.log({\n      type: GameEventType.WEAPON_ACTIVATE,\n      message: `Activated: ${this.formatWeaponName(weaponType)}`\n    });\n  }\n\n  logBouncedOrbDetonate(weaponType: string, kills: number): void {\n    this.log({\n      type: GameEventType.BOUNCED_ORB_DETONATE,\n      message: `${this.formatWeaponName(weaponType)} detonated (${kills} kills)`,\n      details: { weaponType, kills }\n    });\n  }\n\n  logPlayerDeath(cause: string): void {\n    this.log({\n      type: GameEventType.PLAYER_DEATH,\n      message: `Death: ${cause}`\n    });\n  }\n\n  getEvents(): GameEvent[] {\n    return [...this.events];\n  }\n\n  getEventsReversed(): GameEvent[] {\n    return [...this.events].reverse();\n  }\n\n  getFormattedEvents(): { time: string; message: string }[] {\n    return this.getEventsReversed().map(event => ({\n      time: this.formatTime(event.timestamp),\n      message: event.message\n    }));\n  }\n\n  private formatTime(timestamp: number): string {\n    const elapsed = timestamp - this.gameStartTime;\n    const seconds = Math.floor(elapsed / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n  }\n\n  private formatPatternName(type: string): string {\n    const names: Record<string, string> = {\n      'ZOMBIE_SNOW': 'Zombie Snow',\n      'SWEEPER_LINE': 'Sweeper Line',\n      'SPARSE_GRID': 'Sparse Grid',\n      'BOUNCING_BALL': 'Bouncing Ball',\n      'GATLING_POINT': 'Gatling Point',\n      'BULLET_HELL': 'Bullet Hell',\n      'CONTAINMENT_RING': 'Containment Ring',\n      'CYCLONE': 'Cyclone',\n      'CLOCK_SWEEP': 'Clock Sweep'\n    };\n    return names[type] || type;\n  }\n\n  private formatWeaponName(type: string): string {\n    const names: Record<string, string> = {\n      'KINETIC_BOMB': 'Kinetic Bomb',\n      'BLASTER': 'Blaster',\n      'ICE_BOMB': 'Ice Bomb',\n      'HOMING_MISSILE': 'Homing Missile',\n      'NUCLEAR_BOMB': 'Nuclear Bomb',\n      'ELECTRIC_BOMB': 'Electric Bomb',\n      'DOT_REPELLENT': 'Dot Repellent',\n      'CHAINSAW': 'Chainsaw',\n      'FLAME_BURST': 'Flame Burst',\n      'TRIPLE_CANNON': 'Triple Cannon',\n      'FIREBALL_ORB': 'Fireball Orb',\n      'TESLA_CANNON': 'Tesla Cannon'\n    };\n    return names[type] || type;\n  }\n\n  clear(): void {\n    this.events = [];\n  }\n}\n","import { GameState, Bounds, type DeathEvent } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { InputManager } from './InputManager';\nimport { Player } from '../entities/Player';\nimport { ScoringSystem } from './ScoringSystem';\nimport { CollisionSystem } from './CollisionSystem';\nimport { PatternManager } from './PatternManager';\nimport { WeaponOrbSpawner } from './WeaponOrbSpawner';\nimport { WeaponRegistry } from '../weapons/WeaponRegistry';\nimport type { Weapon } from '../weapons/Weapon';\nimport { NuclearBomb } from '../weapons/NuclearBomb';\nimport { COLOR_BACKGROUND, FRAME_TIME } from '../utils/constants';\nimport { getHighscores, addHighscore } from '../utils/storage';\nimport { GameEventLogger } from './GameEventLogger';\n\n\nexport class Game {\n  private renderer: Renderer;\n  private input: InputManager;\n  private state: GameState = GameState.MENU;\n  private lastFrameTime: number = 0;\n  private isPaused: boolean = false;\n  private accumulator: number = 0;\n\n  private player: Player | null = null;\n\n  private bounds: Bounds;\n  private timeAlive: number = 0;\n\n  private scoringSystem: ScoringSystem = new ScoringSystem();\n  private collisionSystem: CollisionSystem;\n  private patternManager: PatternManager = new PatternManager();\n  private orbSpawner: WeaponOrbSpawner = new WeaponOrbSpawner();\n  private activeWeapons: Weapon[] = [];\n  private lastDeathEvent: DeathEvent | null = null;\n  private eventLogger: GameEventLogger = new GameEventLogger();\n  private menuElement: HTMLElement;\n  private gameOverElement: HTMLElement;\n  private permissionElement: HTMLElement;\n  private newGameBtn: HTMLElement;\n  private playAgainBtn: HTMLElement;\n  private enableMotionBtn: HTMLElement;\n  private finalScoreElement: HTMLElement;\n  private newHighscoreElement: HTMLElement;\n  \n  constructor() {\n    this.renderer = new Renderer('game');\n    this.input = new InputManager();\n    this.bounds = this.renderer.getBounds();\n    this.collisionSystem = new CollisionSystem(this.bounds);\n    \n    this.menuElement = document.getElementById('menu')!;\n    this.gameOverElement = document.getElementById('game-over')!;\n    this.permissionElement = document.getElementById('permission-prompt')!;\n    this.newGameBtn = document.getElementById('new-game-btn')!;\n    this.playAgainBtn = document.getElementById('play-again-btn')!;\n    this.enableMotionBtn = document.getElementById('enable-motion-btn')!;\n    this.finalScoreElement = document.getElementById('final-score')!;\n    this.newHighscoreElement = document.getElementById('new-highscore')!;\n    \n    this.setupEventListeners();\n    \n    // Setup scale slider\n    this.setupScaleSlider();\n    this.checkPlatform();\n    this.gameLoop(0);\n    this.displayMenuHighscores();\n  }\n  \n  private checkPlatform(): void {\n    const isDesktop = !('ontouchstart' in window) && \n                      !('DeviceOrientationEvent' in window);\n    if (isDesktop) {\n      this.showElement('desktop-warning', true);\n      return;\n    }\n    this.checkOrientation();\n    window.addEventListener('orientationchange', () => this.checkOrientation());\n    window.addEventListener('resize', () => this.checkOrientation());\n  }\n  \n  private checkOrientation(): void {\n    const isLandscape = window.innerWidth > window.innerHeight;\n    this.showElement('landscape-warning', isLandscape && this.state === GameState.PLAYING);\n  }\n  \n  private showElement(id: string, show: boolean): void {\n    const el = document.getElementById(id);\n    if (el) el.style.display = show ? 'flex' : 'none';\n  }\n\n  private displayMenuHighscores(): void {\n    const menuHighscoreList = document.getElementById('menu-highscores');\n    if (menuHighscoreList) {\n      const highscores = getHighscores();\n      if (highscores.length === 0) {\n        menuHighscoreList.innerHTML = '<li style=\"color: #666;\">No scores yet</li>';\n      } else {\n        menuHighscoreList.innerHTML = highscores\n          .slice(0, 10)\n          .map((h, i) => `<li>${i + 1}. ${h.score}</li>`)\n          .join('');\n      }\n    }\n  }\n  \n  private setupEventListeners(): void {\n    this.newGameBtn.addEventListener('click', () => this.handleNewGameClick());\n    this.playAgainBtn.addEventListener('click', () => this.handleNewGameClick());\n    this.enableMotionBtn.addEventListener('click', () => this.requestMotionPermission());\n    \n    window.addEventListener('resize', () => {\n      this.bounds = this.renderer.getBounds();\n    });\n    \n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden && this.state === GameState.PLAYING) {\n        this.pause();\n      } else if (!document.hidden && this.state === GameState.PAUSED) {\n        this.resume();\n      }\n    });\n  }\n  \n  private setupScaleSlider(): void {\n    const scaleSlider = document.getElementById('game-scale-slider') as HTMLInputElement;\n    const scaleValue = document.getElementById('scale-value');\n    \n    if (scaleSlider && scaleValue) {\n      // Load saved scale from localStorage or use default\n      const savedScale = localStorage.getItem('game-scale');\n      const initialScale = savedScale ? parseInt(savedScale, 10) : 130;\n      \n      scaleSlider.value = initialScale.toString();\n      scaleValue.textContent = `${initialScale}%`;\n      this.renderer.setScale(initialScale / 100);\n      \n      // Update bounds with the initial scale\n      this.bounds = this.renderer.getBounds();\n      this.collisionSystem.updateBounds(this.bounds);\n      \n      scaleSlider.addEventListener('input', () => {\n        const scale = parseInt(scaleSlider.value, 10);\n        scaleValue.textContent = `${scale}%`;\n        this.renderer.setScale(scale / 100);\n        localStorage.setItem('game-scale', scale.toString());\n        \n        // Update bounds when scale changes\n        this.bounds = this.renderer.getBounds();\n        if (this.collisionSystem) {\n          this.collisionSystem.updateBounds(this.bounds);\n        }\n      });\n    }\n  }\n  \n  private async handleNewGameClick(): Promise<void> {\n    if (this.input.needsPermissionRequest()) {\n      this.menuElement.classList.add('hidden');\n      this.permissionElement.style.display = 'flex';\n      return;\n    }\n    \n    this.startGame();\n  }\n  \n  private async requestMotionPermission(): Promise<void> {\n    const granted = await this.input.requestPermission();\n    \n    if (granted) {\n      this.permissionElement.style.display = 'none';\n      this.startGame();\n    } else {\n      alert('Motion permission denied. The game requires device motion to play.');\n    }\n  }\n  \n  startGame(): void {\n    this.state = GameState.PLAYING;\n    this.timeAlive = 0;\n    this.lastDeathEvent = null;\n    this.lastFrameTime = performance.now();\n\n    this.scoringSystem.start();\n\n    this.collisionSystem.updateBounds(this.bounds);\n\n    const centerX = this.bounds.width / 2;\n    const centerY = this.bounds.height / 2;\n    this.player = new Player(centerX, centerY);\n\n    this.patternManager.clear();\n    this.orbSpawner.initialize(this.bounds, this.player.getPosition());\n    this.activeWeapons = [];\n    this.eventLogger.startGame();\n\n    this.input.calibrateTiltBasis();\n\n    this.menuElement.classList.add('hidden');\n    this.gameOverElement.classList.add('hidden');\n    \n\n  }\n  \n  private handleGameOver(): void {\n    const finalScore = this.scoringSystem.getScore();\n    this.state = GameState.GAME_OVER;\n\n    this.finalScoreElement.textContent = `Score: ${finalScore}`;\n\n    // Save highscore and check if it's a new high score\n    const rank = addHighscore(finalScore);\n    const isNewHighscore = rank > 0 && rank <= 3;\n    \n    // Show \"New High Score!\" message if applicable\n    if (isNewHighscore) {\n      this.newHighscoreElement.textContent = rank === 1 ? 'New #1 High Score!' : `New #${rank} High Score!`;\n      this.newHighscoreElement.style.display = 'block';\n    } else {\n      this.newHighscoreElement.style.display = 'none';\n    }\n\n    // Display highscores on death screen\n    const highscoreList = document.getElementById('gameover-highscores');\n    if (highscoreList) {\n      const highscores = getHighscores();\n      highscoreList.innerHTML = highscores\n        .slice(0, 10)\n        .map((h, i) => {\n          const isCurrentScore = rank > 0 && i + 1 === rank;\n          const style = isCurrentScore ? ' style=\"color: #FFD700; font-weight: bold;\"' : '';\n          return `<li${style}>${i + 1}. ${h.score}</li>`;\n        })\n        .join('');\n    }\n\n    const deathReasonElement = document.getElementById('death-reason');\n    if (deathReasonElement) {\n      deathReasonElement.textContent = this.lastDeathEvent?.message ?? 'Unknown';\n    }\n\n    // Display event log\n    const eventLogElement = document.getElementById('event-log');\n    if (eventLogElement) {\n      const events = this.eventLogger.getFormattedEvents();\n      eventLogElement.innerHTML = events\n        .map(e => `<li><span class=\"event-time\">[${e.time}]</span> ${e.message}</li>`)\n        .join('');\n    }\n    this.gameOverElement.classList.remove('hidden');\n  }\n\n  pause(): void {\n    this.isPaused = true;\n  }\n\n  resume(): void {\n    this.isPaused = false;\n    this.lastFrameTime = performance.now();\n  }\n\n  private gameLoop = (currentTime: number): void => {\n    if (this.state !== GameState.PLAYING || this.isPaused) {\n      requestAnimationFrame(this.gameLoop);\n      return;\n    }\n    const deltaTime = currentTime - this.lastFrameTime;\n    this.lastFrameTime = currentTime;\n\n    this.accumulator += deltaTime;\n\n    while (this.accumulator >= FRAME_TIME) {\n      this.update(FRAME_TIME / 1000);\n      this.accumulator -= FRAME_TIME;\n    }\n\n    this.render();\n    requestAnimationFrame(this.gameLoop);\n  };\n  \n  private update(dt: number): void {\n    if (!this.player) return;\n\n    this.timeAlive += dt;\n\n    const velocity = this.input.getVelocity();\n    this.player.update(dt, velocity, this.bounds);\n\n    const score = this.scoringSystem.getScore();\n    this.patternManager.setScore(score);\n\n    this.patternManager.update(dt, this.player.getPosition(), this.bounds);\n\n    // If no dots and no pattern is actively spawning, throw in a new pattern\n    const allDots = this.patternManager.getAllDots();\n    if (allDots.length === 0 && !this.patternManager.isAnyPatternActivelySpawning()) {\n      const nextType = this.patternManager.selectNextPattern();\n      if (nextType) {\n        this.patternManager.spawnPattern(nextType, this.player.getPosition(), this.bounds);\n      }\n    }\n\n    this.orbSpawner.update(this.bounds, this.player.getPosition());\n\n    this.collisionSystem.rebuildGrid(allDots);\n\n    const orbs = this.orbSpawner.getOrbs();\n\n    // Update bounced weapon orb positions\n    for (const orb of orbs) {\n      orb.updatePosition(dt, this.bounds);\n    }\n\n    const collidingOrb = this.collisionSystem.checkPlayerOrbCollision(this.player, orbs);\n    if (collidingOrb) {\n      // Try to bounce bounced weapons first\n      const playerVelocity = this.input.getVelocity();\n      const bounced = collidingOrb.bounce(playerVelocity, this.player.getPosition());\n\n      if (!bounced) {\n        // Not a bounced weapon or bounce failed - pick it up\n        const weaponType = collidingOrb.getWeaponType();\n        const weapon = WeaponRegistry.create(weaponType);\n        if (weapon) {\n          weapon.activate(this.player, allDots, collidingOrb.getPosition());\n          this.activeWeapons.push(weapon);\n          collidingOrb.pickup();\n          this.orbSpawner.removeOrb(collidingOrb);\n          this.eventLogger.logWeaponPickup(weaponType);\n\n        }\n      }\n    }\n\n    for (let i = this.activeWeapons.length - 1; i >= 0; i--) {\n      const weapon = this.activeWeapons[i];\n      \n      // Pass orbs to NuclearBomb before update so it can destroy them in explosion\n      if (weapon instanceof NuclearBomb) {\n        weapon.setOrbs(orbs);\n      }\n      \n      weapon.update(dt, this.player, allDots, this.bounds);\n      \n      // Remove any orbs destroyed by NuclearBomb explosion\n      if (weapon instanceof NuclearBomb) {\n        const destroyedOrbs = weapon.getDestroyedOrbs();\n        for (const destroyedOrb of destroyedOrbs) {\n          this.orbSpawner.removeOrb(destroyedOrb);\n        }\n      }\n      \n      // Check for player collision with active weapon (for bounceable weapons like Electric/Nuclear bomb)\n      if (weapon.isActive()) {\n        const playerPos = this.player.getPosition();\n        const weaponPos = weapon.getPosition();\n        const weaponRadius = weapon.getRadius();\n        const playerRadius = this.player.hitboxRadius;\n        \n        const dx = weaponPos.x - playerPos.x;\n        const dy = weaponPos.y - playerPos.y;\n        const distSq = dx * dx + dy * dy;\n        const radiiSum = weaponRadius + playerRadius;\n        \n        if (distSq < radiiSum * radiiSum) {\n          const playerVelocity = this.input.getVelocity();\n          weapon.handlePlayerCollision(this.player, playerVelocity);\n        }\n      }\n      \n      if (weapon instanceof NuclearBomb && weapon.hasKilledPlayer()) {\n        this.eventLogger.logBouncedOrbDetonate('NUCLEAR_BOMB', weapon.getKilledDots());\n        this.eventLogger.logPlayerDeath('Nuclear Bomb explosion');\n        this.lastDeathEvent = {\n          message: 'Killed by Nuclear Bomb explosion',\n          type: 'nuclear_bomb',\n          timestamp: Date.now()\n        };\n        this.handleGameOver();\n        return;\n      }\n      \n      if (weapon.isComplete()) {\n        this.scoringSystem.addKills(weapon.getKilledDots());\n        this.activeWeapons.splice(i, 1);\n      }\n    }\n\n    const collidingDot = this.collisionSystem.checkPlayerDotCollision(this.player);\n    if (collidingDot) {\n      if (collidingDot.isLethal()) {\n        this.eventLogger.logPlayerDeath('red dot');\n        this.lastDeathEvent = {\n          message: 'Hit by a red dot',\n          type: 'dot',\n          timestamp: Date.now()\n        };\n        this.handleGameOver();\n      } else if (collidingDot.isFrozen()) {\n        collidingDot.kill();\n        this.scoringSystem.addKills(1);\n      }\n    }\n  }\n  \n  private render(): void {\n    this.renderer.clear(COLOR_BACKGROUND);\n\n    const orbs = this.orbSpawner.getOrbs();\n    for (let i = 0; i < orbs.length; i++) {\n      orbs[i].render(this.renderer);\n    }\n\n    const allDots = this.patternManager.getAllDots();\n    for (let i = 0; i < allDots.length; i++) {\n      allDots[i].render(this.renderer);\n    }\n\n    for (let i = 0; i < this.activeWeapons.length; i++) {\n      this.activeWeapons[i].render(this.renderer);\n    }\n\n    if (this.player) {\n      this.player.render(this.renderer);\n    }\n\n    this.renderer.flushBatches();\n    this.renderer.endFrame();\n  }\n  \n  getState(): GameState {\n    return this.state;\n  }\n  \n  getScore(): number {\n    return this.scoringSystem.getScore();\n  }\n\n}\n","import { Vector2, Bounds, DotState, PatternType } from '../types';\nimport { Renderer } from '../renderer/Renderer';\nimport { Vec2, wrapInPlace } from '../utils/math';\nimport { DOT_RADIUS, DOT_SPAWN_ANIMATION_DURATION, DOT_SPAWN_SCALE_MAX, COLOR_DOT, COLOR_DOT_SPAWNING, COLOR_DOT_FROZEN } from '../utils/constants';\n\nconst FROZEN_BORDER_MAX_THICKNESS = 8;\nconst FROZEN_BORDER_COLOR = '#00CCFF';\n\nconst SPAWN_INV_DURATION = 1 / DOT_SPAWN_ANIMATION_DURATION;\nconst SCALE_RANGE = DOT_SPAWN_SCALE_MAX - 1;\n\nexport class Dot {\n  position: Vec2;\n  velocity: Vector2;\n  state: DotState;\n  patternId: string | null = null;\n  \n  private spawnElapsed: number = 0;\n  private currentScale: number = DOT_SPAWN_SCALE_MAX;\n  readonly radius: number = DOT_RADIUS;\n  \n  // Frozen/thaw properties\n  private frozenTime: number = 0;\n  private readonly thawDuration: number = 6000; // 6 seconds (doubled)\n  private readonly preThawWarningTime: number = 500; // Start vibrating 500ms before thaw\n  private isZombie: boolean = false;\n  private readonly zombieSpeed: number = 50;\n  private vibrationOffset: Vector2 = { x: 0, y: 0 };\n  private frozenBorderThickness: number = FROZEN_BORDER_MAX_THICKNESS;\n\n  constructor(x: number, y: number, patternId: string | null = null) {\n    this.position = new Vec2(x, y);\n    this.velocity = { x: 0, y: 0 };\n    this.state = DotState.SPAWNING;\n    this.patternId = patternId;\n  }\n\n  skipSpawnAnimation(): void {\n    this.state = DotState.ACTIVE;\n    this.currentScale = 1;\n    this.spawnElapsed = 1 / SPAWN_INV_DURATION;\n  }\n\n  update(dt: number, bounds: Bounds, playerPosition?: Vector2): void {\n    if (this.state === DotState.SPAWNING) {\n      this.spawnElapsed += dt * 1000;\n      const progress = this.spawnElapsed * SPAWN_INV_DURATION;\n      \n      if (progress >= 1) {\n        this.state = DotState.ACTIVE;\n        this.currentScale = 1;\n      } else {\n        this.currentScale = DOT_SPAWN_SCALE_MAX - SCALE_RANGE * progress;\n      }\n      return;\n    }\n    \n    if (this.state === DotState.FROZEN) {\n      this.frozenTime += dt * 1000;\n\n      const frozenProgress = Math.min(this.frozenTime / this.thawDuration, 1);\n      this.frozenBorderThickness = FROZEN_BORDER_MAX_THICKNESS * (1 - frozenProgress);\n\n      const timeUntilThaw = this.thawDuration - this.frozenTime;\n      if (timeUntilThaw <= this.preThawWarningTime && timeUntilThaw > 0) {\n        const shakeIntensity = 2 * (1 - timeUntilThaw / this.preThawWarningTime);\n        this.vibrationOffset.x = (Math.random() - 0.5) * shakeIntensity;\n        this.vibrationOffset.y = (Math.random() - 0.5) * shakeIntensity;\n      } else {\n        this.vibrationOffset.x = 0;\n        this.vibrationOffset.y = 0;\n      }\n\n      if (this.frozenTime >= this.thawDuration) {\n        this.thaw(playerPosition);\n      }\n      return;\n    }\n    \n    if (this.state !== DotState.ACTIVE) {\n      return;\n    }\n    \n    // If this is a zombie dot (thawed from frozen), chase the player\n    if (this.isZombie && playerPosition) {\n      const dx = playerPosition.x - this.position.x;\n      const dy = playerPosition.y - this.position.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      \n      if (dist > 0) {\n        this.velocity.x = (dx / dist) * this.zombieSpeed;\n        this.velocity.y = (dy / dist) * this.zombieSpeed;\n      }\n    }\n    \n    this.position.x += this.velocity.x * dt;\n    this.position.y += this.velocity.y * dt;\n    \n    // Don't wrap Cyclone, ClockSweep, or SweeperLine dots - they have their own movement patterns\n    if (this.patternId !== PatternType.CYCLONE && \n        this.patternId !== PatternType.CLOCK_SWEEP &&\n        this.patternId !== PatternType.SWEEPER_LINE) {\n      wrapInPlace(this.position, bounds);\n    }\n  }\n\n  render(renderer: Renderer): void {\n    const currentRadius = this.radius * this.currentScale;\n\n    let color: string;\n    switch (this.state) {\n      case DotState.SPAWNING:\n        color = COLOR_DOT_SPAWNING;\n        break;\n      case DotState.FROZEN:\n        color = COLOR_DOT_FROZEN;\n        break;\n      default:\n        color = COLOR_DOT;\n    }\n\n    const renderX = this.position.x + this.vibrationOffset.x;\n    const renderY = this.position.y + this.vibrationOffset.y;\n\n    renderer.drawCircle(\n      renderX,\n      renderY,\n      currentRadius,\n      color\n    );\n    \n    if (this.state === DotState.SPAWNING) {\n      const alpha = 1 - this.currentScale / DOT_SPAWN_SCALE_MAX;\n      renderer.drawCircleOutline(\n        renderX,\n        renderY,\n        currentRadius * 1.5,\n        `rgba(255,102,102,${alpha.toFixed(2)})`\n      );\n    }\n\n    if (this.state === DotState.FROZEN) {\n      // Draw light blue border as an outline that shrinks as they thaw\n      renderer.drawCircleOutline(\n        renderX,\n        renderY,\n        currentRadius + this.frozenBorderThickness,\n        FROZEN_BORDER_COLOR\n      );\n      renderer.drawCircle(\n        renderX,\n        renderY,\n        currentRadius,\n        color\n      );\n    }\n  }\n\n  isLethal(): boolean {\n    return this.state === DotState.ACTIVE;\n  }\n\n  isFrozen(): boolean {\n    return this.state === DotState.FROZEN;\n  }\n\n  freeze(): void {\n    if (this.state === DotState.ACTIVE || this.state === DotState.SPAWNING) {\n      this.state = DotState.FROZEN;\n      this.velocity.x = 0;\n      this.velocity.y = 0;\n      this.frozenTime = 0;\n      this.frozenBorderThickness = FROZEN_BORDER_MAX_THICKNESS;\n    }\n  }\n\n  thaw(playerPosition?: Vector2): void {\n    if (this.state === DotState.FROZEN) {\n      this.state = DotState.ACTIVE;\n      this.isZombie = true;\n      this.vibrationOffset.x = 0;\n      this.vibrationOffset.y = 0;\n      if (playerPosition) {\n        const dx = playerPosition.x - this.position.x;\n        const dy = playerPosition.y - this.position.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist > 0) {\n          this.velocity.x = (dx / dist) * this.zombieSpeed;\n          this.velocity.y = (dy / dist) * this.zombieSpeed;\n        }\n      }\n    }\n  }\n\n  kill(): void {\n    this.state = DotState.DEAD;\n  }\n\n  isDead(): boolean {\n    return this.state === DotState.DEAD;\n  }\n\n  getPosition(): Vector2 {\n    return this.position;\n  }\n\n  getRadius(): number {\n    return this.radius;\n  }\n\n  getEffectiveRadius(): number {\n    if (this.state === DotState.FROZEN) {\n      return this.radius + this.frozenBorderThickness;\n    }\n    return this.radius;\n  }\n}\n","import { Dot } from '../entities/Dot';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { Renderer } from '../renderer/Renderer';\n\nexport abstract class Pattern {\n  abstract readonly type: PatternType;\n  abstract readonly difficulty: Difficulty;\n\n  protected dots: Dot[] = [];\n  protected elapsedMs: number = 0;\n  protected isStarted: boolean = false;\n\n  abstract spawn(center: Vector2, bounds: Bounds): void;\n  abstract update(dt: number, playerPosition: Vector2, bounds: Bounds): void;\n\n  /**\n   * Centralized dot spawning method.\n   * Creates a dot with a spawn animation and optional initial velocity.\n   * The dot will be non-lethal during the spawn animation (500ms),\n   * then become active with the provided velocity.\n   *\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param velocity - Initial velocity (applied once spawn completes)\n   * @returns The created Dot instance\n   */\n  protected spawnDot(x: number, y: number, velocity: Vector2 = { x: 0, y: 0 }): Dot {\n    const dot = new Dot(x, y, this.type);\n    dot.velocity.x = velocity.x;\n    dot.velocity.y = velocity.y;\n    this.dots.push(dot);\n    return dot;\n  }\n\n  getDots(): Dot[] {\n    return this.dots.filter(d => !d.isDead());\n  }\n\n  isComplete(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns true if the pattern is still actively spawning dots.\n   * Override in subclasses that spawn dots over time.\n   */\n  isActivelySpawning(): boolean {\n    return false;\n  }\n\n  start(): void {\n    this.elapsedMs = 0;\n    this.isStarted = true;\n  }\n\n  getElapsedTime(): number {\n    return this.elapsedMs;\n  }\n\n  tick(dt: number): void {\n    this.elapsedMs += dt * 1000;\n  }\n\n  render(_renderer: Renderer): void {\n    // Override in subclasses to render pattern-specific visuals (e.g., warning indicators)\n  }\n\n  clear(): void {\n    for (let i = 0; i < this.dots.length; i++) {\n      this.dots[i].kill();\n    }\n    this.dots = [];\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { randomPosition } from '../utils/math';\nimport { DOT_RADIUS } from '../utils/constants';\n\nexport class ZombieSnow extends Pattern {\n  readonly type = PatternType.ZOMBIE_SNOW;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private spawnInterval: number;\n  private elapsedSinceSpawn: number = 0;\n  private readonly duration: number = 15000;\n  private readonly dotSpeed: number = 50;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.spawnInterval = 150;\n        break;\n      case Difficulty.MEDIUM:\n        this.spawnInterval = 300;\n        break;\n      default:\n        this.spawnInterval = 500;\n    }\n  }\n\n  spawn(_center: Vector2, _bounds: Bounds): void {\n    this.start();\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.elapsedMs <= this.duration) {\n      this.elapsedSinceSpawn += dt * 1000;\n      if (this.elapsedSinceSpawn >= this.spawnInterval) {\n        this.elapsedSinceSpawn = 0;\n        this.spawnDotAtRandomPosition(bounds);\n      }\n    }\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const dx = playerPosition.x - pos.x;\n      const dy = playerPosition.y - pos.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 0) {\n        dot.velocity.x = (dx / dist) * this.dotSpeed;\n        dot.velocity.y = (dy / dist) * this.dotSpeed;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnDotAtRandomPosition(bounds: Bounds): void {\n    const margin = DOT_RADIUS * 2;\n    const pos = randomPosition(bounds, margin);\n    this.spawnDot(pos.x, pos.y);\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.getDots().length === 0;\n  }\n\n  isActivelySpawning(): boolean {\n    return this.elapsedMs <= this.duration;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { DOT_SPAWN_ANIMATION_DURATION } from '../utils/constants';\n\nexport class SweeperLine extends Pattern {\n  readonly type = PatternType.SWEEPER_LINE;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private readonly duration: number = 20000;\n  private readonly dotSpacing: number = 20;\n  private readonly holeSize: number = 40;\n\n  private isHorizontal: boolean = true;\n  private sweepSpeed: number = 150;\n  private linePos: number = 0;\n  private lineVelocity: number = 0;\n  private lineOffset: number = 0;\n  private pendingSpawns: { offset: number }[] = [];\n  private spawnTimer: number = 0;\n  private readonly spawnDelay: number = 12;\n  private isSpawning: boolean = false;\n  private spawnCompleteTime: number = 0;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.sweepSpeed = 220;\n        break;\n      case Difficulty.MEDIUM:\n        this.sweepSpeed = 180;\n        break;\n      default:\n        this.sweepSpeed = 140;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.isSpawning = true;\n    this.spawnCompleteTime = 0;\n\n    this.isHorizontal = Math.random() > 0.5;\n\n    if (this.isHorizontal) {\n      this.lineOffset = Math.random() * (bounds.width - 200) + 100;\n    } else {\n      this.lineOffset = Math.random() * (bounds.height - 200) + 100;\n    }\n\n    if (this.isHorizontal) {\n      this.lineVelocity = Math.random() > 0.5 ? this.sweepSpeed : -this.sweepSpeed;\n\n      this.linePos = this.lineVelocity > 0 ? 0 : bounds.height;\n    } else {\n      this.lineVelocity = Math.random() > 0.5 ? this.sweepSpeed : -this.sweepSpeed;\n\n      this.linePos = this.lineVelocity > 0 ? 0 : bounds.width;\n    }\n\n    this.generateLineWithHoles(bounds);\n  }\n\n  private generateLineWithHoles(bounds: Bounds): void {\n    const numHoles = Math.floor(Math.random() * 2) + 2;\n    const lineLength = this.isHorizontal ? bounds.height : bounds.width;\n    const numDots = Math.floor((lineLength - 100) / this.dotSpacing);\n\n    const holeSet = new Set<number>();\n    const holeWidthDots = Math.ceil(this.holeSize / this.dotSpacing);\n\n    for (let h = 0; h < numHoles; h++) {\n      const holeCenter = Math.floor(Math.random() * (numDots - 10)) + 5;\n      for (let i = -Math.floor(holeWidthDots / 2); i <= Math.floor(holeWidthDots / 2); i++) {\n        holeSet.add(holeCenter + i);\n      }\n    }\n\n    const startOffset = (lineLength - (numDots * this.dotSpacing)) / 2;\n\n    for (let i = 0; i < numDots; i++) {\n      if (!holeSet.has(i)) {\n        const offset = startOffset + (i * this.dotSpacing);\n        this.pendingSpawns.push({ offset });\n      }\n    }\n  }\n\n  update(dt: number, _playerPosition: Vector2, bounds: Bounds): void {\n\n    if (this.isSpawning) {\n      this.spawnCompleteTime += dt * 1000;\n\n      const totalSpawnTime = DOT_SPAWN_ANIMATION_DURATION + (this.pendingSpawns.length * this.spawnDelay);\n      if (this.spawnCompleteTime >= totalSpawnTime) {\n        this.isSpawning = false;\n      }\n    }\n\n    if (!this.isSpawning) {\n      this.linePos += this.lineVelocity * dt;\n      if (this.isHorizontal) {\n        if (this.linePos >= bounds.height) {\n          this.linePos = bounds.height;\n          this.lineVelocity = -this.sweepSpeed;\n        } else if (this.linePos <= 0) {\n          this.linePos = 0;\n          this.lineVelocity = this.sweepSpeed;\n        }\n      } else {\n        if (this.linePos >= bounds.width) {\n          this.linePos = bounds.width;\n          this.lineVelocity = -this.sweepSpeed;\n        } else if (this.linePos <= 0) {\n          this.linePos = 0;\n          this.lineVelocity = this.sweepSpeed;\n        }\n      }\n    }\n\n    if (this.pendingSpawns.length > 0) {\n      this.spawnTimer += dt * 1000;\n      const lineLength = this.isHorizontal ? bounds.height : bounds.width;\n      while (this.spawnTimer >= this.spawnDelay && this.pendingSpawns.length > 0) {\n        this.spawnTimer -= this.spawnDelay;\n        const { offset } = this.pendingSpawns.shift()!;\n\n        if (this.isHorizontal) {\n          this.spawnDot(\n            this.lineOffset + offset - (lineLength / 2),\n            this.linePos,\n            { x: 0, y: this.lineVelocity }\n          );\n        } else {\n          this.spawnDot(\n            this.linePos,\n            this.lineOffset + offset - (lineLength / 2),\n            { x: this.lineVelocity, y: 0 }\n          );\n        }\n      }\n    }\n\n    const velocityX = this.isHorizontal ? 0 : this.lineVelocity;\n    const velocityY = this.isHorizontal ? this.lineVelocity : 0;\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n\n      if (dot.isFrozen()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n\n\n      if (!this.isSpawning) {\n        dot.position.x += velocityX * dt;\n        dot.position.y += velocityY * dt;\n        dot.velocity.x = velocityX;\n        dot.velocity.y = velocityY;\n        if (this.isHorizontal) {\n          dot.position.y = Math.max(0, Math.min(bounds.height, dot.position.y));\n        } else {\n          dot.position.x = Math.max(0, Math.min(bounds.width, dot.position.x));\n        }\n      }\n\n\n      if (this.isHorizontal) {\n        if (dot.position.x < -50 || dot.position.x > bounds.width + 50) {\n          dot.kill();\n        }\n      } else {\n        if (dot.position.y < -50 || dot.position.y > bounds.height + 50) {\n          dot.kill();\n        }\n      }\n\n      dot.update(dt, bounds, _playerPosition);\n    }\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      if (this.dots[i].isDead()) {\n        this.dots.splice(i, 1);\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.dots.length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\nexport class SparseGrid extends Pattern {\n  readonly type = PatternType.SPARSE_GRID;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private readonly dotSpeed: number = 20;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.dotSpeed = 40;\n        break;\n      case Difficulty.MEDIUM:\n        this.dotSpeed = 30;\n        break;\n      default:\n        this.dotSpeed = 20;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnGrid(bounds);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const dx = playerPosition.x - pos.x;\n      const dy = playerPosition.y - pos.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance > 0) {\n        const speed = distance > 50 ? this.dotSpeed : this.dotSpeed * (distance / 50);\n        dot.velocity.x = (dx / distance) * speed;\n        dot.velocity.y = (dy / distance) * speed;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnGrid(bounds: Bounds): void {\n    const margin = 100;\n    const spacing = 85;\n    const cols = Math.floor((bounds.width - margin * 2) / spacing);\n    const rows = Math.floor((bounds.height - margin * 2) / spacing);\n\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        const x = margin + col * spacing + spacing / 2;\n        const y = margin + row * spacing + spacing / 2;\n        this.spawnDot(x, y, { x: 0, y: 0 });\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\nexport class UltraSparseGrid extends Pattern {\n  readonly type = PatternType.ULTRA_SPARSE_GRID;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private readonly dotSpeed: number = 20;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.dotSpeed = 40;\n        break;\n      case Difficulty.MEDIUM:\n        this.dotSpeed = 30;\n        break;\n      default:\n        this.dotSpeed = 20;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnGrid(bounds);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const dx = playerPosition.x - pos.x;\n      const dy = playerPosition.y - pos.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance > 0) {\n        const speed = distance > 50 ? this.dotSpeed : this.dotSpeed * (distance / 50);\n        dot.velocity.x = (dx / distance) * speed;\n        dot.velocity.y = (dy / distance) * speed;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnGrid(bounds: Bounds): void {\n    const spacing = 170;\n    const cols = Math.floor(bounds.width / spacing);\n    const rows = Math.floor(bounds.height / spacing);\n    const offsetX = (bounds.width - cols * spacing) / 2;\n    const offsetY = (bounds.height - rows * spacing) / 2;\n\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        const x = offsetX + col * spacing + spacing / 2;\n        const y = offsetY + row * spacing + spacing / 2;\n        this.spawnDot(x, y, { x: 0, y: 0 });\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { DOT_RADIUS } from '../utils/constants';\n\ninterface DotOffset {\n  x: number;\n  y: number;\n}\n\nexport class BouncingBall extends Pattern {\n  readonly type = PatternType.BOUNCING_BALL;\n  difficulty: Difficulty = Difficulty.MEDIUM;\n\n  private readonly duration: number = 30000;\n  private readonly ballRadius: number = 120;\n  private readonly dotCount: number = 200;\n  private centerPosition: Vector2 = { x: 0, y: 0 };\n  private centerVelocity: Vector2 = { x: 0, y: 0 };\n  private dotOffsets: DotOffset[] = [];\n  private speed: number = 120;\n\n  constructor(difficulty: Difficulty = Difficulty.MEDIUM) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.speed = 180;\n        break;\n      case Difficulty.MEDIUM:\n        this.speed = 120;\n        break;\n      default:\n        this.speed = 80;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.centerPosition = {\n      x: bounds.width / 2,\n      y: bounds.height / 2\n    };\n\n    const angle = Math.random() * Math.PI * 2;\n    this.centerVelocity = {\n      x: Math.cos(angle) * this.speed,\n      y: Math.sin(angle) * this.speed\n    };\n\n    this.spawnDots();\n  }\n\n  private spawnDots(): void {\n    this.dotOffsets = [];\n\n    const dotsPerRing = 20;\n    const ringCount = Math.ceil(this.dotCount / dotsPerRing);\n\n    for (let ring = 0; ring < ringCount; ring++) {\n      const ringRadius = (this.ballRadius * (ring + 1)) / ringCount;\n      const dotsInThisRing = Math.min(dotsPerRing, this.dotCount - this.dotOffsets.length);\n\n      for (let i = 0; i < dotsInThisRing; i++) {\n        const angle = (i / dotsInThisRing) * Math.PI * 2;\n        this.dotOffsets.push({\n          x: Math.cos(angle) * ringRadius,\n          y: Math.sin(angle) * ringRadius\n        });\n      }\n\n      if (this.dotOffsets.length >= this.dotCount) break;\n    }\n\n    for (let i = 0; i < this.dotOffsets.length; i++) {\n      const offset = this.dotOffsets[i];\n      this.spawnDot(\n        this.centerPosition.x + offset.x,\n        this.centerPosition.y + offset.y,\n        { x: this.centerVelocity.x, y: this.centerVelocity.y }\n      );\n    }\n  }\n\n  update(dt: number, _playerPosition: Vector2, bounds: Bounds): void {\n    this.centerPosition.x += this.centerVelocity.x * dt;\n    this.centerPosition.y += this.centerVelocity.y * dt;\n\n    const minX = this.ballRadius + DOT_RADIUS;\n    const maxX = bounds.width - this.ballRadius - DOT_RADIUS;\n    const minY = this.ballRadius + DOT_RADIUS;\n    const maxY = bounds.height - this.ballRadius - DOT_RADIUS;\n\n    if (this.centerPosition.x <= minX) {\n      this.centerPosition.x = minX;\n      this.centerVelocity.x = Math.abs(this.centerVelocity.x);\n    } else if (this.centerPosition.x >= maxX) {\n      this.centerPosition.x = maxX;\n      this.centerVelocity.x = -Math.abs(this.centerVelocity.x);\n    }\n\n    if (this.centerPosition.y <= minY) {\n      this.centerPosition.y = minY;\n      this.centerVelocity.y = Math.abs(this.centerVelocity.y);\n    } else if (this.centerPosition.y >= maxY) {\n      this.centerPosition.y = maxY;\n      this.centerVelocity.y = -Math.abs(this.centerVelocity.y);\n    }\n\n    for (let i = 0; i < this.dots.length; i++) {\n      const dot = this.dots[i];\n      \n      // Skip frozen dots - they should not move\n      if (dot.isFrozen()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n      \n      const offset = this.dotOffsets[i];\n\n      if (offset && !dot.isDead()) {\n        // Calculate where the dot should be (expected position)\n        const expectedX = this.centerPosition.x + offset.x;\n        const expectedY = this.centerPosition.y + offset.y;\n        \n        // Calculate displacement caused by external forces (like DotRepellent)\n        const displacementX = dot.position.x - expectedX;\n        const displacementY = dot.position.y - expectedY;\n        \n        // Apply displacement to center position (allows DotRepellent to push the ball)\n        this.centerPosition.x += displacementX;\n        this.centerPosition.y += displacementY;\n        \n        // Re-calculate expected position after center displacement\n        const newExpectedX = this.centerPosition.x + offset.x;\n        const newExpectedY = this.centerPosition.y + offset.y;\n        \n        // Set dot to its proper relative position in the formation\n        dot.position.x = newExpectedX;\n        dot.position.y = newExpectedY;\n        dot.velocity.x = this.centerVelocity.x;\n        dot.velocity.y = this.centerVelocity.y;\n      }\n\n      dot.update(dt, bounds, _playerPosition);\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2, DotState } from '../types';\nimport { randomPosition } from '../utils/math';\nimport { DOT_RADIUS } from '../utils/constants';\nimport { Dot } from '../entities/Dot';\nimport { Renderer } from '../renderer/Renderer';\n\nexport class GatlingPoint extends Pattern {\n  readonly type = PatternType.GATLING_POINT;\n  difficulty: Difficulty = Difficulty.MEDIUM;\n\n  private shootDuration: number;\n  private readonly dotSpeed: number = 400;\n  private shootInterval: number = 100;\n  private elapsedSinceSpawn: number = 0;\n  private spawnPoint: Vector2 = { x: 0, y: 0 };\n  private spawnPointDot: Dot | null = null;\n  private readonly spawnPointRadius: number = DOT_RADIUS;\n  private spawnPointDead: boolean = false;\n  private cooldownDuration: number = 5000; // 5 seconds between bursts\n  private cooldownElapsed: number = 0;\n  private isShooting: boolean = false; // Start in spawn animation, then shooting mode\n  private shootingElapsed: number = 0;\n  private masterSpawnDuration: number = 1500; // 1.5 second spawn animation for master dot\n  private masterSpawnElapsed: number = 0;\n  private shotsFired: number = 0;\n  private readonly slowShotCount: number = 5; // First 5 shots are slower\n  private readonly slowShotSpeedMultiplier: number = 0.5; // Half speed for slow shots\n\n  constructor(difficulty: Difficulty = Difficulty.MEDIUM) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.shootDuration = 6000;\n        this.shootInterval = 50;\n        break;\n      case Difficulty.MEDIUM:\n        this.shootDuration = 4500;\n        this.shootInterval = 80;\n        break;\n      default:\n        this.shootDuration = 3000;\n        this.shootInterval = 100;\n    }\n  }\n\n  spawn(_center: Vector2, _bounds: Bounds): void {\n    this.start();\n    const margin = 50;\n    this.spawnPoint = randomPosition(_bounds, margin);\n    \n    this.spawnPointDot = new Dot(this.spawnPoint.x, this.spawnPoint.y, this.type);\n    // Master dot starts in SPAWNING state - will become ACTIVE after animation\n    // Use Object.defineProperty to override the readonly radius for the spawn point\n    Object.defineProperty(this.spawnPointDot, 'radius', {\n      value: this.spawnPointRadius,\n      writable: false,\n      configurable: true\n    });\n    this.dots.push(this.spawnPointDot);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.spawnPointDot && !this.spawnPointDead) {\n      if (this.spawnPointDot.isDead()) {\n        this.spawnPointDead = true;\n      } else if (this.spawnPointDot.isFrozen()) {\n        // Spawn point frozen - stop spawning\n      } else {\n        // Update master dot spawn animation first\n        this.updateMasterSpawnAnimation(dt);\n        this.updateShootingLogic(dt, playerPosition);\n      }\n    }\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n      const vel = dot.velocity;\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const radius = dot.radius;\n\n      // Bounce off walls - only reverse velocity when moving toward the wall\n      // and clamp position to prevent getting stuck\n      if (pos.x <= radius && vel.x < 0) {\n        vel.x = -vel.x * 0.5;\n        pos.x = radius + 1;\n      } else if (pos.x >= bounds.width - radius && vel.x > 0) {\n        vel.x = -vel.x * 0.5;\n        pos.x = bounds.width - radius - 1;\n      }\n      \n      if (pos.y <= radius && vel.y < 0) {\n        vel.y = -vel.y * 0.5;\n        pos.y = radius + 1;\n      } else if (pos.y >= bounds.height - radius && vel.y > 0) {\n        vel.y = -vel.y * 0.5;\n        pos.y = bounds.height - radius - 1;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private updateMasterSpawnAnimation(dt: number): void {\n    if (this.spawnPointDot && this.spawnPointDot.state === DotState.SPAWNING) {\n      this.masterSpawnElapsed += dt * 1000;\n      // Update the dot's internal spawn animation\n      this.spawnPointDot.update(dt, { width: 0, height: 0 });\n      \n      if (this.masterSpawnElapsed >= this.masterSpawnDuration) {\n        this.spawnPointDot.state = DotState.ACTIVE;\n        this.isShooting = true;\n      }\n    }\n  }\n\n  private updateShootingLogic(dt: number, playerPosition: Vector2): void {\n    if (this.isShooting) {\n      // Shooting phase\n      this.shootingElapsed += dt * 1000;\n      this.elapsedSinceSpawn += dt * 1000;\n      \n      if (this.elapsedSinceSpawn >= this.shootInterval) {\n        this.elapsedSinceSpawn = 0;\n        this.spawnDotAtPoint(playerPosition);\n      }\n      \n      // Check if shooting phase is done\n      if (this.shootingElapsed >= this.shootDuration) {\n        this.isShooting = false;\n        this.cooldownElapsed = 0;\n      }\n    } else {\n      // Cooldown phase - wait 5 seconds\n      this.cooldownElapsed += dt * 1000;\n      \n      if (this.cooldownElapsed >= this.cooldownDuration) {\n        // Start shooting again\n        this.isShooting = true;\n        this.shootingElapsed = 0;\n        this.elapsedSinceSpawn = 0;\n      }\n    }\n  }\n\n  private spawnDotAtPoint(playerPosition: Vector2): void {\n    const dx = playerPosition.x - this.spawnPoint.x;\n    const dy = playerPosition.y - this.spawnPoint.y;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    if (dist > 0) {\n      // Calculate speed - first few shots are slower\n      let speed = this.dotSpeed;\n      if (this.shotsFired < this.slowShotCount) {\n        speed = this.dotSpeed * this.slowShotSpeedMultiplier;\n      }\n      this.shotsFired++;\n\n      const dot = this.spawnDot(this.spawnPoint.x, this.spawnPoint.y, {\n        x: (dx / dist) * speed,\n        y: (dy / dist) * speed\n      });\n      // Skip spawn animation - make instantly active and lethal\n      dot.skipSpawnAnimation();\n    } else {\n      this.spawnDot(this.spawnPoint.x, this.spawnPoint.y);\n    }\n  }\n\n  isComplete(): boolean {\n    // Pattern is complete when master point is killed or frozen and all dots are gone\n    if (this.spawnPointDead || (this.spawnPointDot && this.spawnPointDot.isFrozen())) {\n      return this.getDots().length === 0;\n    }\n    // Master point is still alive - pattern never completes until killed\n    return false;\n  }\n\n  isActivelySpawning(): boolean {\n    if (this.spawnPointDead || (this.spawnPointDot && this.spawnPointDot.isFrozen())) {\n      return false;\n    }\n    return this.isShooting;\n  }\n\n  getSpawnPointDot(): Dot | null {\n    return this.spawnPointDot;\n  }\n\n  isSpawnPointDead(): boolean {\n    return this.spawnPointDead;\n  }\n  render(renderer: Renderer): void {\n    super.render?.(renderer);\n\n    if (this.spawnPointDot && !this.spawnPointDot.isDead() && !this.spawnPointDot.isFrozen()) {\n      const pos = this.spawnPointDot.getPosition();\n      const pulse = 1 + Math.sin(this.elapsedMs * 0.005) * 0.2;\n      \n      renderer.drawCircleOutline(\n        pos.x,\n        pos.y,\n        this.spawnPointRadius * pulse,\n        '#FFD700',\n        3\n      );\n      \n      renderer.drawCircleOutline(\n        pos.x,\n        pos.y,\n        this.spawnPointRadius * pulse * 1.3,\n        'rgba(255, 215, 0, 0.3)',\n        1\n      );\n    }\n  }\n}\n","import { Pattern } from './Pattern';\nimport { Dot } from '../entities/Dot';\nimport { Bounds, Vector2, DotState } from '../types';\nimport { DOT_RADIUS } from '../utils/constants';\nimport { Renderer } from '../renderer/Renderer';\n\ntype SpawnLocation = 'top' | 'bottom' | 'left' | 'right' | 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';\n\nconst SPAWN_LOCATIONS: SpawnLocation[] = ['top', 'bottom', 'left', 'right', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight'];\n\nexport abstract class BulletHellBase extends Pattern {\n  protected duration: number = 4000;\n  protected readonly baseDotSpeed: number = 250;\n  protected readonly spawnInterval: number = 150;\n  protected readonly masterRadius: number = DOT_RADIUS * 2;\n\n  protected originX: number = 0;\n  protected originY: number = 0;\n  protected spawnAccumulator: number = 0;\n  protected patternPhase: number = 0;\n  protected isShooting: boolean = false;\n  \n  private masterDot: Dot | null = null;\n  private masterDead: boolean = false;\n  private masterSpawnDuration: number = 1500;\n  private masterSpawnElapsed: number = 0;\n\n  protected abstract spawnPatternBullets(): void;\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnAccumulator = 0;\n    this.patternPhase = 0;\n    this.masterSpawnElapsed = 0;\n    this.masterDead = false;\n\n    const location = SPAWN_LOCATIONS[Math.floor(Math.random() * SPAWN_LOCATIONS.length)];\n    const pos = this.getSpawnPosition(bounds, location);\n    this.originX = pos.x;\n    this.originY = pos.y;\n\n    this.masterDot = new Dot(this.originX, this.originY, this.type);\n    Object.defineProperty(this.masterDot, 'radius', {\n      value: this.masterRadius,\n      writable: false,\n      configurable: true\n    });\n    this.dots.push(this.masterDot);\n  }\n\n  private getSpawnPosition(bounds: Bounds, location: SpawnLocation): Vector2 {\n    const margin = this.masterRadius + 5;\n    const w = bounds.width;\n    const h = bounds.height;\n\n    switch (location) {\n      case 'top':\n        return { x: w / 2, y: margin };\n      case 'bottom':\n        return { x: w / 2, y: h - margin };\n      case 'left':\n        return { x: margin, y: h / 2 };\n      case 'right':\n        return { x: w - margin, y: h / 2 };\n      case 'topLeft':\n        return { x: margin, y: margin };\n      case 'topRight':\n        return { x: w - margin, y: margin };\n      case 'bottomLeft':\n        return { x: margin, y: h - margin };\n      case 'bottomRight':\n        return { x: w - margin, y: h - margin };\n    }\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    if (this.masterDot && !this.masterDead) {\n      if (this.masterDot.isDead()) {\n        this.masterDead = true;\n      } else if (!this.masterDot.isFrozen()) {\n        this.updateMasterSpawnAnimation(dt);\n        \n        if (this.isShooting && this.elapsedMs <= this.duration + this.masterSpawnDuration) {\n          this.spawnAccumulator += dt * 1000;\n          \n          while (this.spawnAccumulator >= this.spawnInterval) {\n            this.spawnAccumulator -= this.spawnInterval;\n            this.spawnPatternBullets();\n          }\n        }\n\n        this.patternPhase += dt * 0.5;\n      }\n    }\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      \n      if (dot === this.masterDot) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n      \n      if (dot.isFrozen()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n      \n      const pos = dot.getPosition();\n\n      if (pos.x < -DOT_RADIUS || pos.x > bounds.width + DOT_RADIUS ||\n          pos.y < -DOT_RADIUS || pos.y > bounds.height + DOT_RADIUS) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      dot.position.x += dot.velocity.x * dt;\n      dot.position.y += dot.velocity.y * dt;\n    }\n  }\n\n  private updateMasterSpawnAnimation(dt: number): void {\n    if (this.masterDot && this.masterDot.state === DotState.SPAWNING) {\n      this.masterSpawnElapsed += dt * 1000;\n      this.masterDot.update(dt, { width: 0, height: 0 });\n      \n      if (this.masterSpawnElapsed >= this.masterSpawnDuration) {\n        this.masterDot.state = DotState.ACTIVE;\n        this.isShooting = true;\n      }\n    }\n  }\n\n  protected createBullet(angle: number, speedMultiplier: number = 1): Dot {\n    const speed = this.baseDotSpeed * speedMultiplier;\n    const dot = new Dot(this.originX, this.originY, this.type);\n    dot.velocity.x = Math.cos(angle) * speed;\n    dot.velocity.y = Math.sin(angle) * speed;\n    dot.state = DotState.ACTIVE;\n    dot.skipSpawnAnimation();\n    this.dots.push(dot);\n    return dot;\n  }\n\n  render(renderer: Renderer): void {\n    super.render?.(renderer);\n\n    if (this.masterDot && !this.masterDot.isDead() && !this.masterDot.isFrozen()) {\n      const pos = this.masterDot.getPosition();\n      const pulse = 1 + Math.sin(this.elapsedMs * 0.005) * 0.2;\n      \n      renderer.drawCircleOutline(\n        pos.x,\n        pos.y,\n        this.masterRadius * pulse,\n        '#FFD700',\n        3\n      );\n      \n      renderer.drawCircleOutline(\n        pos.x,\n        pos.y,\n        this.masterRadius * pulse * 1.3,\n        'rgba(255, 215, 0, 0.3)',\n        1\n      );\n    }\n  }\n\n  isComplete(): boolean {\n    if (this.masterDead || (this.masterDot && this.masterDot.isFrozen())) {\n      const remainingDots = this.dots.filter(d => d !== this.masterDot && !d.isDead());\n      return remainingDots.length === 0;\n    }\n    return false;\n  }\n\n  isActivelySpawning(): boolean {\n    if (this.masterDead || (this.masterDot && this.masterDot.isFrozen())) {\n      return false;\n    }\n    return this.isShooting;\n  }\n\n  getSpawnPointDot(): Dot | null {\n    return this.masterDot;\n  }\n\n  isSpawnPointDead(): boolean {\n    return this.masterDead;\n  }\n}\n","import { BulletHellBase } from './BulletHellBase';\nimport { PatternType, Difficulty } from '../types';\n\nexport class SpiralPattern extends BulletHellBase {\n  readonly type = PatternType.SPIRAL;\n  readonly difficulty: Difficulty = Difficulty.HARD;\n\n  constructor(difficulty: Difficulty = Difficulty.HARD) {\n    super();\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.duration = 4000;\n        break;\n      case Difficulty.MEDIUM:\n        this.duration = 3000;\n        break;\n    }\n  }\n\n  protected spawnPatternBullets(): void {\n    const arms = 3;\n    const bulletsPerArm = 2;\n    const spiralSpeed = 2.0;\n    \n    for (let arm = 0; arm < arms; arm++) {\n      const baseAngle = this.patternPhase * spiralSpeed + (arm * Math.PI * 2 / arms);\n      \n      for (let i = 0; i < bulletsPerArm; i++) {\n        const angle = baseAngle + i * 0.1;\n        const speedMult = 0.8 + i * 0.1;\n        this.createBullet(angle, speedMult);\n      }\n    }\n  }\n}\n","import { BulletHellBase } from './BulletHellBase';\nimport { PatternType, Difficulty } from '../types';\n\nexport class CircleBurstPattern extends BulletHellBase {\n  readonly type = PatternType.CIRCLE_BURST;\n  readonly difficulty: Difficulty = Difficulty.HARD;\n\n  constructor(difficulty: Difficulty = Difficulty.HARD) {\n    super();\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.duration = 4000;\n        break;\n      case Difficulty.MEDIUM:\n        this.duration = 3000;\n        break;\n    }\n  }\n\n  protected spawnPatternBullets(): void {\n    const bulletCount = 16;\n    const angleStep = (Math.PI * 2) / bulletCount;\n    \n    for (let i = 0; i < bulletCount; i++) {\n      const angle = i * angleStep + this.patternPhase * 0.5;\n      this.createBullet(angle);\n    }\n  }\n}\n","import { BulletHellBase } from './BulletHellBase';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\nexport class AimedStreamsPattern extends BulletHellBase {\n  readonly type = PatternType.AIMED_STREAMS;\n  readonly difficulty: Difficulty = Difficulty.HARD;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n\n  constructor(difficulty: Difficulty = Difficulty.HARD) {\n    super();\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.duration = 4000;\n        break;\n      case Difficulty.MEDIUM:\n        this.duration = 3000;\n        break;\n    }\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    this.playerPosition = playerPosition;\n    super.update(dt, playerPosition, bounds);\n  }\n\n  protected spawnPatternBullets(): void {\n    const streamCount = 5;\n    const baseAngle = Math.atan2(\n      this.playerPosition.y - this.originY,\n      this.playerPosition.x - this.originX\n    );\n    \n    for (let i = 0; i < streamCount; i++) {\n      const spread = (i - Math.floor(streamCount / 2)) * 0.15;\n      const angle = baseAngle + spread;\n      const speedMult = 0.9 + Math.random() * 0.2;\n      this.createBullet(angle, speedMult);\n    }\n  }\n}\n","import { BulletHellBase } from './BulletHellBase';\nimport { PatternType, Difficulty } from '../types';\n\nexport class WavePattern extends BulletHellBase {\n  readonly type = PatternType.WAVE;\n  readonly difficulty: Difficulty = Difficulty.HARD;\n\n  constructor(difficulty: Difficulty = Difficulty.HARD) {\n    super();\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.duration = 4000;\n        break;\n      case Difficulty.MEDIUM:\n        this.duration = 3000;\n        break;\n    }\n  }\n\n  protected spawnPatternBullets(): void {\n    const waveWidth = Math.PI;\n    const bulletsInWave = 7;\n    const baseAngle = Math.PI / 2 + Math.sin(this.patternPhase * 2) * 0.3;\n    \n    for (let i = 0; i < bulletsInWave; i++) {\n      const waveOffset = (i / (bulletsInWave - 1) - 0.5) * waveWidth;\n      const angle = baseAngle + waveOffset;\n      const speedMult = 0.7 + Math.abs(waveOffset) * 0.3;\n      this.createBullet(angle, speedMult);\n    }\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\nexport class ContainmentRing extends Pattern {\n  readonly type = PatternType.CONTAINMENT_RING;\n  difficulty: Difficulty = Difficulty.EASY;\n\n  private readonly ringRadius: number = 100;\n  private readonly dotSpeed: number = 30;\n  private readonly dotCount: number = 40;\n  private readonly innerRadius: number = 20;\n\n  constructor(difficulty: Difficulty = Difficulty.EASY) {\n    super();\n    this.difficulty = difficulty;\n  }\n\n  spawn(center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnRing(center, bounds);\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      if (pos.x < -100 || pos.x > bounds.width + 100 ||\n          pos.y < -100 || pos.y > bounds.height + 100) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      const dx = playerPosition.x - pos.x;\n      const dy = playerPosition.y - pos.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > this.innerRadius) {\n        dot.velocity.x = (dx / dist) * this.dotSpeed;\n        dot.velocity.y = (dy / dist) * this.dotSpeed;\n      } else {\n        dot.velocity.x = 0;\n        dot.velocity.y = 0;\n      }\n\n      dot.update(dt, bounds, playerPosition);\n    }\n  }\n\n  private spawnRing(center: Vector2, _bounds: Bounds): void {\n    const gapCount = Math.floor(Math.random() * 5);\n    const gapSize = gapCount > 0 ? 2 : 0;\n    const gaps: Array<[number, number]> = [];\n\n    for (let g = 0; g < gapCount; g++) {\n      const gapCenter = (this.dotCount * g) / gapCount + Math.floor(this.dotCount / (gapCount * 2));\n      const gapStart = gapCenter - gapSize;\n      const gapEnd = gapCenter + gapSize;\n      gaps.push([gapStart, gapEnd]);\n    }\n\n    for (let i = 0; i < this.dotCount; i++) {\n      const inGap = gaps.some(([start, end]) => i >= start && i <= end);\n      if (inGap) continue;\n\n      const angle = (2 * Math.PI * i) / this.dotCount;\n      const x = center.x + this.ringRadius * Math.cos(angle);\n      const y = center.y + this.ringRadius * Math.sin(angle);\n      this.spawnDot(x, y);\n    }\n  }\n\n  isComplete(): boolean {\n    return this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\n\n\nexport class Cyclone extends Pattern {\n  readonly type = PatternType.CYCLONE;\n  difficulty: Difficulty = Difficulty.HARD;\n\n  private readonly duration: number = 25000;\n  private circleRadius: number = 50;\n  private dotSpeed: number = 150;\n\n  constructor(difficulty: Difficulty = Difficulty.HARD) {\n    super();\n    this.difficulty = difficulty;\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.dotSpeed = 300;\n        this.circleRadius = 80;\n        break;\n      case Difficulty.MEDIUM:\n        this.dotSpeed = 200;\n        this.circleRadius = 60;\n        break;\n      default:\n        this.dotSpeed = 150;\n        this.circleRadius = 50;\n    }\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.spawnDots(bounds);\n  }\n\n  update(dt: number, _playerPosition: Vector2, bounds: Bounds): void {\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      const dot = this.dots[i];\n      if (!dot.isLethal()) {\n        dot.update(dt, bounds, _playerPosition);\n        continue;\n      }\n\n      const pos = dot.getPosition();\n\n      // Remove dots that have flown off-screen\n      if (pos.x < -50 || pos.x > bounds.width + 50 ||\n          pos.y < -50 || pos.y > bounds.height + 50) {\n        this.dots.splice(i, 1);\n        continue;\n      }\n\n      dot.update(dt, bounds, _playerPosition);\n    }\n  }\n\n  private spawnDots(bounds: Bounds): void {\n    // Randomly pick one of the four corners\n    const corners = [\n      { x: bounds.width * 0.15, y: bounds.height * 0.15 },      // Top-left\n      { x: bounds.width * 0.85, y: bounds.height * 0.15 },      // Top-right\n      { x: bounds.width * 0.15, y: bounds.height * 0.85 },      // Bottom-left\n      { x: bounds.width * 0.85, y: bounds.height * 0.85 },      // Bottom-right\n    ];\n    const corner = corners[Math.floor(Math.random() * corners.length)];\n    const dotCount = 150;\n\n    for (let i = 0; i < dotCount; i++) {\n      const angle = (i / dotCount) * Math.PI * 2;\n      const offsetAngle = angle + (Math.random() - 0.5) * 0.2;\n      const radius = this.circleRadius * (0.8 + Math.random() * 0.4);\n      const x = corner.x + Math.cos(offsetAngle) * radius;\n      const y = corner.y + Math.sin(offsetAngle) * radius;\n\n      const velAngle = offsetAngle + Math.PI / 2 + (Math.random() - 0.5) * 0.5;\n      const speed = this.dotSpeed * (0.5 + Math.random() * 1);\n      this.spawnDot(x, y, {\n        x: Math.cos(velAngle) * speed,\n        y: Math.sin(velAngle) * speed\n      });\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.getDots().length === 0;\n  }\n}\n","import { Pattern } from './Pattern';\nimport { PatternType, Difficulty, Bounds, Vector2 } from '../types';\nimport { Dot } from '../entities/Dot';\n\ninterface ClockHand {\n  angle: number;\n  speed: number;\n  length: number;\n  dotCount: number;\n  gaps: number[];\n  dots: Array<{ index: number; distance: number; dot: Dot | null }>;\n}\n\nexport class ClockSweep extends Pattern {\n  readonly type = PatternType.CLOCK_SWEEP;\n  difficulty: Difficulty = Difficulty.MEDIUM;\n\n  private readonly duration: number = 25000;\n  private center: Vector2 = { x: 0, y: 0 };\n  private hands: ClockHand[] = [];\n  private spawnProgress: number = 0;\n  private readonly spawnDuration: number = 3500;\n  private hasFinishedSpawning: boolean = false;\n\n  private readonly secondHandSpeed = 0.5;\n  private readonly secondHandLength = 400;\n  private readonly secondHandDotCount = 15;\n\n  private readonly minuteHandSpeed = 0.4;\n  private readonly minuteHandLength = 350;\n  private readonly minuteHandDotCount = 20;\n\n  private readonly hourHandSpeed = 0.15;\n  private readonly hourHandLength = 200;\n  private readonly hourHandDotCount = 25;\n\n  constructor(difficulty: Difficulty = Difficulty.MEDIUM) {\n    super();\n    this.difficulty = difficulty;\n\n    switch (difficulty) {\n      case Difficulty.HARD:\n        this.hands = [\n          this.createHand(this.secondHandSpeed * 1.3, this.secondHandLength, this.secondHandDotCount, []),\n          this.createHand(this.minuteHandSpeed * 1.2, this.minuteHandLength, this.minuteHandDotCount, [8, 9, 10]),\n          this.createHand(this.hourHandSpeed * 1.2, this.hourHandLength, this.hourHandDotCount + 5, []),\n        ];\n        break;\n      case Difficulty.MEDIUM:\n        this.hands = [\n          this.createHand(this.secondHandSpeed, this.secondHandLength, this.secondHandDotCount, []),\n          this.createHand(this.minuteHandSpeed, this.minuteHandLength, this.minuteHandDotCount, [9, 10, 11]),\n          this.createHand(this.hourHandSpeed, this.hourHandLength, this.hourHandDotCount, []),\n        ];\n        break;\n      default:\n        this.hands = [\n          this.createHand(this.secondHandSpeed * 0.8, this.secondHandLength * 0.9, this.secondHandDotCount - 3, []),\n          this.createHand(this.minuteHandSpeed * 0.8, this.minuteHandLength * 0.9, this.minuteHandDotCount - 3, [9, 10]),\n          this.createHand(this.hourHandSpeed * 0.8, this.hourHandLength * 0.9, this.hourHandDotCount - 5, []),\n        ];\n    }\n  }\n\n  private createHand(speed: number, length: number, dotCount: number, gapIndices: number[]): ClockHand {\n    const dots: Array<{ index: number; distance: number; dot: Dot | null }> = [];\n    const spacing = length / (dotCount - 1);\n\n    for (let i = 0; i < dotCount; i++) {\n      if (gapIndices.includes(i)) continue;\n      dots.push({\n        index: i,\n        distance: i * spacing,\n        dot: null,\n      });\n    }\n\n    return {\n      angle: Math.random() * Math.PI * 2,\n      speed,\n      length,\n      dotCount,\n      gaps: gapIndices,\n      dots,\n    };\n  }\n\n  spawn(_center: Vector2, bounds: Bounds): void {\n    this.start();\n    this.center = { x: bounds.width / 2, y: bounds.height / 2 };\n    this.spawnProgress = 0;\n    this.hasFinishedSpawning = false;\n\n    for (const hand of this.hands) {\n      for (const dotInfo of hand.dots) {\n        const x = this.center.x + Math.cos(hand.angle) * dotInfo.distance;\n        const y = this.center.y + Math.sin(hand.angle) * dotInfo.distance;\n        const dot = this.spawnDot(x, y, { x: 0, y: 0 });\n        dotInfo.dot = dot;\n      }\n    }\n  }\n\n  update(dt: number, playerPosition: Vector2, bounds: Bounds): void {\n    if (!this.hasFinishedSpawning) {\n      this.spawnProgress += dt * 1000;\n      if (this.spawnProgress >= this.spawnDuration) {\n        this.hasFinishedSpawning = true;\n      }\n    }\n\n    for (const hand of this.hands) {\n      hand.angle += hand.speed * dt;\n    }\n\n    for (const hand of this.hands) {\n      for (const dotInfo of hand.dots) {\n        const dot = dotInfo.dot;\n\n        if (!dot || dot.isDead()) {\n          continue;\n        }\n\n        if (dot.isFrozen()) {\n          dot.update(dt, bounds, playerPosition);\n          continue;\n        }\n\n        if (!this.hasFinishedSpawning) {\n          dot.update(dt, bounds, playerPosition);\n          continue;\n        }\n\n        const dx = dot.position.x - this.center.x;\n        const dy = dot.position.y - this.center.y;\n        \n        const tangentialVx = -hand.speed * dy;\n        const tangentialVy = hand.speed * dx;\n\n        dot.position.x += tangentialVx * dt;\n        dot.position.y += tangentialVy * dt;\n        dot.velocity.x = tangentialVx;\n        dot.velocity.y = tangentialVy;\n\n        dot.update(dt, bounds, playerPosition);\n      }\n    }\n\n    for (let i = this.dots.length - 1; i >= 0; i--) {\n      if (this.dots[i].isDead()) {\n        this.dots.splice(i, 1);\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.elapsedMs > this.duration && this.dots.length === 0;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport class Blaster extends Weapon {\n  readonly type = WeaponType.BLASTER;\n\n  private state: 'AIMING' | 'FIRING' | 'COMPLETE' = 'AIMING';\n  private aimTime: number = 1000;\n  private aimStartTime: number = 0;\n  private beamPosition: number = 0;\n  private prevBeamPosition: number = 0;\n  private beamAngle: number = 0;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n  private playerAngle: number = 0;\n  private beamOriginPosition: Vector2 = { x: 0, y: 0 };\n\n  // Beam dimensions - must match visual rendering exactly\n  private readonly BEAM_WIDTH = 10;  // Visual width, perpendicular to beam direction\n  private readonly BEAM_LENGTH = 150;\n  private readonly BEAM_SPEED = 600;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.dots = dots;\n    this.aimStartTime = Date.now();\n\n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n    this.beamAngle = this.playerAngle;\n\n    this.state = 'AIMING';\n  }\n\n  update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    if (this.state === 'COMPLETE') return;\n\n    const elapsed = Date.now() - this.aimStartTime;\n\n    if (this.state === 'AIMING') {\n      this.playerPosition = player.getPosition();\n      this.playerAngle = player.directionAngle;\n\n      if (elapsed >= this.aimTime) {\n        this.state = 'FIRING';\n        this.beamAngle = this.playerAngle;\n        this.beamOriginPosition = { ...this.playerPosition };\n      }\n    } else if (this.state === 'FIRING') {\n      this.prevBeamPosition = this.beamPosition;\n      this.beamPosition += this.BEAM_SPEED * dt;\n      this.checkBeamCollision(dots);\n      // Continue beam well past screen edge for better visibility\n      const maxDistance = Math.max(bounds.width, bounds.height) * 1.5;\n      if (this.beamPosition > maxDistance) {\n        this.state = 'COMPLETE';\n      }\n    }\n  }\n\n  checkBeamCollision(dots: Dot[]): void {\n    if (!dots || dots.length === 0) return;\n    const cos = Math.cos(this.beamAngle);\n    const sin = Math.sin(this.beamAngle);\n    // Beam dimensions match visual exactly, small tolerance for dot radius\n    const halfWidth = this.BEAM_WIDTH / 2 + 2;  // 7px half-width\n    const halfLength = this.BEAM_LENGTH / 2 + 2;  // 77px half-length\n    for (const dot of dots) {\n      if (!dot.isDead()) {\n        const dotPos = dot.getPosition();\n        const dotRadius = dot.getRadius();\n        // Transform dot position to beam-local coordinates\n        // In rotated frame where beam is drawn:\n        //   localX = distance along beam sweep direction (beam is 10px long in this axis)\n        //   localY = distance perpendicular to beam (beam is 150px wide in this axis)\n        const dx = dotPos.x - this.beamOriginPosition.x;\n        const dy = dotPos.y - this.beamOriginPosition.y;\n        const localX = dx * cos + dy * sin;  // along beam sweep direction\n        const localY = -dx * sin + dy * cos; // perpendicular to beam (width)\n\n        // Check if dot is within beam width (perpendicular) - 150px wide\n        if (Math.abs(localY) > halfLength + dotRadius) continue;\n\n        // The beam sweeps along localX, centered at beamPosition, extending halfWidth (5px)\n        const beamFront = this.beamPosition + halfWidth;\n        const beamBack = this.beamPosition - halfWidth;\n        const prevBeamFront = this.prevBeamPosition + halfWidth;\n        const prevBeamBack = this.prevBeamPosition - halfWidth;\n\n        // Dot is hit if it overlaps with the beam's swept area\n        const sweepStart = Math.min(beamBack, prevBeamBack);\n        const sweepEnd = Math.max(beamFront, prevBeamFront);\n\n        if (localX >= sweepStart && localX <= sweepEnd) {\n          dot.kill();\n          this.addKilledDot();\n        }\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'COMPLETE') return;\n\n    const ctx = renderer.getContext();\n\n    if (this.state === 'AIMING') {\n      const x = this.playerPosition.x;\n      const y = this.playerPosition.y;\n\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(this.playerAngle);\n\n      ctx.fillStyle = 'rgb(128, 0, 128)';\n      ctx.fillRect(0, -6, 20, 12);\n\n      ctx.restore();\n    } else if (this.state === 'FIRING') {\n      const x = this.beamOriginPosition.x + this.beamPosition * Math.cos(this.beamAngle);\n      const y = this.beamOriginPosition.y + this.beamPosition * Math.sin(this.beamAngle);\n\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(this.beamAngle);\n\n      ctx.fillStyle = 'rgba(128, 0, 255, 0.78)';\n      ctx.fillRect(-5, -75, 10, 150);\n\n      ctx.restore();\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { WEAPON_COLORS } from '../utils/constants';\n\nexport class Chainsaw extends Weapon {\n  readonly type = WeaponType.CHAINSAW;\n\n  private readonly duration: number = 5000;\n  private readonly chainsawRadius: number = 50;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n\n  private readonly warningStartTime: number = 4200;\n  private readonly flashDuration: number = 100;\n  private readonly flashGap: number = 300;\n\n  activate(player: Player, _dots: Dot[]): void {\n    this.start();\n    this.playerPosition = player.getPosition();\n  }\n\n  update(_dt: number, player: Player, dots: Dot[], _bounds: Bounds): void {\n    if (this.getElapsedTime() >= this.duration) return;\n    if (!dots || dots.length === 0) return;\n    this.playerPosition = player.getPosition();\n\n    for (const dot of dots) {\n      if (dot.isDead()) continue;\n      const pos = dot.getPosition();\n      const dx = pos.x - this.playerPosition.x;\n      const dy = pos.y - this.playerPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.chainsawRadius) {\n        dot.kill();\n        this.addKilledDot();\n      }\n    }\n  }\n\n  private shouldShowVisual(): boolean {\n    const elapsed = this.getElapsedTime();\n\n    if (elapsed < this.warningStartTime) {\n      return true;\n    }\n\n    const warningElapsed = elapsed - this.warningStartTime;\n    const isFirstFlashOff = warningElapsed < this.flashDuration;\n    const isSecondFlashOff = warningElapsed >= this.flashGap &&\n                              warningElapsed < this.flashGap + this.flashDuration;\n\n    return !isFirstFlashOff && !isSecondFlashOff;\n  }\n\n  render(renderer: Renderer): void {\n    if (!this.shouldShowVisual()) return;\n    \n    const elapsed = this.getElapsedTime();\n    const rotation = (elapsed / 50) % (Math.PI * 2); // Spinning rotation\n    const numTeeth = 8;\n    const innerRadius = this.chainsawRadius * 0.7;\n    const outerRadius = this.chainsawRadius;\n    \n    // Draw base circle (semi-transparent)\n    renderer.drawCircle(this.playerPosition.x, this.playerPosition.y, this.chainsawRadius, WEAPON_COLORS.CHAINSAW + '66');\n    \n    // Draw spinning triangular teeth\n    const ctx = renderer.getContext();\n    ctx.save();\n    ctx.translate(this.playerPosition.x, this.playerPosition.y);\n    ctx.rotate(rotation);\n    \n    ctx.fillStyle = '#E0E0E0';\n    for (let i = 0; i < numTeeth; i++) {\n      const angle = (i / numTeeth) * Math.PI * 2;\n      const nextAngle = ((i + 1) / numTeeth) * Math.PI * 2;\n      \n      // Draw triangular tooth\n      ctx.beginPath();\n      ctx.moveTo(\n        Math.cos(angle) * innerRadius,\n        Math.sin(angle) * innerRadius\n      );\n      ctx.lineTo(\n        Math.cos(angle + (nextAngle - angle) * 0.5) * outerRadius,\n        Math.sin(angle + (nextAngle - angle) * 0.5) * outerRadius\n      );\n      ctx.lineTo(\n        Math.cos(nextAngle) * innerRadius,\n        Math.sin(nextAngle) * innerRadius\n      );\n      ctx.closePath();\n      ctx.fill();\n    }\n    \n    // Draw center hub\n    ctx.fillStyle = '#808080';\n    ctx.beginPath();\n    ctx.arc(0, 0, innerRadius * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.restore();\n  }\n\n  isComplete(): boolean {\n    return this.getElapsedTime() >= this.duration;\n  }\n\n  getChainsawRadius(): number {\n    return this.chainsawRadius;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport class DotRepellent extends Weapon {\n  readonly type = WeaponType.DOT_REPELLENT;\n\n  private readonly duration: number = 8000;\n  private readonly fieldRadius: number = 100;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n\n  activate(player: Player, _dots: Dot[]): void {\n    this.start();\n    this.dots = [];\n    this.playerPosition = player.getPosition();\n  }\n\n  update(_dt: number, player: Player, dots: Dot[], _bounds: Bounds): void {\n    const elapsed = this.getElapsedTime();\n    if (elapsed >= this.duration) return;\n    if (!dots || dots.length === 0) return;\n\n    this.playerPosition = player.getPosition();\n\n    for (const dot of dots) {\n      if (dot.isDead() || dot.isFrozen()) continue;\n\n      const dotPos = dot.getPosition();\n      const dx = dotPos.x - this.playerPosition.x;\n      const dy = dotPos.y - this.playerPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < this.fieldRadius && distance > 0) {\n        const push = 5 * (1 - distance / this.fieldRadius);\n        dot.position.x += (dx / distance) * push;\n        dot.position.y += (dy / distance) * push;\n      }\n    }\n  }\n\n  render(_renderer: Renderer): void {\n    const ctx = _renderer.getContext();\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.arc(\n      this.playerPosition.x,\n      this.playerPosition.y,\n      this.fieldRadius,\n      0,\n      Math.PI * 2\n    );\n    ctx.strokeStyle = 'rgba(128, 128, 128, 0.3)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  isComplete(): boolean {\n    return this.getElapsedTime() >= this.duration;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\n\ninterface ChainNode {\n  x: number;\n  y: number;\n  radius: number;\n  activatedAt: number;\n  chainDepth: number;\n  parentX?: number;\n  parentY?: number;\n}\n\ninterface LightningArc {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  createdAt: number;\n  chainDepth: number;\n}\n\nexport class ElectricBomb extends Weapon {\n  readonly type = WeaponType.ELECTRIC_BOMB;\n\n  private state: 'ROLLING' | 'CHAINING' | 'COMPLETE' = 'ROLLING';\n  private orbPosition: Vector2 = { x: 0, y: 0 };\n  private orbVelocity: Vector2 = { x: 0, y: 0 };\n  private chainNodes: ChainNode[] = [];\n  private lightningArcs: LightningArc[] = [];\n  private dotsToProcess: Dot[] = [];\n  private readonly initialRadiusFactor: number = 0.25;\n  private readonly chainRadiusFactor: number = 0.10;\n  private readonly maxChainDepth: number = 1000;\n\n  private orbRadius: number = 12;\n  private rollingDuration: number = 1500;\n  private chainDelayMs: number = 80;\n  private lastChainTime: number = 0;\n  private bounds: Bounds | null = null;\n  private lastCollisionTime: number = 0;\n  private readonly collisionCooldown: number = 100;\n\n  activate(player: Player, dots: Dot[], initialPosition?: { x: number; y: number }): void {\n    this.dots = dots;\n    this.start();\n\n    // Use provided position (from WeaponOrb) or fallback to player position\n    if (initialPosition) {\n      this.orbPosition = { x: initialPosition.x, y: initialPosition.y };\n    } else {\n      this.orbPosition = { ...player.getPosition() };\n    }\n\n    // Start with zero velocity like NuclearBomb - inherits momentum from nudging\n    this.orbVelocity = { x: 0, y: 0 };\n\n    this.state = 'ROLLING';\n  }\n\n  update(_dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    if (this.bounds === null) {\n      this.bounds = bounds;\n    }\n\n    switch (this.state) {\n      case 'ROLLING':\n        this.updateRolling(_dt, bounds);\n        break;\n\n      case 'CHAINING':\n        this.updateChaining(dots, player, bounds);\n        break;\n\n      case 'COMPLETE':\n        break;\n    }\n  }\n\n  getPosition(): Vector2 {\n    return this.orbPosition;\n  }\n\n  getRadius(): number {\n    return this.orbRadius;\n  }\n\n  handlePlayerCollision(_player: Player, playerVelocity: Vector2): boolean {\n    const now = Date.now();\n    if (now - this.lastCollisionTime < this.collisionCooldown) {\n      return false;\n    }\n    this.lastCollisionTime = now;\n\n    const dx = this.orbPosition.x - _player.position.x;\n    const dy = this.orbPosition.y - _player.position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    const minSpeed = 50;\n    const playerSpeed = Math.sqrt(playerVelocity.x ** 2 + playerVelocity.y ** 2);\n\n    if (playerSpeed < minSpeed) {\n      return false;\n    }\n\n    if (distance === 0) {\n      this.orbVelocity.x = playerVelocity.x;\n      this.orbVelocity.y = playerVelocity.y;\n      return true;\n    }\n\n    const nx = dx / distance;\n    const ny = dy / distance;\n    const tx = -ny;\n    const ty = nx;\n\n    const vDotN = playerVelocity.x * nx + playerVelocity.y * ny;\n    const vDotT = playerVelocity.x * tx + playerVelocity.y * ty;\n\n    const directness = vDotN / playerSpeed;\n\n    if (directness < 0.1) {\n      return false;\n    }\n\n    const velocityMultiplier = 1.5;\n\n    if (directness > 0.7) {\n      this.orbVelocity.x = playerVelocity.x * velocityMultiplier;\n      this.orbVelocity.y = playerVelocity.y * velocityMultiplier;\n    } else {\n      const forwardFactor = directness;\n      const sidewaysFactor = 1 - directness;\n\n      this.orbVelocity.x = (nx * vDotN * forwardFactor + tx * vDotT * sidewaysFactor) * velocityMultiplier;\n      this.orbVelocity.y = (ny * vDotN * forwardFactor + ty * vDotT * sidewaysFactor) * velocityMultiplier;\n    }\n\n    return true;\n  }\n\n  private updateRolling(dt: number, bounds: Bounds): void {\n    this.orbPosition.x += this.orbVelocity.x * dt;\n    this.orbPosition.y += this.orbVelocity.y * dt;\n\n    if (this.orbPosition.x - this.orbRadius < 0) {\n      this.orbPosition.x = this.orbRadius;\n      this.orbVelocity.x = Math.abs(this.orbVelocity.x);\n    } else if (this.orbPosition.x + this.orbRadius > bounds.width) {\n      this.orbPosition.x = bounds.width - this.orbRadius;\n      this.orbVelocity.x = -Math.abs(this.orbVelocity.x);\n    }\n\n    if (this.orbPosition.y - this.orbRadius < 0) {\n      this.orbPosition.y = this.orbRadius;\n      this.orbVelocity.y = Math.abs(this.orbVelocity.y);\n    } else if (this.orbPosition.y + this.orbRadius > bounds.height) {\n      this.orbPosition.y = bounds.height - this.orbRadius;\n      this.orbVelocity.y = -Math.abs(this.orbVelocity.y);\n    }\n\n    if (this.getElapsedTime() >= this.rollingDuration) {\n      this.triggerInitialExplosion();\n    }\n  }\n\n  private triggerInitialExplosion(): void {\n    this.state = 'CHAINING';\n    this.lastChainTime = Date.now();\n\n\n    const radius = (this.bounds?.width ?? 800) * this.initialRadiusFactor;\n    \n    this.chainNodes.push({\n      x: this.orbPosition.x,\n      y: this.orbPosition.y,\n      radius,\n      activatedAt: Date.now(),\n      chainDepth: 0\n    });\n\n    this.findAndElectrifyDots(this.chainNodes[0]);\n  }\n\n  private findAndElectrifyDots(node: ChainNode): void {\n    for (const dot of this.dots) {\n      if (dot.isDead()) continue;\n      \n      const pos = dot.getPosition();\n      const dx = pos.x - node.x;\n      const dy = pos.y - node.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      if (distance <= node.radius) {\n        dot.kill();\n        this.addKilledDot();\n        \n        this.lightningArcs.push({\n          x1: node.x,\n          y1: node.y,\n          x2: pos.x,\n          y2: pos.y,\n          createdAt: Date.now(),\n          chainDepth: node.chainDepth\n        });\n        \n        const newNode: ChainNode = {\n          x: pos.x,\n          y: pos.y,\n          radius: (this.bounds?.width ?? 800) * this.chainRadiusFactor,\n          activatedAt: Date.now(),\n          chainDepth: node.chainDepth + 1,\n          parentX: node.x,\n          parentY: node.y\n        };\n        \n        this.chainNodes.push(newNode);\n        this.dotsToProcess.push(dot);\n      }\n    }\n  }\n\n  private updateChaining(dots: Dot[], player: Player, _bounds: Bounds): void {\n    if (!dots || dots.length === 0) {\n      this.state = 'COMPLETE';\n      return;\n    }\n\n    const now = Date.now();\n\n    if (now - this.lastChainTime < this.chainDelayMs) {\n      return;\n    }\n\n    this.lastChainTime = now;\n\n    const pendingNodes = this.chainNodes.filter(n =>\n      n.chainDepth > 0 &&\n      now - n.activatedAt < 100 &&\n      n.chainDepth < this.maxChainDepth\n    );\n\n    if (pendingNodes.length === 0) {\n      this.checkPlayerHit(player);\n\n      const activeNodes = this.chainNodes.filter(n =>\n        now - n.activatedAt < 600\n      );\n\n      // Complete if no active nodes OR if only the initial node (depth 0) exists\n      // (meaning the chain never started because no dots were in range)\n      const hasChainNodes = this.chainNodes.some(n => n.chainDepth > 0);\n\n      if (activeNodes.length === 0 || !hasChainNodes) {\n        this.state = 'COMPLETE';\n      }\n      return;\n    }\n\n    for (const node of pendingNodes) {\n      this.findAndElectrifyDots(node);\n    }\n\n    this.checkPlayerHit(player);\n  }\n\n  private checkPlayerHit(_player: Player): void {\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'ROLLING') {\n      renderer.drawCircle(\n        this.orbPosition.x,\n        this.orbPosition.y,\n        this.orbRadius,\n        '#00FFFF'\n      );\n\n      renderer.drawCircleOutline(\n        this.orbPosition.x,\n        this.orbPosition.y,\n        this.orbRadius + 4,\n        'rgba(0, 255, 255, 0.5)',\n        2\n      );\n    } else if (this.state === 'CHAINING' || this.state === 'COMPLETE') {\n      this.renderChainNodes(renderer);\n      this.renderLightning(renderer);\n    }\n  }\n\n  private renderChainNodes(renderer: Renderer): void {\n    const now = Date.now();\n    const fadeTime = 500;\n\n    this.chainNodes = this.chainNodes.filter(node => now - node.activatedAt < fadeTime + 100);\n\n    for (const node of this.chainNodes) {\n      const age = now - node.activatedAt;\n      const opacity = Math.max(0, 1 - age / fadeTime);\n\n      if (opacity > 0) {\n        renderer.drawCircle(\n          node.x,\n          node.y,\n          node.radius,\n          `rgba(0, 255, 255, ${opacity * 0.3})`\n        );\n\n        renderer.drawCircleOutline(\n          node.x,\n          node.y,\n          node.radius,\n          `rgba(0, 255, 255, ${opacity})`,\n          3\n        );\n      }\n    }\n  }\n\n  private renderLightning(renderer: Renderer): void {\n    const now = Date.now();\n    const lightningFadeTime = 500;\n\n    this.lightningArcs = this.lightningArcs.filter(arc => now - arc.createdAt < lightningFadeTime);\n\n    for (const arc of this.lightningArcs) {\n      const age = now - arc.createdAt;\n      const opacity = Math.max(0, 1 - age / lightningFadeTime);\n\n      if (opacity > 0) {\n        this.drawJaggedLightning(\n          renderer,\n          arc.x1,\n          arc.y1,\n          arc.x2,\n          arc.y2,\n          opacity,\n          arc.chainDepth\n        );\n      }\n    }\n  }\n\n  private drawJaggedLightning(\n    renderer: Renderer,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    opacity: number,\n    chainDepth: number\n  ): void {\n    const segments = 3 + Math.min(chainDepth, 3);\n    const jitter = 6 + chainDepth * 2;\n    const color = `rgba(0, 200, 255, ${opacity})`;\n    const glowColor = `rgba(100, 230, 255, ${opacity * 0.5})`;\n\n    const points: { x: number; y: number }[] = [];\n    points.push({ x: x1, y: y1 });\n\n    for (let i = 1; i < segments; i++) {\n      const t = i / segments;\n      const baseX = x1 + (x2 - x1) * t;\n      const baseY = y1 + (y2 - y1) * t;\n\n      const offsetX = (Math.random() - 0.5) * jitter * 2;\n      const offsetY = (Math.random() - 0.5) * jitter * 2;\n\n      points.push({ x: baseX + offsetX, y: baseY + offsetY });\n    }\n\n    points.push({ x: x2, y: y2 });\n\n    for (let i = 0; i < points.length - 1; i++) {\n      renderer.drawLine(\n        points[i].x,\n        points[i].y,\n        points[i + 1].x,\n        points[i + 1].y,\n        glowColor,\n        4\n      );\n    }\n\n    for (let i = 0; i < points.length - 1; i++) {\n      renderer.drawLine(\n        points[i].x,\n        points[i].y,\n        points[i + 1].x,\n        points[i + 1].y,\n        color,\n        2\n      );\n    }\n  }\n\n  isActive(): boolean {\n    return this.state === 'ROLLING';\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  hasKilledPlayer(): boolean {\n    return false;\n  }\n\n  getExplosionCount(): number {\n    return this.chainNodes.length;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\ninterface FlameParticle {\n  x: number;\n  y: number;\n  age: number;\n  maxAge: number;\n}\n\ninterface FireTrail {\n  x: number;\n  y: number;\n  startTime: number;\n  duration: number;\n}\n\nexport class FlameBurst extends Weapon {\n  readonly type = WeaponType.FLAME_BURST;\n  \n  private readonly FLAME_DURATION_MS = 3000;\n  private readonly CONE_ANGLE_RAD = Math.PI / 3;\n  private readonly FLAME_REACH_PX = 200;\n  private readonly TRAIL_DURATION_MS = 1000;\n  private readonly PARTICLE_MAX_AGE_MS = 200;\n  private readonly PARTICLE_AGE_VARIANCE_MS = 100;\n  private readonly PARTICLES_PER_FRAME = 5;\n  private readonly FRAME_TIME_MS = 16;\n  \n  private playerPosition: Vector2 = { x: 0, y: 0 };\n  private playerAngle: number = 0;\n  private flames: FlameParticle[] = [];\n  private trails: FireTrail[] = [];\n  private flameActive: boolean = false;\n  private complete: boolean = false;\n  \n  activate(player: Player, _dots: Dot[]): void {\n    this.start();\n    this.dots = _dots;\n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n    this.flames = [];\n    this.trails = [];\n    this.flameActive = true;\n    this.complete = false;\n  }\n  \n  update(_dt: number, player: Player, dots: Dot[], _bounds: Bounds): void {\n    if (this.complete) return;\n    \n    const elapsed = this.getElapsedTime();\n    \n    if (elapsed >= this.FLAME_DURATION_MS) {\n      this.flameActive = false;\n      const now = Date.now();\n      this.trails = this.trails.filter(trail => now - trail.startTime < trail.duration);\n      if (this.trails.length === 0) {\n        this.complete = true;\n      }\n      return;\n    }\n    \n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n    \n    this.spawnFlameParticles();\n    \n    this.flames = this.flames.filter(flame => {\n      flame.age += this.FRAME_TIME_MS;\n      return flame.age < flame.maxAge;\n    });\n    \n    if (Math.random() < 0.3) {\n      this.spawnFireTrail();\n    }\n    \n    const now = Date.now();\n    this.trails = this.trails.filter(trail => now - trail.startTime < trail.duration);\n    \n    this.killDotsInFlameCone(dots);\n  }\n  \n  private spawnFlameParticles(): void {\n    for (let i = 0; i < this.PARTICLES_PER_FRAME; i++) {\n      const angleOffset = (Math.random() - 0.5) * this.CONE_ANGLE_RAD;\n      const angle = this.playerAngle + angleOffset;\n      const distance = Math.random() * this.FLAME_REACH_PX;\n      const jitterX = (Math.random() - 0.5) * 20;\n      const jitterY = (Math.random() - 0.5) * 20;\n      \n      this.flames.push({\n        x: this.playerPosition.x + Math.cos(angle) * distance + jitterX,\n        y: this.playerPosition.y + Math.sin(angle) * distance + jitterY,\n        age: 0,\n        maxAge: this.PARTICLE_MAX_AGE_MS + Math.random() * this.PARTICLE_AGE_VARIANCE_MS\n      });\n    }\n  }\n  \n  private spawnFireTrail(): void {\n    const angleOffset = (Math.random() - 0.5) * this.CONE_ANGLE_RAD;\n    const angle = this.playerAngle + angleOffset;\n    const distance = 20 + Math.random() * 60;\n    \n    this.trails.push({\n      x: this.playerPosition.x + Math.cos(angle) * distance,\n      y: this.playerPosition.y + Math.sin(angle) * distance,\n      startTime: Date.now(),\n      duration: this.TRAIL_DURATION_MS\n    });\n  }\n  \n  private killDotsInFlameCone(dots: Dot[]): void {\n    if (!dots || dots.length === 0) return;\n    \n    const halfConeAngle = this.CONE_ANGLE_RAD / 2;\n\n    for (const dot of dots) {\n      if (dot.isDead()) continue;\n      \n      const dotPos = dot.getPosition();\n      const dx = dotPos.x - this.playerPosition.x;\n      const dy = dotPos.y - this.playerPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      if (distance > this.FLAME_REACH_PX) continue;\n      \n      const dotAngle = Math.atan2(dy, dx);\n      let angleDiff = dotAngle - this.playerAngle;\n      \n      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;\n      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;\n      \n      if (Math.abs(angleDiff) <= halfConeAngle) {\n        dot.kill();\n        this.addKilledDot();\n      }\n    }\n  }\n  \n  render(renderer: Renderer): void {\n    if (this.complete) return;\n    \n    const ctx = renderer.getContext();\n    const now = Date.now();\n    \n    this.renderTrails(ctx, now);\n    \n    if (!this.flameActive) return;\n    \n    this.renderFlameCone(ctx);\n    this.renderFlameParticles(ctx);\n  }\n  \n  private renderTrails(ctx: CanvasRenderingContext2D, now: number): void {\n    for (const trail of this.trails) {\n      const age = now - trail.startTime;\n      const progress = age / trail.duration;\n      const alpha = Math.max(0, 1 - progress);\n      const radius = 8 + progress * 5;\n      \n      ctx.beginPath();\n      ctx.arc(trail.x, trail.y, radius, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.6})`;\n      ctx.fill();\n      \n      ctx.beginPath();\n      ctx.arc(trail.x, trail.y, radius * 0.5, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, 200, 50, ${alpha * 0.8})`;\n      ctx.fill();\n    }\n  }\n  \n  private renderFlameCone(ctx: CanvasRenderingContext2D): void {\n    ctx.save();\n    ctx.translate(this.playerPosition.x, this.playerPosition.y);\n    ctx.rotate(this.playerAngle);\n    \n    const coneGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.FLAME_REACH_PX);\n    coneGradient.addColorStop(0, 'rgba(255, 150, 0, 0.3)');\n    coneGradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');\n    coneGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');\n    \n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.arc(0, 0, this.FLAME_REACH_PX, -this.CONE_ANGLE_RAD / 2, this.CONE_ANGLE_RAD / 2);\n    ctx.closePath();\n    ctx.fillStyle = coneGradient;\n    ctx.fill();\n    \n    ctx.restore();\n  }\n  \n  private renderFlameParticles(ctx: CanvasRenderingContext2D): void {\n    for (const flame of this.flames) {\n      const progress = flame.age / flame.maxAge;\n      const alpha = Math.max(0, 1 - progress);\n      const size = 6 + progress * 8;\n      \n      ctx.beginPath();\n      ctx.arc(flame.x, flame.y, size, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, ${Math.floor(100 + progress * 50)}, 0, ${alpha * 0.5})`;\n      ctx.fill();\n      \n      ctx.beginPath();\n      ctx.arc(flame.x, flame.y, size * 0.4, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, ${Math.floor(200 + progress * 55)}, ${Math.floor(50 + progress * 100)}, ${alpha * 0.8})`;\n      ctx.fill();\n    }\n  }\n  \n  isComplete(): boolean {\n    return this.complete;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { distance } from '../utils/math';\n\ninterface Missile {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  angle: number;\n  target: Dot | null;\n  active: boolean;\n}\n\ninterface Explosion {\n  x: number;\n  y: number;\n  startTime: number;\n  duration: number;\n  mainRadius: number;\n  subExplosions: { x: number; y: number; radius: number }[];\n  hasAppliedDamage: boolean;\n  active: boolean;\n}\n\nconst MISSILE_RADIUS = 6;\nconst MISSILE_COLOR = '#FF6B00';\nconst MISSILE_TRAIL_COLOR = 'rgba(255, 107, 0, 0.3)';\nconst MAX_TURN_RATE = 5 * Math.PI / 180;\n\nconst EXPLOSION_MAIN_RADIUS = 45;\nconst EXPLOSION_SUB_RADIUS = 15;\nconst EXPLOSION_DURATION_MS = 500;\nconst EXPLOSION_SUB_DELAY_MS = 250;\nconst EXPLOSION_COLOR = '#FFD700';\n\nexport class HomingMissile extends Weapon {\n  readonly type = WeaponType.HOMING_MISSILE;\n\n  private missiles: Missile[] = [];\n  private explosions: Explosion[] = [];\n  private readonly missileSpeed: number = 800;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.dots = dots;\n    this.missiles = [];\n    this.explosions = [];\n\n    const playerPos = player.getPosition();\n    const baseAngle = player.directionAngle;\n    const playerVel = player.velocity;\n\n    const playerSpeedInfluence = Math.sqrt(playerVel.x ** 2 + playerVel.y ** 2) * 0.5;\n    const effectiveSpeed = this.missileSpeed + playerSpeedInfluence;\n\n    const angles = [baseAngle - Math.PI / 6, baseAngle, baseAngle + Math.PI / 6];\n\n    for (const launchAngle of angles) {\n      const missile: Missile = {\n        x: playerPos.x,\n        y: playerPos.y,\n        vx: Math.cos(launchAngle) * effectiveSpeed,\n        vy: Math.sin(launchAngle) * effectiveSpeed,\n        angle: launchAngle,\n        target: null,\n        active: true\n      };\n      this.missiles.push(missile);\n    }\n  }\n\n  private findBestTarget(missile: Missile, dots: Dot[]): Dot | null {\n    if (!dots || dots.length === 0) return null;\n    \n    let bestTarget: Dot | null = null;\n    let bestScore = Infinity;\n\n    for (const dot of dots) {\n      if (dot.isDead()) continue;\n\n      const dotPos = dot.getPosition();\n      const dist = distance(missile, dotPos);\n\n      const angleToDot = Math.atan2(dotPos.y - missile.y, dotPos.x - missile.x);\n      const angleDiff = Math.abs(this.normalizeAngle(angleToDot - missile.angle));\n\n      const score = dist * (1 + angleDiff);\n\n      if (score < bestScore) {\n        bestScore = score;\n        bestTarget = dot;\n      }\n    }\n\n    return bestTarget;\n  }\n\n  private normalizeAngle(angle: number): number {\n    while (angle > Math.PI) angle -= 2 * Math.PI;\n    while (angle < -Math.PI) angle += 2 * Math.PI;\n    return angle;\n  }\n\n  private createExplosion(x: number, y: number): void {\n    const subExplosions = [];\n    for (let i = 0; i < 4; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const dist = Math.random() * EXPLOSION_MAIN_RADIUS * 0.6;\n      subExplosions.push({\n        x: Math.cos(angle) * dist,\n        y: Math.sin(angle) * dist,\n        radius: EXPLOSION_SUB_RADIUS * (0.8 + Math.random() * 0.4)\n      });\n    }\n\n    const explosion: Explosion = {\n      x,\n      y,\n      startTime: Date.now(),\n      duration: EXPLOSION_DURATION_MS,\n      mainRadius: EXPLOSION_MAIN_RADIUS,\n      subExplosions,\n      hasAppliedDamage: false,\n      active: true\n    };\n    this.explosions.push(explosion);\n  }\n\n  private applyExplosionDamage(explosion: Explosion, dots: Dot[]): void {\n    if (explosion.hasAppliedDamage) return;\n\n    for (const dot of dots) {\n      if (dot.isDead()) continue;\n\n      const dotPos = dot.getPosition();\n      const dist = distance({ x: explosion.x, y: explosion.y }, dotPos);\n\n      if (dist < explosion.mainRadius + dot.getRadius()) {\n        dot.kill();\n        this.addKilledDot();\n      }\n    }\n\n    explosion.hasAppliedDamage = true;\n  }\n\n  update(_dt: number, _player: Player, dots: Dot[], bounds: Bounds): void {\n    const now = Date.now();\n\n    this.missiles = this.missiles.filter(m => m.active);\n    this.explosions = this.explosions.filter(e => e.active);\n\n    for (const explosion of this.explosions) {\n      const elapsed = now - explosion.startTime;\n      if (elapsed >= explosion.duration) {\n        explosion.active = false;\n      }\n      if (!explosion.hasAppliedDamage) {\n        this.applyExplosionDamage(explosion, dots);\n      }\n    }\n\n    for (const missile of this.missiles) {\n      if (!missile.active) continue;\n\n      if (!missile.target || missile.target.isDead()) {\n        missile.target = this.findBestTarget(missile, dots);\n      }\n\n      if (missile.target) {\n        const targetPos = missile.target.getPosition();\n        const angleToTarget = Math.atan2(\n          targetPos.y - missile.y,\n          targetPos.x - missile.x\n        );\n\n        const angleDiff = this.normalizeAngle(angleToTarget - missile.angle);\n\n        const turnAmount = Math.max(-MAX_TURN_RATE, Math.min(MAX_TURN_RATE, angleDiff));\n        missile.angle += turnAmount;\n\n        const currentSpeed = Math.sqrt(missile.vx ** 2 + missile.vy ** 2);\n        missile.vx = Math.cos(missile.angle) * currentSpeed;\n        missile.vy = Math.sin(missile.angle) * currentSpeed;\n      }\n\n      missile.x += missile.vx * _dt;\n      missile.y += missile.vy * _dt;\n\n      if (\n        missile.x < -MISSILE_RADIUS ||\n        missile.x > bounds.width + MISSILE_RADIUS ||\n        missile.y < -MISSILE_RADIUS ||\n        missile.y > bounds.height + MISSILE_RADIUS\n      ) {\n        missile.active = false;\n        continue;\n      }\n\n      for (const dot of dots) {\n        if (dot.isDead()) continue;\n\n        const dotPos = dot.getPosition();\n        const dist = distance(missile, dotPos);\n\n        if (dist < MISSILE_RADIUS + dot.getRadius()) {\n          this.createExplosion(missile.x, missile.y);\n          missile.active = false;\n          break;\n        }\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    const ctx = renderer.getContext();\n    const now = Date.now();\n\n    for (const missile of this.missiles) {\n      if (!missile.active) continue;\n\n      ctx.save();\n      ctx.translate(missile.x, missile.y);\n      ctx.rotate(missile.angle);\n\n      ctx.beginPath();\n      ctx.moveTo(-15, 0);\n      ctx.lineTo(-MISSILE_RADIUS, 0);\n      ctx.strokeStyle = MISSILE_TRAIL_COLOR;\n      ctx.lineWidth = 4;\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.moveTo(MISSILE_RADIUS * 1.5, 0);\n      ctx.lineTo(-MISSILE_RADIUS, -MISSILE_RADIUS * 0.6);\n      ctx.lineTo(-MISSILE_RADIUS, MISSILE_RADIUS * 0.6);\n      ctx.closePath();\n      ctx.fillStyle = MISSILE_COLOR;\n      ctx.fill();\n\n      ctx.restore();\n    }\n\n    for (const explosion of this.explosions) {\n      if (!explosion.active) continue;\n\n      const elapsed = now - explosion.startTime;\n      const progress = elapsed / explosion.duration;\n      const opacity = 1 - progress;\n\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      ctx.fillStyle = EXPLOSION_COLOR;\n\n      ctx.beginPath();\n      ctx.arc(explosion.x, explosion.y, explosion.mainRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      if (elapsed >= EXPLOSION_SUB_DELAY_MS) {\n        for (const sub of explosion.subExplosions) {\n          ctx.beginPath();\n          ctx.arc(\n            explosion.x + sub.x,\n            explosion.y + sub.y,\n            sub.radius,\n            0,\n            Math.PI * 2\n          );\n          ctx.fill();\n        }\n      }\n\n      ctx.restore();\n    }\n  }\n\n  isComplete(): boolean {\n    return this.missiles.every(m => !m.active) && this.explosions.every(e => !e.active);\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport interface FrozenDot {\n  dot: Dot;\n  frozenTime: number;\n}\n\nexport class IceBomb extends Weapon {\n  readonly type = WeaponType.ICE_BOMB;\n\n  private state: 'EXPLODING' | 'FADING' | 'COMPLETE' = 'EXPLODING';\n  private bounds: Bounds | null = null;\n  private explosionRadius: number = 0;\n  private explosionCenter: { x: number; y: number } = { x: 0, y: 0 };\n  private explosionStartTime: number = 0;\n  private frozenDotsCount: number = 0;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.explosionStartTime = Date.now();\n    this.explosionCenter = { x: player.position.x, y: player.position.y };\n    this.dots = dots;\n    \n    // Don't freeze dots here - wait for first update() when we have proper bounds\n    this.explosionRadius = 0;\n    \n    this.state = 'EXPLODING';\n  }\n\n  update(_dt: number, _player: Player, dots: Dot[], bounds: Bounds): void {\n    if (!this.bounds) {\n      this.bounds = bounds;\n      this.explosionRadius = 0.3 * bounds.width;\n      // Initial freeze now that we have proper bounds - matches the visual\n      this.freezeDotsInRadius(dots);\n    }\n\n    // Continuously freeze dots that enter the radius while effect is active\n    if (this.state === 'EXPLODING' || this.state === 'FADING') {\n      this.freezeDotsInRadius(dots);\n    }\n\n    if (this.state === 'EXPLODING') {\n      const elapsed = Date.now() - this.explosionStartTime;\n      if (elapsed >= 500) {\n        this.state = 'FADING';\n      }\n    } else if (this.state === 'FADING') {\n      const elapsed = Date.now() - this.explosionStartTime;\n      // Effect lasts 6000ms to match dot freeze duration (doubled)\n      if (elapsed >= 6000) {\n        this.state = 'COMPLETE';\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'EXPLODING' || this.state === 'FADING') {\n      const elapsed = Date.now() - this.explosionStartTime;\n      let alpha = 0.6;\n      \n      if (this.state === 'FADING') {\n        // Fade out over 5500ms (from 500ms to 6000ms)\n        alpha = 0.6 * (1 - (elapsed - 500) / 5500);\n      }\n      \n      if (alpha > 0) {\n        renderer.drawCircle(\n          this.explosionCenter.x,\n          this.explosionCenter.y,\n          this.explosionRadius,\n          `rgba(0, 204, 255, ${alpha})` // Blue explosion\n        );\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  private freezeDotsInRadius(dots: Dot[]): void {\n    if (!dots || dots.length === 0) return;\n\n    for (const dot of dots) {\n      if (dot.isDead() || dot.isFrozen()) {\n        continue;\n      }\n\n      const pos = dot.getPosition();\n      const dx = pos.x - this.explosionCenter.x;\n      const dy = pos.y - this.explosionCenter.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.explosionRadius) {\n        dot.freeze();\n        this.frozenDotsCount++;\n      }\n    }\n  }\n\n  getFrozenDotsCount(): number {\n    return this.frozenDotsCount;\n  }\n\n  getExplosionRadius(): number {\n    return this.explosionRadius;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\nexport class KineticBomb extends Weapon {\n  readonly type = WeaponType.KINETIC_BOMB;\n\n  private state: 'COLLAPSING' | 'EXPLODING' | 'COMPLETE' = 'COLLAPSING';\n  private explosionCenter: Vector2 = { x: 0, y: 0 };\n  private explosionRadius: number = 0;\n  private bounds: Bounds | null = null;\n  private killedDotsInExplosion: Set<Dot> = new Set();\n\n  activate(player: Player, dots: Dot[]): void {\n    this.dots = dots;\n    this.explosionCenter = { x: player.position.x, y: player.position.y };\n    this.start();\n  }\n\n  update(_dt: number, _player: Player, dots: Dot[], bounds: Bounds): void {\n    if (!this.bounds) this.bounds = bounds;\n    const elapsedTime = this.getElapsedTime();\n\n    switch (this.state) {\n      case 'COLLAPSING':\n        if (elapsedTime >= 100) {\n          this.state = 'EXPLODING';\n          this.explosionRadius = 0.45 * bounds.width;\n        }\n        break;\n\n      case 'EXPLODING':\n        // Continuously kill dots that enter the explosion\n        this.killDotsInExplosion(dots);\n        \n        // Complete after 1 second total (100ms collapse + 900ms explosion)\n        if (elapsedTime >= 1000) {\n          this.state = 'COMPLETE';\n        }\n        break;\n\n      case 'COMPLETE':\n        break;\n    }\n  }\n\n  render(renderer: Renderer): void {\n    const elapsedTime = this.getElapsedTime();\n\n    if (this.state === 'COLLAPSING') {\n      const collapseRadius = 50 * (1 - elapsedTime / 100);\n      if (collapseRadius > 0) {\n        renderer.drawCircle(\n          this.explosionCenter.x,\n          this.explosionCenter.y,\n          Math.max(0, collapseRadius),\n          '#FF4500'\n        );\n      }\n    } else if (this.state === 'EXPLODING') {\n      // Translucent explosion that fades over time\n      const explosionElapsed = elapsedTime - 100;\n      const explosionDuration = 900;\n      const fadeOpacity = 1 - (explosionElapsed / explosionDuration);\n      \n      if (fadeOpacity > 0) {\n        renderer.drawCircle(\n          this.explosionCenter.x,\n          this.explosionCenter.y,\n          this.explosionRadius,\n          `rgba(255, 69, 0, ${fadeOpacity * 0.7})`\n        );\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n\n  private killDotsInExplosion(dots: Dot[]): void {\n    for (const dot of dots) {\n      if (dot.isDead() || this.killedDotsInExplosion.has(dot)) continue;\n\n      const pos = dot.getPosition();\n      const dx = pos.x - this.explosionCenter.x;\n      const dy = pos.y - this.explosionCenter.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= this.explosionRadius) {\n        dot.kill();\n        this.addKilledDot();\n        this.killedDotsInExplosion.add(dot);\n      }\n    }\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\ninterface Bullet {\n  position: Vector2;\n  velocity: Vector2;\n  active: boolean;\n  exploded: boolean;\n  explosionTime: number;\n}\n\nexport class TripleCannon extends Weapon {\n  readonly type = WeaponType.TRIPLE_CANNON;\n\n  private state: 'AIMING' | 'FIRING' | 'COMPLETE' = 'AIMING';\n  private aimTime: number = 500;\n  private aimStartTime: number = 0;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n  private playerAngle: number = 0;\n  private bullets: Bullet[] = [];\n  private currentBulletIndex: number = 0;\n  private lastShotTime: number = 0;\n  private shotDelay: number = 250; // quarter second between shots\n\n  // Bullet settings\n  private readonly BULLET_RADIUS = 8;\n  private readonly BULLET_SPEED = 800;\n  private readonly EXPLOSION_RADIUS = 60;\n  private readonly EXPLOSION_DURATION = 300;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.dots = dots;\n    this.aimStartTime = Date.now();\n\n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n\n    this.state = 'AIMING';\n    this.bullets = [];\n    this.currentBulletIndex = 0;\n    this.lastShotTime = 0;\n  }\n\n  update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    if (this.state === 'COMPLETE') return;\n\n    const elapsed = Date.now() - this.aimStartTime;\n\n    if (this.state === 'AIMING') {\n      this.playerPosition = player.getPosition();\n      this.playerAngle = player.directionAngle;\n\n      if (elapsed >= this.aimTime) {\n        this.state = 'FIRING';\n        this.fireBullet();\n      }\n    } else if (this.state === 'FIRING') {\n      const now = Date.now();\n\n      // Continue tracking player aim between shots\n      this.playerPosition = player.getPosition();\n      this.playerAngle = player.directionAngle;\n\n      // Fire next bullet after delay\n      if (this.currentBulletIndex < 3 && now - this.lastShotTime >= this.shotDelay) {\n        this.fireBullet();\n      }\n      // Update all bullets\n      let allDone = true;\n      for (const bullet of this.bullets) {\n        if (bullet.exploded) {\n          // Handle explosion\n          if (now - bullet.explosionTime >= this.EXPLOSION_DURATION) {\n            bullet.active = false;\n          } else {\n            this.checkExplosionCollision(bullet, dots);\n            allDone = false;\n          }\n        } else if (bullet.active) {\n          // Move bullet\n          bullet.position.x += bullet.velocity.x * dt;\n          bullet.position.y += bullet.velocity.y * dt;\n          if (\n            bullet.position.x < 0 ||\n            bullet.position.x > bounds.width ||\n            bullet.position.y < 0 ||\n            bullet.position.y > bounds.height\n          ) {\n            this.explodeBullet(bullet);\n          }\n          // Check dot collision\n          if (this.checkBulletCollision(bullet, dots)) {\n            this.explodeBullet(bullet);\n          }\n\n          allDone = false;\n        }\n      }\n      // Complete when all bullets are done and we've fired all 3\n      if (allDone && this.currentBulletIndex >= 3) {\n        this.state = 'COMPLETE';\n      }\n    }\n  }\n\n  private fireBullet(): void {\n    const cos = Math.cos(this.playerAngle);\n    const sin = Math.sin(this.playerAngle);\n\n    const bullet: Bullet = {\n      position: { ...this.playerPosition },\n      velocity: {\n        x: cos * this.BULLET_SPEED,\n        y: sin * this.BULLET_SPEED\n      },\n      active: true,\n      exploded: false,\n      explosionTime: 0\n    };\n\n    this.bullets.push(bullet);\n    this.currentBulletIndex++;\n    this.lastShotTime = Date.now();\n  }\n\n  private explodeBullet(bullet: Bullet): void {\n    bullet.exploded = true;\n    bullet.explosionTime = Date.now();\n    bullet.velocity = { x: 0, y: 0 };\n  }\n\n  private checkBulletCollision(bullet: Bullet, dots: Dot[]): boolean {\n    if (!dots || dots.length === 0) return false;\n\n    for (const dot of dots) {\n      if (!dot.isDead()) {\n        const dotPos = dot.getPosition();\n        const dotRadius = dot.getRadius();\n        const dx = bullet.position.x - dotPos.x;\n        const dy = bullet.position.y - dotPos.y;\n        const distSq = dx * dx + dy * dy;\n        const radiiSum = this.BULLET_RADIUS + dotRadius;\n\n        if (distSq < radiiSum * radiiSum) {\n          dot.kill();\n          this.addKilledDot();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private checkExplosionCollision(bullet: Bullet, dots: Dot[]): void {\n    if (!dots || dots.length === 0) return;\n\n    for (const dot of dots) {\n      if (!dot.isDead()) {\n        const dotPos = dot.getPosition();\n        const dotRadius = dot.getRadius();\n        const dx = bullet.position.x - dotPos.x;\n        const dy = bullet.position.y - dotPos.y;\n        const distSq = dx * dx + dy * dy;\n        const radiiSum = this.EXPLOSION_RADIUS + dotRadius;\n\n        if (distSq < radiiSum * radiiSum) {\n          dot.kill();\n          this.addKilledDot();\n        }\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'COMPLETE') return;\n\n    const ctx = renderer.getContext();\n\n    if (this.state === 'AIMING') {\n      const x = this.playerPosition.x;\n      const y = this.playerPosition.y;\n\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(this.playerAngle);\n\n      // Draw targeting reticle\n      ctx.strokeStyle = 'rgb(255, 0, 255)';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(20, 0, 8, 0, Math.PI * 2);\n      ctx.stroke();\n\n      ctx.restore();\n    } else if (this.state === 'FIRING') {\n      const now = Date.now();\n\n      for (const bullet of this.bullets) {\n        if (!bullet.active) continue;\n\n        if (bullet.exploded) {\n          // Draw purple explosion\n          const elapsed = now - bullet.explosionTime;\n          const progress = elapsed / this.EXPLOSION_DURATION;\n          const alpha = 1 - progress;\n          const radius = this.EXPLOSION_RADIUS * (0.5 + 0.5 * progress);\n\n          ctx.fillStyle = `rgba(128, 0, 255, ${alpha * 0.8})`;\n          ctx.beginPath();\n          ctx.arc(bullet.position.x, bullet.position.y, radius, 0, Math.PI * 2);\n          ctx.fill();\n\n          // Inner bright core\n          ctx.fillStyle = `rgba(200, 100, 255, ${alpha})`;\n          ctx.beginPath();\n          ctx.arc(bullet.position.x, bullet.position.y, radius * 0.5, 0, Math.PI * 2);\n          ctx.fill();\n        } else {\n          // Draw circular bullet\n          ctx.fillStyle = 'rgb(255, 0, 255)';\n          ctx.beginPath();\n          ctx.arc(bullet.position.x, bullet.position.y, this.BULLET_RADIUS, 0, Math.PI * 2);\n          ctx.fill();\n\n          // Bullet glow\n          ctx.fillStyle = 'rgba(255, 100, 255, 0.5)';\n          ctx.beginPath();\n          ctx.arc(bullet.position.x, bullet.position.y, this.BULLET_RADIUS * 1.5, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    }\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\nimport { WEAPON_ORB_RADIUS } from '../utils/constants';\n\ninterface FirePoint {\n  x: number;\n  y: number;\n  createdAt: number;\n}\n\nexport class FireballOrb extends Weapon {\n  readonly type = WeaponType.FIREBALL_ORB;\n\n  private state: 'DRIFTING' | 'FIZZLING' | 'COMPLETE' = 'DRIFTING';\n  private orbPosition: Vector2 = { x: 0, y: 0 };\n  private orbVelocity: Vector2 = { x: 0, y: 0 };\n  private bounds: Bounds | null = null;\n\n  private readonly activeDuration: number = 2500;\n  private readonly fireDuration: number = 10000;\n  private fizzleStartTime: number = 0;\n\n  private firePoints: FirePoint[] = [];\n  private readonly fireTrailWidth: number = 12;\n  private readonly orbRadius: number = WEAPON_ORB_RADIUS * 0.6;\n\n  private lastSegmentPosition: Vector2 = { x: 0, y: 0 };\n  private readonly minSegmentDistance: number = 15;\n\n  private lastCollisionTime: number = 0;\n  private readonly collisionCooldown: number = 100;\n\n  activate(player: Player, _dots: Dot[], initialPosition?: { x: number; y: number }): void {\n    this.dots = _dots;\n    this.start();\n\n    if (initialPosition) {\n      this.orbPosition = { x: initialPosition.x, y: initialPosition.y };\n    } else {\n      const playerSpeed = Math.sqrt(player.velocity.x ** 2 + player.velocity.y ** 2);\n      if (playerSpeed > 10) {\n        const dirX = player.velocity.x / playerSpeed;\n        const dirY = player.velocity.y / playerSpeed;\n        const offset = player.hitboxRadius + this.orbRadius + 5;\n        this.orbPosition = {\n          x: player.position.x + dirX * offset,\n          y: player.position.y + dirY * offset\n        };\n      } else {\n        this.orbPosition = { x: player.position.x, y: player.position.y - player.hitboxRadius - this.orbRadius - 5 };\n      }\n    }\n    this.orbVelocity = { x: 0, y: 0 };\n    this.lastSegmentPosition = { ...this.orbPosition };\n  }\n\n  handlePlayerCollision(player: Player, playerVelocity: Vector2): boolean {\n    const now = Date.now();\n    if (now - this.lastCollisionTime < this.collisionCooldown) {\n      return false;\n    }\n    this.lastCollisionTime = now;\n\n    const dx = this.orbPosition.x - player.position.x;\n    const dy = this.orbPosition.y - player.position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    const minSpeed = 50;\n    const playerSpeed = Math.sqrt(playerVelocity.x ** 2 + playerVelocity.y ** 2);\n\n    if (playerSpeed < minSpeed) {\n      return false;\n    }\n\n    if (distance === 0) {\n      this.orbVelocity.x = playerVelocity.x;\n      this.orbVelocity.y = playerVelocity.y;\n      return true;\n    }\n\n    const nx = dx / distance;\n    const ny = dy / distance;\n    const tx = -ny;\n    const ty = nx;\n\n    const vDotN = playerVelocity.x * nx + playerVelocity.y * ny;\n    const vDotT = playerVelocity.x * tx + playerVelocity.y * ty;\n\n    const directness = vDotN / playerSpeed;\n\n    if (directness < 0.1) {\n      return false;\n    }\n\n    const velocityMultiplier = 2.2;\n\n    if (directness > 0.7) {\n      this.orbVelocity.x = playerVelocity.x * velocityMultiplier;\n      this.orbVelocity.y = playerVelocity.y * velocityMultiplier;\n    } else {\n      const forwardFactor = directness;\n      const sidewaysFactor = 1 - directness;\n\n      this.orbVelocity.x = (nx * vDotN * forwardFactor + tx * vDotT * sidewaysFactor) * velocityMultiplier;\n      this.orbVelocity.y = (ny * vDotN * forwardFactor + ty * vDotT * sidewaysFactor) * velocityMultiplier;\n    }\n\n    return true;\n  }\n\n  getPosition(): Vector2 {\n    return this.orbPosition;\n  }\n\n  getRadius(): number {\n    return this.orbRadius;\n  }\n\n  isActive(): boolean {\n    return this.state === 'DRIFTING';\n  }\n\n  update(dt: number, _player: Player, _dots: Dot[], bounds: Bounds): void {\n    this.bounds = bounds;\n    const now = Date.now();\n\n    const cutoffTime = now - this.fireDuration;\n    this.firePoints = this.firePoints.filter(p => p.createdAt > cutoffTime);\n\n    if (this.state === 'DRIFTING') {\n      this.orbPosition.x += this.orbVelocity.x * dt;\n      this.orbPosition.y += this.orbVelocity.y * dt;\n\n      const minX = this.orbRadius;\n      const maxX = bounds.width - this.orbRadius;\n      const minY = this.orbRadius;\n      const maxY = bounds.height - this.orbRadius;\n\n      if (this.orbPosition.x <= minX) {\n        this.orbVelocity.x = Math.abs(this.orbVelocity.x);\n        this.orbPosition.x = minX;\n      } else if (this.orbPosition.x >= maxX) {\n        this.orbVelocity.x = -Math.abs(this.orbVelocity.x);\n        this.orbPosition.x = maxX;\n      }\n\n      if (this.orbPosition.y <= minY) {\n        this.orbVelocity.y = Math.abs(this.orbVelocity.y);\n        this.orbPosition.y = minY;\n      } else if (this.orbPosition.y >= maxY) {\n        this.orbVelocity.y = -Math.abs(this.orbVelocity.y);\n        this.orbPosition.y = maxY;\n      }\n\n      const speed = Math.sqrt(this.orbVelocity.x ** 2 + this.orbVelocity.y ** 2);\n      if (speed > 10) {\n        const dx = this.orbPosition.x - this.lastSegmentPosition.x;\n        const dy = this.orbPosition.y - this.lastSegmentPosition.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        \n        if (dist >= this.minSegmentDistance) {\n          this.firePoints.push({\n            x: this.orbPosition.x,\n            y: this.orbPosition.y,\n            createdAt: now\n          });\n          this.lastSegmentPosition = { ...this.orbPosition };\n        }\n      }\n\n      this.killDotsInRadius(this.orbPosition.x, this.orbPosition.y, this.orbRadius * 1.5);\n\n      if (this.getElapsedTime() >= this.activeDuration) {\n        this.state = 'FIZZLING';\n        this.fizzleStartTime = now;\n      }\n    } else if (this.state === 'FIZZLING') {\n      if (now - this.fizzleStartTime > 300) {\n        this.state = 'COMPLETE';\n      }\n    }\n\n    for (const point of this.firePoints) {\n      this.killDotsInRadius(point.x, point.y, this.fireTrailWidth);\n    }\n  }\n\n  private killDotsInRadius(x: number, y: number, radius: number): void {\n    for (const dot of this.dots) {\n      if (dot.isDead()) continue;\n\n      const pos = dot.getPosition();\n      const dx = pos.x - x;\n      const dy = pos.y - y;\n      const distSq = dx * dx + dy * dy;\n\n      if (distSq <= (radius + 5) * (radius + 5)) {\n        dot.kill();\n        this.addKilledDot();\n      }\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (!this.bounds) return;\n\n    const ctx = renderer.getContext();\n    const now = Date.now();\n\n    if (this.firePoints.length > 1) {\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n\n      for (let i = 1; i < this.firePoints.length; i++) {\n        const point = this.firePoints[i];\n        const prevPoint = this.firePoints[i - 1];\n        const age = now - point.createdAt;\n        const progress = age / this.fireDuration;\n\n        if (progress >= 1) continue;\n\n        const alpha = Math.max(0, 1 - progress);\n        const flicker = 0.85 + Math.sin(now * 0.015 + point.x * 0.05) * 0.15;\n        const finalAlpha = alpha * flicker;\n\n        const width = this.fireTrailWidth * (1 - progress * 0.3);\n\n        ctx.beginPath();\n        ctx.moveTo(prevPoint.x, prevPoint.y);\n        ctx.lineTo(point.x, point.y);\n        ctx.strokeStyle = `rgba(255, 200, 50, ${finalAlpha * 0.9})`;\n        ctx.lineWidth = width * 1.3;\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(prevPoint.x, prevPoint.y);\n        ctx.lineTo(point.x, point.y);\n        ctx.strokeStyle = `rgba(255, 100, 0, ${finalAlpha})`;\n        ctx.lineWidth = width;\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(prevPoint.x, prevPoint.y);\n        ctx.lineTo(point.x, point.y);\n        ctx.strokeStyle = `rgba(255, 220, 100, ${finalAlpha * 0.7})`;\n        ctx.lineWidth = width * 0.4;\n        ctx.stroke();\n      }\n    }\n\n    if (this.state === 'DRIFTING') {\n      this.drawFlamingOrb(ctx, this.orbPosition.x, this.orbPosition.y, this.orbRadius);\n    } else if (this.state === 'FIZZLING') {\n      const fizzleProgress = (now - this.fizzleStartTime) / 300;\n      const shrinkRadius = this.orbRadius * (1 - fizzleProgress);\n      if (shrinkRadius > 0) {\n        this.drawFlamingOrb(ctx, this.orbPosition.x, this.orbPosition.y, shrinkRadius);\n      }\n    }\n  }\n\n  private drawFlamingOrb(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number): void {\n    const now = Date.now();\n\n    const glowRadius = radius * 2.5;\n    const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowRadius);\n    gradient.addColorStop(0, 'rgba(255, 220, 100, 0.7)');\n    gradient.addColorStop(0.4, 'rgba(255, 100, 0, 0.4)');\n    gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');\n\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.arc(x, y, glowRadius, 0, Math.PI * 2);\n    ctx.fill();\n\n    const orbGradient = ctx.createRadialGradient(\n      x - radius * 0.2, y - radius * 0.2, 0,\n      x, y, radius\n    );\n    orbGradient.addColorStop(0, '#FFEE66');\n    orbGradient.addColorStop(0.5, '#FF8800');\n    orbGradient.addColorStop(1, '#DD3300');\n\n    ctx.fillStyle = orbGradient;\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fill();\n\n    const numFlames = 5;\n    for (let i = 0; i < numFlames; i++) {\n      const baseAngle = (i / numFlames) * Math.PI * 2;\n      const wobble = Math.sin(now * 0.008 + i * 1.3) * 0.25;\n      const angle = baseAngle + wobble;\n\n      const flameLength = radius * (0.35 + Math.sin(now * 0.012 + i * 2.1) * 0.15);\n      const flameWidth = radius * 0.25;\n\n      const startX = x + Math.cos(angle) * radius * 0.7;\n      const startY = y + Math.sin(angle) * radius * 0.7;\n      const endX = x + Math.cos(angle) * (radius + flameLength);\n      const endY = y + Math.sin(angle) * (radius + flameLength);\n\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.lineTo(endX, endY);\n      ctx.strokeStyle = 'rgba(255, 200, 50, 0.6)';\n      ctx.lineWidth = flameWidth;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    ctx.fillStyle = 'rgba(255, 255, 220, 0.5)';\n    ctx.beginPath();\n    ctx.arc(x - radius * 0.2, y - radius * 0.2, radius * 0.2, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE' && this.firePoints.length === 0;\n  }\n\n  hasKilledPlayer(): boolean {\n    return false;\n  }\n}\n","import { Weapon } from './Weapon';\nimport type { Player } from '../entities/Player';\nimport { Dot } from '../entities/Dot';\nimport { WeaponType, Bounds, Vector2 } from '../types';\nimport type { Renderer } from '../renderer/Renderer';\n\ninterface Bullet {\n  position: Vector2;\n  velocity: Vector2;\n  active: boolean;\n  exploded: boolean;\n  explosionTime: number;\n  chainNodes: ChainNode[];\n  lightningArcs: LightningArc[];\n}\n\ninterface ChainNode {\n  x: number;\n  y: number;\n  radius: number;\n  activatedAt: number;\n  chainDepth: number;\n  parentX?: number;\n  parentY?: number;\n}\n\ninterface LightningArc {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  createdAt: number;\n  chainDepth: number;\n}\n\nexport class TeslaCannon extends Weapon {\n  readonly type = WeaponType.TESLA_CANNON;\n\n  private state: 'AIMING' | 'FIRING' | 'COMPLETE' = 'AIMING';\n  private aimTime: number = 500;\n  private aimStartTime: number = 0;\n  private playerPosition: Vector2 = { x: 0, y: 0 };\n  private playerAngle: number = 0;\n  private bullets: Bullet[] = [];\n  private currentBulletIndex: number = 0;\n  private lastShotTime: number = 0;\n  private shotDelay: number = 250;\n\n  private readonly BULLET_RADIUS = 8;\n  private readonly BULLET_SPEED = 800;\n  private readonly EXPLOSION_RADIUS = 60;\n  private readonly EXPLOSION_DURATION = 400;\n  private readonly chainRadiusFactor: number = 0.10;\n  private readonly maxChainDepth: number = 5;\n  private bounds: Bounds | null = null;\n\n  activate(player: Player, dots: Dot[]): void {\n    this.start();\n    this.dots = dots;\n    this.aimStartTime = Date.now();\n\n    this.playerPosition = player.getPosition();\n    this.playerAngle = player.directionAngle;\n\n    this.state = 'AIMING';\n    this.bullets = [];\n    this.currentBulletIndex = 0;\n    this.lastShotTime = 0;\n  }\n\n  update(dt: number, player: Player, dots: Dot[], bounds: Bounds): void {\n    if (this.bounds === null) {\n      this.bounds = bounds;\n    }\n\n    if (this.state === 'COMPLETE') return;\n\n    const elapsed = Date.now() - this.aimStartTime;\n\n    if (this.state === 'AIMING') {\n      this.playerPosition = player.getPosition();\n      this.playerAngle = player.directionAngle;\n\n      if (elapsed >= this.aimTime) {\n        this.state = 'FIRING';\n        this.fireBullet();\n      }\n    } else if (this.state === 'FIRING') {\n      const now = Date.now();\n\n      this.playerPosition = player.getPosition();\n      this.playerAngle = player.directionAngle;\n\n      if (this.currentBulletIndex < 3 && now - this.lastShotTime >= this.shotDelay) {\n        this.fireBullet();\n      }\n\n      let allDone = true;\n      for (const bullet of this.bullets) {\n        if (bullet.exploded) {\n          if (now - bullet.explosionTime >= this.EXPLOSION_DURATION) {\n            bullet.active = false;\n          } else {\n            this.processChainLightning(bullet, now);\n            allDone = false;\n          }\n        } else if (bullet.active) {\n          bullet.position.x += bullet.velocity.x * dt;\n          bullet.position.y += bullet.velocity.y * dt;\n          if (\n            bullet.position.x < 0 ||\n            bullet.position.x > bounds.width ||\n            bullet.position.y < 0 ||\n            bullet.position.y > bounds.height\n          ) {\n            this.explodeBullet(bullet);\n          }\n          if (this.checkBulletCollision(bullet, dots)) {\n            this.explodeBullet(bullet);\n          }\n          allDone = false;\n        }\n      }\n\n      if (allDone && this.currentBulletIndex >= 3) {\n        this.state = 'COMPLETE';\n      }\n    }\n  }\n\n  private fireBullet(): void {\n    const reversedAngle = this.playerAngle + Math.PI;\n    const cos = Math.cos(reversedAngle);\n    const sin = Math.sin(reversedAngle);\n\n    const bullet: Bullet = {\n      position: { ...this.playerPosition },\n      velocity: {\n        x: cos * this.BULLET_SPEED,\n        y: sin * this.BULLET_SPEED\n      },\n      active: true,\n      exploded: false,\n      explosionTime: 0,\n      chainNodes: [],\n      lightningArcs: []\n    };\n\n    this.bullets.push(bullet);\n    this.currentBulletIndex++;\n    this.lastShotTime = Date.now();\n  }\n\n  private explodeBullet(bullet: Bullet): void {\n    bullet.exploded = true;\n    bullet.explosionTime = Date.now();\n    bullet.velocity = { x: 0, y: 0 };\n\n    const radius = (this.bounds?.width ?? 800) * this.chainRadiusFactor * 2.5;\n    bullet.chainNodes.push({\n      x: bullet.position.x,\n      y: bullet.position.y,\n      radius,\n      activatedAt: Date.now(),\n      chainDepth: 0\n    });\n\n    this.findAndElectrifyDots(bullet, bullet.chainNodes[0]);\n  }\n\n  private checkBulletCollision(bullet: Bullet, dots: Dot[]): boolean {\n    if (!dots || dots.length === 0) return false;\n\n    for (const dot of dots) {\n      if (!dot.isDead()) {\n        const dotPos = dot.getPosition();\n        const dotRadius = dot.getRadius();\n        const dx = bullet.position.x - dotPos.x;\n        const dy = bullet.position.y - dotPos.y;\n        const distSq = dx * dx + dy * dy;\n        const radiiSum = this.BULLET_RADIUS + dotRadius;\n\n        if (distSq < radiiSum * radiiSum) {\n          dot.kill();\n          this.addKilledDot();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private findAndElectrifyDots(bullet: Bullet, node: ChainNode): void {\n    for (const dot of this.dots) {\n      if (dot.isDead()) continue;\n\n      const pos = dot.getPosition();\n      const dx = pos.x - node.x;\n      const dy = pos.y - node.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance <= node.radius) {\n        dot.kill();\n        this.addKilledDot();\n\n        bullet.lightningArcs.push({\n          x1: node.x,\n          y1: node.y,\n          x2: pos.x,\n          y2: pos.y,\n          createdAt: Date.now(),\n          chainDepth: node.chainDepth\n        });\n\n        const newNode: ChainNode = {\n          x: pos.x,\n          y: pos.y,\n          radius: (this.bounds?.width ?? 800) * this.chainRadiusFactor,\n          activatedAt: Date.now(),\n          chainDepth: node.chainDepth + 1,\n          parentX: node.x,\n          parentY: node.y\n        };\n\n        bullet.chainNodes.push(newNode);\n      }\n    }\n  }\n\n  private processChainLightning(bullet: Bullet, now: number): void {\n    const pendingNodes = bullet.chainNodes.filter(n =>\n      n.chainDepth > 0 &&\n      now - n.activatedAt < 100 &&\n      n.chainDepth < this.maxChainDepth\n    );\n\n    for (const node of pendingNodes) {\n      this.findAndElectrifyDots(bullet, node);\n    }\n  }\n\n  render(renderer: Renderer): void {\n    if (this.state === 'COMPLETE') return;\n\n    const ctx = renderer.getContext();\n\n    if (this.state === 'AIMING') {\n      const x = this.playerPosition.x;\n      const y = this.playerPosition.y;\n\n      const reversedAngle = this.playerAngle + Math.PI;\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(reversedAngle);\n\n      ctx.strokeStyle = '#00CCFF';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(20, 0, 8, 0, Math.PI * 2);\n      ctx.stroke();\n\n      ctx.restore();\n    } else if (this.state === 'FIRING') {\n      const now = Date.now();\n\n      for (const bullet of this.bullets) {\n        if (!bullet.active) continue;\n\n        if (bullet.exploded) {\n          this.renderElectricExplosion(ctx, bullet, now);\n        } else {\n          ctx.fillStyle = '#00CCFF';\n          ctx.beginPath();\n          ctx.arc(bullet.position.x, bullet.position.y, this.BULLET_RADIUS, 0, Math.PI * 2);\n          ctx.fill();\n\n          ctx.fillStyle = 'rgba(0, 204, 255, 0.5)';\n          ctx.beginPath();\n          ctx.arc(bullet.position.x, bullet.position.y, this.BULLET_RADIUS * 1.5, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    }\n  }\n\n  private renderElectricExplosion(ctx: CanvasRenderingContext2D, bullet: Bullet, now: number): void {\n    const elapsed = now - bullet.explosionTime;\n    const progress = elapsed / this.EXPLOSION_DURATION;\n    const alpha = Math.max(0, 1 - progress);\n\n    const fadeTime = 400;\n    bullet.chainNodes = bullet.chainNodes.filter(node => now - node.activatedAt < fadeTime + 50);\n    bullet.lightningArcs = bullet.lightningArcs.filter(arc => now - arc.createdAt < fadeTime);\n\n    for (const node of bullet.chainNodes) {\n      const nodeAge = now - node.activatedAt;\n      const nodeOpacity = Math.max(0, 1 - nodeAge / fadeTime);\n\n      if (nodeOpacity > 0) {\n        ctx.fillStyle = `rgba(0, 204, 255, ${nodeOpacity * 0.3})`;\n        ctx.beginPath();\n        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);\n        ctx.fill();\n\n        ctx.strokeStyle = `rgba(0, 230, 255, ${nodeOpacity})`;\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n    }\n\n    for (const arc of bullet.lightningArcs) {\n      const arcAge = now - arc.createdAt;\n      const arcOpacity = Math.max(0, 1 - arcAge / fadeTime);\n\n      if (arcOpacity > 0) {\n        this.drawJaggedLightning(\n          ctx,\n          arc.x1,\n          arc.y1,\n          arc.x2,\n          arc.y2,\n          arcOpacity,\n          arc.chainDepth\n        );\n      }\n    }\n\n    const coreRadius = this.EXPLOSION_RADIUS * (0.3 + 0.5 * progress);\n    ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.6})`;\n    ctx.beginPath();\n    ctx.arc(bullet.position.x, bullet.position.y, coreRadius, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.fillStyle = `rgba(200, 255, 255, ${alpha})`;\n    ctx.beginPath();\n    ctx.arc(bullet.position.x, bullet.position.y, coreRadius * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  private drawJaggedLightning(\n    ctx: CanvasRenderingContext2D,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    opacity: number,\n    chainDepth: number\n  ): void {\n    const segments = 3 + Math.min(chainDepth, 3);\n    const jitter = 6 + chainDepth * 2;\n    const color = `rgba(0, 230, 255, ${opacity})`;\n    const glowColor = `rgba(100, 230, 255, ${opacity * 0.5})`;\n\n    const points: { x: number; y: number }[] = [];\n    points.push({ x: x1, y: y1 });\n\n    for (let i = 1; i < segments; i++) {\n      const t = i / segments;\n      const baseX = x1 + (x2 - x1) * t;\n      const baseY = y1 + (y2 - y1) * t;\n\n      const offsetX = (Math.random() - 0.5) * jitter * 2;\n      const offsetY = (Math.random() - 0.5) * jitter * 2;\n\n      points.push({ x: baseX + offsetX, y: baseY + offsetY });\n    }\n\n    points.push({ x: x2, y: y2 });\n\n    ctx.strokeStyle = glowColor;\n    ctx.lineWidth = 4;\n    ctx.lineCap = 'round';\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      ctx.lineTo(points[i].x, points[i].y);\n    }\n    ctx.stroke();\n\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      ctx.lineTo(points[i].x, points[i].y);\n    }\n    ctx.stroke();\n  }\n\n  isComplete(): boolean {\n    return this.state === 'COMPLETE';\n  }\n}\n","import { Game } from './game/Game';\nimport { PatternRegistry } from './patterns/PatternRegistry';\nimport { WeaponRegistry } from './weapons/WeaponRegistry';\nimport { PatternType } from './types';\nimport { WeaponType } from './types';\n\n\nimport { ZombieSnow } from './patterns/ZombieSnow';\nimport { SweeperLine } from './patterns/SweeperLine';\nimport { SparseGrid } from './patterns/SparseGrid';\nimport { UltraSparseGrid } from './patterns/UltraSparseGrid';\nimport { BouncingBall } from './patterns/BouncingBall';\nimport { GatlingPoint } from './patterns/GatlingPoint';\nimport { SpiralPattern } from './patterns/SpiralPattern';\nimport { CircleBurstPattern } from './patterns/CircleBurstPattern';\nimport { AimedStreamsPattern } from './patterns/AimedStreamsPattern';\nimport { WavePattern } from './patterns/WavePattern';\nimport { ContainmentRing } from './patterns/ContainmentRing';\nimport { Cyclone } from './patterns/Cyclone';\nimport { ClockSweep } from './patterns/ClockSweep';\n\nimport { Blaster } from './weapons/Blaster';\nimport { Chainsaw } from './weapons/Chainsaw';\nimport { DotRepellent } from './weapons/DotRepellent';\nimport { ElectricBomb } from './weapons/ElectricBomb';\nimport { FlameBurst } from './weapons/FlameBurst';\nimport { HomingMissile } from './weapons/HomingMissile';\nimport { IceBomb } from './weapons/IceBomb';\nimport { KineticBomb } from './weapons/KineticBomb';\nimport { NuclearBomb } from './weapons/NuclearBomb';\nimport { TripleCannon } from './weapons/TripleCannon';\nimport { FireballOrb } from './weapons/FireballOrb';\nimport { TeslaCannon } from './weapons/TeslaCannon';\n\nPatternRegistry.register(PatternType.ZOMBIE_SNOW, ZombieSnow);\nPatternRegistry.register(PatternType.SWEEPER_LINE, SweeperLine);\nPatternRegistry.register(PatternType.SPARSE_GRID, SparseGrid);\nPatternRegistry.register(PatternType.ULTRA_SPARSE_GRID, UltraSparseGrid);\nPatternRegistry.register(PatternType.BOUNCING_BALL, BouncingBall);\nPatternRegistry.register(PatternType.GATLING_POINT, GatlingPoint);\nPatternRegistry.register(PatternType.SPIRAL, SpiralPattern);\nPatternRegistry.register(PatternType.CIRCLE_BURST, CircleBurstPattern);\nPatternRegistry.register(PatternType.AIMED_STREAMS, AimedStreamsPattern);\nPatternRegistry.register(PatternType.WAVE, WavePattern);\nPatternRegistry.register(PatternType.CONTAINMENT_RING, ContainmentRing);\nPatternRegistry.register(PatternType.CYCLONE, Cyclone);\nPatternRegistry.register(PatternType.CLOCK_SWEEP, ClockSweep);\n\nWeaponRegistry.register(WeaponType.BLASTER, Blaster);\nWeaponRegistry.register(WeaponType.CHAINSAW, Chainsaw);\nWeaponRegistry.register(WeaponType.DOT_REPELLENT, DotRepellent);\nWeaponRegistry.register(WeaponType.ELECTRIC_BOMB, ElectricBomb);\nWeaponRegistry.register(WeaponType.FLAME_BURST, FlameBurst);\nWeaponRegistry.register(WeaponType.HOMING_MISSILE, HomingMissile);\nWeaponRegistry.register(WeaponType.ICE_BOMB, IceBomb);\nWeaponRegistry.register(WeaponType.KINETIC_BOMB, KineticBomb);\nWeaponRegistry.register(WeaponType.NUCLEAR_BOMB, NuclearBomb);\nWeaponRegistry.register(WeaponType.TRIPLE_CANNON, TripleCannon);\nWeaponRegistry.register(WeaponType.FIREBALL_ORB, FireballOrb);\nWeaponRegistry.register(WeaponType.TESLA_CANNON, TeslaCannon);\n\n\n\nnew Game();"],"names":["GameState","DotState","PatternType","WeaponType","Difficulty","GameEventType","Renderer","canvasId","canvas","ctx","scale","callback","color","x","y","radius","batch","lineWidth","i","c","byWidth","o","group","x1","y1","x2","y2","width","angle","length","cos","sin","endX","endY","headLength","headAngle","height","text","fontSize","points","PLAYER_VISUAL_RADIUS","PLAYER_HITBOX_RADIUS","PLAYER_MAX_SPEED","PLAYER_ARROW_LENGTH","DOT_RADIUS","DOT_SPAWN_ANIMATION_DURATION","DOT_SPAWN_SCALE_MAX","WEAPON_ORB_RADIUS","COLOR_PLAYER","COLOR_PLAYER_ARROW","COLOR_DOT","COLOR_DOT_SPAWNING","COLOR_DOT_FROZEN","COLOR_BACKGROUND","WEAPON_COLORS","TARGET_FPS","FRAME_TIME","InputManager","basis","error","gamma","beta","orientation","tiltX","tiltY","event","reference","gammaDelta","betaDelta","gameCoords","normalizedX","normalizedY","value","min","max","Vec2","v","other","scalar","mag","distance","a","b","dx","dy","wrapInPlace","position","bounds","circleCollision","radiusA","radiusB","distanceSq","radiiSum","randomPosition","margin","Player","dt","inputVelocity","shouldWrap","renderer","arrowStartX","arrowStartY","ScoringSystem","count","difficulty","bonuses","timeBonus","CELL_SIZE","NEARBY_OFFSETS","CollisionSystem","_bounds","cellX","cellY","dots","dot","pos","key","cell","player","playerPos","playerRadius","nearbyKeys","j","dotPos","dotRadius","orbs","orb","orbPos","orbRadius","PatternRegistryImpl","type","patternClass","PatternClass","PatternRegistry","BASE_INTERVAL","MIN_INTERVAL","MAX_SCORE_SCALING","PatternManager","playerPosition","nextType","pattern","index","logger","score","candidateTypes","randomIndex","completedPattern","scoreRatio","WeaponOrb","weaponType","borderColor","iconScale","branchX","branchY","arrowSize","spacing","arrowX","arrowY","size","skullScale","teethX","teethX2","boneEndRadius","boneEnds","end","numTeeth","innerR","outerR","bulletRadius","bulletX","flames","flameLen","distSq","playerVelocity","now","nx","ny","tx","ty","vDotN","vDotT","restitution","friction","minX","maxX","minY","maxY","WeaponOrbSpawner","attempts","types","WeaponRegistryImpl","weaponClass","WeaponClass","WeaponRegistry","Weapon","_player","_playerVelocity","d","NuclearBomb","_dots","initialPosition","playerSpeed","dirX","dirY","offset","minSpeed","directness","velocityMultiplier","forwardFactor","sidewaysFactor","elapsedTime","progress","warningExplosionRadius","warningStartTime","warningElapsed","flash1Start","flash2Start","shouldShowFlash","explosionElapsed","alpha","color1","color2","factor","r1","g1","b1","r2","g2","b2","r","g","STORAGE_KEY","MAX_HIGHSCORES","getHighscores","data","addHighscore","highscores","newEntry","trimmed","rank","e","GameEventLogger","patternType","dotsSpawned","kills","cause","timestamp","elapsed","seconds","minutes","secs","Game","isLandscape","id","show","el","menuHighscoreList","h","scaleSlider","scaleValue","savedScale","initialScale","centerX","centerY","finalScore","highscoreList","deathReasonElement","eventLogElement","events","currentTime","deltaTime","velocity","allDots","collidingOrb","weapon","destroyedOrbs","destroyedOrb","weaponPos","weaponRadius","collidingDot","FROZEN_BORDER_MAX_THICKNESS","FROZEN_BORDER_COLOR","SPAWN_INV_DURATION","SCALE_RANGE","Dot","patternId","frozenProgress","timeUntilThaw","shakeIntensity","dist","currentRadius","renderX","renderY","Pattern","_renderer","ZombieSnow","_center","SweeperLine","numHoles","lineLength","numDots","holeSet","holeWidthDots","holeCenter","startOffset","_playerPosition","totalSpawnTime","velocityX","velocityY","SparseGrid","speed","cols","rows","row","col","UltraSparseGrid","offsetX","offsetY","BouncingBall","dotsPerRing","ringCount","ring","ringRadius","dotsInThisRing","expectedX","expectedY","displacementX","displacementY","newExpectedX","newExpectedY","GatlingPoint","vel","pulse","SPAWN_LOCATIONS","BulletHellBase","location","w","speedMultiplier","SpiralPattern","arm","baseAngle","speedMult","CircleBurstPattern","angleStep","AimedStreamsPattern","spread","WavePattern","waveWidth","bulletsInWave","waveOffset","ContainmentRing","center","gapCount","gapSize","gaps","gapCenter","gapStart","gapEnd","start","Cyclone","corners","corner","dotCount","offsetAngle","velAngle","ClockSweep","gapIndices","hand","dotInfo","tangentialVx","tangentialVy","Blaster","maxDistance","halfWidth","halfLength","localX","localY","beamFront","beamBack","prevBeamFront","prevBeamBack","sweepStart","sweepEnd","Chainsaw","_dt","isFirstFlashOff","isSecondFlashOff","rotation","innerRadius","outerRadius","nextAngle","DotRepellent","push","ElectricBomb","node","newNode","pendingNodes","activeNodes","n","hasChainNodes","fadeTime","age","opacity","lightningFadeTime","arc","chainDepth","segments","jitter","glowColor","t","baseX","baseY","FlameBurst","trail","flame","angleOffset","jitterX","jitterY","halfConeAngle","angleDiff","coneGradient","MISSILE_RADIUS","MISSILE_COLOR","MISSILE_TRAIL_COLOR","MAX_TURN_RATE","EXPLOSION_MAIN_RADIUS","EXPLOSION_SUB_RADIUS","EXPLOSION_DURATION_MS","EXPLOSION_SUB_DELAY_MS","EXPLOSION_COLOR","HomingMissile","playerVel","playerSpeedInfluence","effectiveSpeed","angles","launchAngle","missile","bestTarget","bestScore","angleToDot","subExplosions","explosion","m","targetPos","angleToTarget","turnAmount","currentSpeed","sub","IceBomb","KineticBomb","collapseRadius","fadeOpacity","TripleCannon","allDone","bullet","FireballOrb","cutoffTime","p","point","prevPoint","flicker","finalAlpha","fizzleProgress","shrinkRadius","glowRadius","gradient","orbGradient","numFlames","wobble","flameLength","flameWidth","startX","startY","TeslaCannon","reversedAngle","nodeAge","nodeOpacity","arcAge","arcOpacity","coreRadius"],"mappings":"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"}